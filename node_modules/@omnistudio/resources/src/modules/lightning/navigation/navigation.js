/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v109.0.0
 */
import { camelCase, kebabCase } from "c/changeCase";
import {
  normalizeParams,
  deNamespace,
  stringifyParams,
} from "c/navigationUtils";

let redirects;
try {
  redirects = require("vlocityoverride/redirects").default;
} catch (err) {
  // no-op, no user-defined redirect are found.
}

class CurrentPageReference {
  update() {}
  connect() {}
  disconnect() {}
}

const n = Symbol("navigate");
const g = Symbol("generateUrl");

const NavigationMixin = (Base) =>
  class extends Base {
    [n](pageReference, replace = false) {
      return this[g](pageReference)
        .then((url) => handleNavigation(pageReference.type, url, replace))
        .then(() => {
          this.dispatchEvent(
            new CustomEvent("routechange", { bubbles: true, composed: true })
          );
        })
        .catch((reason) => {
          if (reason.code === NavigationError.NOT_SUPPORTED) {
            console.warn(reason.message);
          } else {
            throw reason;
          }
        });
    }

    /**
     * @param {(ComponentPageReference | CurrentPageReference | WebPageReference)} pageReference
     */
    [g](pageReference) {
      return Promise.resolve(generateUrl(pageReference));
    }
  };

/**
 *
 * @param {PageReference["type"]} type
 * @param {string} url
 * @param {boolean} replace
 */
function handleNavigation(type, url, replace) {
  if (VLOCITY_SPA_NAVIGATION) {
    if (type === "standard__webPage") return handleWebNavigation(url, replace);
    return handleAppNavigation(url, replace);
  } else {
    return handleWebNavigation(url, replace);
  }
}

function handleAppNavigation(url, replace) {
  if (replace) {
    history.replaceState(null, null, url);
  } else {
    history.pushState(null, null, url);
  }
}

function handleWebNavigation(url, replace) {
  if (replace) {
    location.replace(url);
  } else {
    location.assign(url);
  }
}

function generateUrl(pageReference) {
  redirects;
  let url;
  switch (pageReference.type) {
    case "standard__app":
      url = generateAppUrl(pageReference);
      break;
    case "standard__component":
      url = generateComponentUrl(pageReference);
      break;
    case "standard__navItemPage":
      url = generateNavItemPageUrl(pageReference);
      break;
    case "standard__objectPage":
      url = generateObjectUrl(pageReference);
      break;
    case "standard__recordPage":
      url = generateRecordUrl(pageReference);
      break;
    case "standard__recordRelationshipPage":
      url = generateRecordRelationshipUrl(pageReference);
      break;
    case "standard__webPage":
      url = generateWebPageUrl(pageReference);
      break;
    case undefined:
      url = location.pathname;
      break;
    default:
      url = `/${Object.values(pageReference.attributes)
        .map((part) => kebabCase(part))
        .join("/")}`;
      break;
  }

  if (redirects) url = getRedirectUrl(url);

  if (pageReference.state) {
    const queryString = stringifyParams(pageReference.state, "");
    if (queryString !== "?") url = `${url}${queryString}`;
  }

  return url;
}

function generateAppUrl(pageReference) {
  const [appName] = deNamespace(pageReference.attributes.appTarget);
  let url = `/${kebabCase(appName)}`;
  if (pageReference.attributes.pageRef)
    url += generateUrl(pageReference.attributes.pageRef);
  return url;
}

function generateComponentUrl(pageReference) {
  if (!pageReference.attributes.componentName) return "";

  const params = normalizeParams(pageReference.state);
  let [componentName, namespace] = deNamespace(
    pageReference.attributes.componentName
  );

  if (componentName === "vlocityLWCWrapper") {
    namespace = COMPONENT_NAMESPACE;
    [componentName] = deNamespace(params.target);
  }

  if (componentName === "vlocityLWCOmniWrapper") {
    namespace = OMNISCRIPT_NAMESPACE;
    [componentName] = deNamespace(params.target);
    params.target = undefined;
  }

  return `/${namespace}/${camelCase(componentName)}`;
}

function generateNavItemPageUrl(pageReference) {
  const [pageName] = deNamespace(pageReference.attributes.apiName);
  return `/${kebabCase(pageName)}`;
}

function generateObjectUrl(pageReference) {
  return `/o/${kebabCase(pageReference.attributes.objectApiName)}${
    pageReference.attributes.actionName
      ? "/" + pageReference.attributes.actionName
      : ""
  }`;
}

function generateRecordUrl(pageReference) {
  pageReference.state = {
    ...pageReference.state,
    ...{ id: pageReference.attributes.recordId },
  };
  return `/r/${kebabCase(pageReference.attributes.objectApiName)}`;
}

function generateRecordRelationshipUrl(pageReference) {
  const url = generateRecordUrl(pageReference);
  pageReference.state = {
    ...pageReference.state,
    ...{ rel: pageReference.attributes.relationshipApiName }
  }
  return url;
}

function generateWebPageUrl(pageReference) {
  return pageReference.attributes.url;
}

function getRedirectUrl(url) {
  let redirect;

  // get exact match url
  if (redirects.has(url)) {
    redirect = redirects.get(url);
  }

  // find wild card matches
  if (!redirect) {
    for (let path of redirects.keys()) {
      if (
        path.indexOf("*") > 0 &&
        new RegExp(path.replace("*", ".*")).test(url)
      ) {
        redirect = redirects.get(path);
        break;
      }
    }
  }

  return redirect || url;
}

class NavigationError extends Error {
  static NOT_SUPPORTED = "ENOTSUPPORTED";
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}

NavigationMixin.__proto__.Navigate = n;
NavigationMixin.__proto__.GenerateUrl = g;

export { CurrentPageReference, NavigationMixin };
