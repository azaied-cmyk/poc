/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v109.0.0
 */
import { api, LightningElement } from "lwc";
import {
  lwcToGoogleLatLng,
  DEFAULT_CENTER,
  DEFAULT_ZOOM,
  MAPS_NOT_AVAILABLE_MESSAGE,
  SCRIPT_EXAMPLE,
  SCRIPT_REFERENCE,
} from "./mapConstants";
import tmpl from "./map.html";
import errTmpl from "./mapError.html";
export default class map extends LightningElement {
  //#region Component Attributes
  /**
   * A location to use as the map's center.
   * If center is not specified, the map centers automatically.
   * @type {MapMarker}
   * @todo - Support type {AddressLocation} which would require geocoding the address to get the coordinates.
   */
  @api get center() {
    return this._center;
  }
  set center(value) {
    this._center = value;
    if (this.mapInterface) {
      this.mapInterface.setCenter(lwcToGoogleLatLng(this._center.location));
    }
  }

  /**
   * Displays or hides the list of locations. Valid values are visible, hidden, or auto.
   * This value defaults to auto, which shows the list only when multiple markers are present.
   * Passing in an invalid value hides the list view.
   * @type {'visible' | 'hidden' | 'auto'}
   * @enum
   * @todo - This feature is currently unsupported.
   */
  @api listView = "auto";

  /**
   * One or more objects with the address or latitude and longitude to be displayed on the map.
   * If latitude and longitude are provided, the address is ignored.
   * @type {MapMarker[]}
   */
  @api get mapMarkers() {
    return this._mapMarkers;
  }

  set mapMarkers(value) {
    if (this.mapInterface) this.settMapMarkers(value);
  }

  /**
   * Provides the heading title for the markers. Required if specifying multiple markers.
   * The title is displayed below the map as a header for the list of clickable addresses.
   * @type {string}
   * @todo - This feature is currently unsupported.
   */
  @api markersTitle;

  /**
   * Provides the value of the currently selected marker.
   * Returns undefined if you donâ€™t pass value to map-markers.
   * @type {string}
   * @todo - This feature is currently unsupported.
   */
  @api selectedMarkerValue;

  /**
   * If present, the footer element is displayed below the map.
   * The footer shows an 'Open in Google Maps' link that opens an external window
   * to display the selected marker location in Google Maps. Default value is false.
   * @type {boolean}
   * @todo - This feature is currently unsupported.
   */
  @api showFooter = false;

  /**
   * The zoom levels as defined by Google Maps API.
   * If a zoom level is not specified, a default zoom level is applied to accommodate all markers on the map.
   * @type {number}
   */
  @api get zoomLevel() {
    return this._zoomLevel;
  }
  set zoomLevel(value) {
    if (!isNaN(value)) {
      this._zoomLevel = Number(value);

      if (this.mapInterface) {
        this.mapInterface.setZoom(this._zoomLevel);
      }
    }
  }
  //#endregion Component Attributes

  //#region Private Fields
  /**
   * If the google maps api is not available, this boolean will prevent console errors
   * and display aa helpful prompt on the UI.
   * @type {boolean}
   */
  _error = !Object.prototype.hasOwnProperty.call(window, "google");

  /**
   * Message displayed when maps has not loaded.
   * @type {string}
   */
  _errorMessage = MAPS_NOT_AVAILABLE_MESSAGE;

  /**
   * A sample of the script tag to include in the header. Displayed when maps has not loaded.
   * @type {string}
   */
  _scriptExample = SCRIPT_EXAMPLE;

  /**
   * A reference link to google's documentation describing how to include the api.
   * @type {string}
   */
  _scriptReference = SCRIPT_REFERENCE;

  /**
   * Has the first render cycle completed?
   * @type {boolean}
   */
  _isFistRenderComplete = false;

  /**
   * The DOM element which the map wil be appended to.
   * @type {HTMLElement}
   */
  _mapContainer;
  //#endregion Private Fields

  /**
   * A convenience method to set the value of this.mapMarkers, without violating api decorator rules.
   * @param {MapMarker[]} markers
   */
  settMapMarkers(markers) {
    this.clearMarkers();
    this._mapMarkers = markers;

    const BOUNDS = new google.maps.LatLngBounds();

    this._mapMarkers.forEach((marker) => {
      const position = lwcToGoogleLatLng(marker.location);
      this._gMarkers.push(
        new google.maps.Marker({
          animation: google.maps.Animation.DROP,
          position: position,
          map: this.mapInterface,
        })
      );
      BOUNDS.extend(position);
      if (markers.length === 1) {
        BOUNDS.extend({
          lat: position.lat() - 0.01,
          lng: position.lng() - 0.01,
        });
        BOUNDS.extend({
          lat: position.lat() + 0.01,
          lng: position.lng() + 0.01,
        });
      }
    });
    // && !this._zoomLevel
    if (!this._center) {
      this.mapInterface.fitBounds(BOUNDS);
    }
  }

  /**
   * Removes markers from the map UI.
   */
  clearMarkers() {
    if (this._gMarkers) this._gMarkers.forEach((marker) => marker.setMap(null));

    this._gMarkers = [];
  }

  /**
   * Initialize the google map UI, and store a reference of the interface.
   */
  initMap() {
    this.mapInterface = new google.maps.Map(this._mapContainer, {
      center: lwcToGoogleLatLng(
        this._center ? this._center.location : DEFAULT_CENTER.location
      ),
      gestureHandling: "cooperative",
      zoom: this._zoomLevel ? this._zoomLevel : DEFAULT_ZOOM,
    });

    if (this._mapMarkers) this.settMapMarkers(this._mapMarkers);
  }

  render() {
    if (this._error === false) return tmpl;
    return errTmpl;
  }

  renderedCallback() {
    if (this._isFistRenderComplete !== true) {
      if (this._error === true) return;
      this._mapContainer = this.template.querySelector("[data-map-container]");
      this.initMap();
      this._isFistRenderComplete = true;
    }
  }
}
