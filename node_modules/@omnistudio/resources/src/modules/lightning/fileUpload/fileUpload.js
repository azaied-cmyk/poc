/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v109.0.0
 */
import { LightningElement, api, track } from 'lwc';
import fakeProgress from 'fake-progress';
import { getConnection } from 'c/omniscriptConnection';
import { getIconPath } from 'lightning/iconUtils';

export default class FileUpload extends LightningElement {

    @api accept;
    @api disabled;
    @api label;
    @api multiple;
    @api name;
    @api recordId;

    @track hasError = false;
    @track modalOpen = false;
    @track selectedFiles = [];
    @track doneDisabled = true;
    @track utilitySpriteUrl = getIconPath('utility:close');
    uploadedFileIds = [];

    connectedCallback() {
        this.changeEventCallback = this.onInputChange.bind(this);
    }

    disconnectedCallback() {
        this.getInput().removeEventListener('change', this.changeEventCallback);
    }

    renderedCallback() {
        this.getInput().addEventListener('change', this.changeEventCallback);
    }

    getInput() {
        return this.template.querySelector('.slds-file-selector__input');
    }


    onInputChange(evt) {
        const item = this.getInput();

        // Get the list of files we are going to upload
        const arrFiles = Array.from(item.files);

        // Skip if no files were selected
        if (arrFiles.length === 0) {
            return;
        }

        this.selectedFiles = arrFiles.map(file => {
            return {
                name: file.name,
                size: file.size,
                formattedSize: this.formatBytes(file.size),
                type: file.type,
                progress: 0,
                progressColor: '',
                actionIcon: 'utility:close',
                altText: 'Upload of file ' + file.name,
                hasErrors: false,
                errorMessage: 'Can\'t upload ' + file.name,
                clickableIcon: true,
                canceled: false
            }
        });

        this.modalOpen = true;
        this.doneDisabled = true;

        const promise = arrFiles.reduce((previous, file, idx) => {

            // If canceled, skip and resolve
            if (this.selectedFiles[idx].canceled) {
                return previous.then(ids => Promise.resolve(ids));
            }

            return previous.then(ids => {
                return new Promise((resolve, reject) => {
                    this.readFile(file)
                        .then(binary => this.uploadFile(this.selectedFiles[idx], idx, binary))
                        .then(result => {
                            if (result) {
                                ids.push(result);
                            }
                            resolve(ids);
                        })
                        .catch(reject)
                });
            });
        }, Promise.resolve([]));

        promise.then((ids) => {
            this.uploadedFileIds = ids;
            this.doneDisabled = false;
        });
    }

    readFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = loadEvt => {
                resolve(loadEvt.target.result);
            }
            reader.onerror = reject;
            reader.readAsBinaryString(file);
        });
    }

    uploadFile(file, idx, binaryFile) {

        // If canceled, skip and resolve
        if (file.canceled) {
            return Promise.resolve();
        }

        // Update the action icon
        file.actionIcon = 'utility:upload';
        file.clickableIcon = false;

        // Create a fake progress to simulate that we are uploading the file.
        const constant = file.size < 1000000 ? 5000 : Math.round(file.size / 100);
        const progress = new fakeProgress({
            autoStart: true,
            timeConstant: constant
        });

        // An async function that will update the "fake" progress
        const progressCheck = () => {
            file.progress = (progress.progress * 100).toFixed(1);
        }

        // Update the fake progress each second
        const interval = setInterval(progressCheck, 1000);

        // Start constructing the file
        const path = '/services/data/v48.0';
        let result = null;

        // Temp
        const conn = getConnection();

        return conn.request(path + '/composite/', {
            'allOrNone': true,
            'compositeRequest': [
                {
                    'method': 'POST',
                    'url': path + '/sobjects/ContentVersion',
                    'referenceId': 'newFile',
                    'body': {
                        'Title': file.name,
                        'PathOnClient': file.name,
                        'VersionData': btoa(binaryFile),
                        'FirstPublishLocationId': this.recordId
                    }
                },
                {
                    'method': 'GET',
                    'url': path + '/sobjects/ContentVersion/@{newFile.id}',
                    'referenceId': 'docId'
                },
                {
                    'method': 'POST',
                    'url': path + '/sobjects/ContentDistribution',
                    'referenceId': 'newContDist',
                    'body': {
                        'Name': file.name + ' Public Share',
                        'ContentVersionId': '@{newFile.id}'
                    }
                },
                {
                    'method': 'GET',
                    'url': path + '/sobjects/ContentDistribution/@{newContDist.id}',
                    'referenceId': 'contDist'
                }
            ]
        })
            .then(this.validateCompositeResponse)
            .then(function (response) {

                // get new file id
                let contentVersionId = null,
                    contentDocumentId = null,
                    publicUrl = null;
                for (let i = 0; i < response.compositeResponse.length; i++) {
                    if (response.compositeResponse[i].referenceId === 'newFile') {
                        contentVersionId = response.compositeResponse[i].body.id;
                    } else if (response.compositeResponse[i].referenceId === 'docId') {
                        contentDocumentId = response.compositeResponse[i].body.ContentDocumentId;
                    } else if (response.compositeResponse[i].referenceId === 'contDist') {
                        publicUrl = response.compositeResponse[i].body.ContentDownloadUrl;
                    }
                }

                // Complete the progress
                file.progress = 100;
                file.progressColor = 'success';
                file.actionIcon = 'action:approval';

                // ... do something with the new file id
                result = {
                    documentId: contentDocumentId,
                    documentVersionId: contentVersionId,
                    publicUrl: publicUrl,
                    name: file.name
                }

            }).catch(function (err) {

                console.error(err);
                // ... show error to user

                file.hasErrors = true;

            }).then(function () {
                progress.end();
                clearInterval(interval);
                return result;
            });
    }



    onDoneClick(evt) {
        this.modalOpen = false;

        if (this.uploadedFileIds.length > 0) {
            this.dispatchEvent(new CustomEvent('uploadfinished', {
                detail: {
                    files: this.uploadedFileIds
                }
            }));
        }

        this.selectedFiles = [];
        this.uploadedFileIds = [];
    }

    formatBytes(value, format = 0) {

        // format == 0 -> SI
        // format == 1 -> IEC
        const [multiple, k, suffix] = (format === 0
            ? [1000, 'k', 'B']
            : [1024, 'K', 'iB']);

        const exp = (Math.log(value) / Math.log(multiple)) | 0,
            decimals = exp > 1 ? 1 : 0;

        // or, if you'd prefer not to use bitwise expressions or disabling tslint rules, remove the line above and use the following:
        // const exp = value === 0 ? 0 : Math.floor(Math.log(value) / Math.log(multiple)) 
        const size = Number((value / Math.pow(multiple, exp)).toFixed(decimals));

        console.log(exp);

        return {
            size,
            suffix: (exp
                ? (k + 'MGTPEZY')[exp - 1] + suffix
                : 'byte' + (size !== 1 ? 's' : ''))
        };
    }

    /**
     * Checks each sub-response for an error code
     * and throws error if finds one, else does nothing.
     * @param {Object} response 
     */
    validateCompositeResponse(response) {

        return new Promise(function (resolve, reject) {
            for (let i = 0; i < response.compositeResponse.length; i++) {

                let body = response.compositeResponse[i].body[0];

                // ignore the 'processing halted' messages as that just indicates
                // that sub-request wasn't the one that blew up, keep looking
                if (body && body.errorCode && body.errorCode != 'PROCESSING_HALTED') {
                    reject(body.message);
                }

            }

            resolve(response);
        });
    }

    onFileRemoveClick(evt) {
        const idx = evt.target.getAttribute('data-idx');

        this.selectedFiles[idx].canceled = true;
    }
}