/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { LightningElement, api, track } from "lwc";
import { LOCALE, CURRENCY, TIMEZONE } from "c/salesforceUtils";
import { get } from "c/lodash";
import {
  formatCurrency,
  formatDate,
  inputMask,
  getDateTimeLocaleFormat,
  lwcPropertyNameConversion
} from "c/utility";
import { BaseFlexElementMixin } from "c/baseFlexElementMixin";
export default class OutputField extends BaseFlexElementMixin(
  LightningElement
) {
  @api label;
  @api record;
  @api fieldName;
  @api type = "string";
  @api placeholder;
  @api extraclass = "";
  @api mask;
  @api set mergeField(val) {
    if (val) {
      this._mergeField = decodeURI(val);
    }
  }
  get mergeField() {
    return this._mergeField;
  }
  @api preventNavigation = false;
  @api labelclass;
  @api valueclass;
  @api format;
  @api theme = "slds";
  @api updatedFieldValue;
  @api locale;
  @api currency;
  @api fieldLabel;
  @api useAbsoluteDate;
  @api get fieldTitle() {
    return this._fieldTitle
      ? this._fieldTitle
      : this.fieldLabel
      ? this.fieldLabel
      : this.fieldValue;
  }
  set fieldTitle(val) {
    this._fieldTitle = val;
  }

  @api get styles() {
    return this._styles;
  }

  set styles(val) {
    const fetchStyles = type => {
      if (val[type]) {
        let keys = Object.keys(val[type]);
        keys.forEach(key => {
          if (val[type][key]) {
            if (key !== "textAlign") {
              let styleKeyName = type === "label" ? "labelStyle" : "valueStyle";
              this[styleKeyName] += `${lwcPropertyNameConversion(key)}:${
                val[type][key]
              };`;
            } else {
              let alignKeyName = type === "label" ? "labelAlign" : "valueAlign";
              this[
                alignKeyName
              ] = `${this.theme}-text-align--${val[type][key]}`;
            }
          }
        });
      }
    };
    val = val ? (typeof val === "string" ? this.validObj(val) : val) : {};
    this._styles = val;
    this.labelStyle = "";
    this.labelAlign = "";
    this.valueStyle = "";
    this.valueAlign = "";
    if (val) {
      fetchStyles("label");
      fetchStyles("value");
    }
  }
  @track _fieldTitle;
  @track isTypeUrl = false;
  @track _mergeField;
  @track labelStyle = "";
  @track labelAlign = "";
  @track valueStyle = "";
  @track valueAlign = "";
  // eslint-disable-next-line no-script-url
  urlHref = "javascript:void(0)";

  validObj = str => {
    try {
      return JSON.parse(str);
    } catch (e) {
      return {};
    }
  };

  get labelClass() {
    return `${this.theme}-show--inline ${this.theme}-form-element__label  ${
      this.labelclass ? this.labelclass : ""
    }`;
  }

  get fieldValueClass() {
    return `field-value ${this.valueclass ? this.valueclass : ""}`;
  }
  get _extraClass() {
    return this.extraclass + " vloc-min-height";
  }
  get interpolatedLabel() {
    if (this.label.indexOf("{") !== -1) {
      let stringToInterpolate = this.label;
      return stringToInterpolate.replace(/\{(.*?)\}/g, (match, expr) => {
        let fieldValue = get(this.record, expr);
        if (this._allMergeFields && !fieldValue) {
          fieldValue = get(this._allMergeFields, expr);
        }
        return typeof fieldValue !== "undefined" ? fieldValue : "";
      });
    }
    return this.label;
  }

  renderedCallback() {
    if (!this.isRendered && this.type === "url") {
      this.isTypeUrl = true;
      this.isRendered = true;
    }
    const container = this.template.querySelector(".richTextContainer");
    if (container) {
      container.innerHTML = this.fieldValue;
    }
  }

  get isMergeField() {
    return this.mergeField ? true : false;
  }

  get fieldValue() {
    if (this.mergeField) {
      if (this.mergeField.indexOf("{") !== -1) {
        return this.interpolateValue(this.mergeField);
      }
      return this.mergeField;
    }
    const validObj = value => {
      try {
        if (value.charAt(0) === "\\") {
          value = value.substring(1);
        }
        return JSON.parse(value);
      } catch (e) {
        return {};
      }
    };
    let record =
      typeof this.record === "string" ? validObj(this.record) : this.record;
    if (this.updatedFieldValue) {
      return this.updatedFieldValue;
      //eslint-disable-next-line no-else-return
    } else {
      if (this.fieldName && this.fieldName.indexOf("{") !== -1) {
        return this.interpolateValue(this.fieldName);
      }
      return this.formatField(get(record, this.fieldName), this.type);
    }
  }

  interpolateValue(value) {
    let stringToInterpolate = value;
    return stringToInterpolate.replace(/\{(.*?)\}/g, (match, expr) => {
      let fieldValue = get(this.record, expr);
      if (this._allMergeFields && !fieldValue) {
        fieldValue = get(this._allMergeFields, expr);
      }
      return typeof fieldValue !== "undefined" ? fieldValue : "";
    });
  }

  get placeholderValue() {
    return (
      this.placeholder &&
      this.placeholder.replace(/\{(.*?)\}/g, (match, expr) => {
        let fieldValue = get(this.record, expr);
        if (this._allMergeFields && !fieldValue) {
          fieldValue = get(this._allMergeFields, expr);
        }
        return typeof fieldValue !== "undefined" ? fieldValue : "";
      })
    );
  }

  formatUsPhone(phone) {
    let phoneTest = new RegExp(
      /^((\+1)|1)? ?\(?(\d{3})\)?[ .-]?(\d{3})[ .-]?(\d{4})( ?(ext\.? ?|x)(\d*))?$/
    );
    phone = phone.trim();
    let results = phoneTest.exec(phone);
    if (results !== null && results.length > 8) {
      return (
        "(" +
        results[3] +
        ") " +
        results[4] +
        "-" +
        results[5] +
        (typeof results[8] !== "undefined" ? " x" + results[8] : "")
      );
    }
    return phone;
  }

  getLocaleFormat(type) {
    let userLocale = this.locale || LOCALE || "en_US";
    let localeFormat = getDateTimeLocaleFormat(userLocale);
    if (type === "date" && localeFormat) {
      localeFormat = localeFormat.substr(0, localeFormat.indexOf(" "));
    }
    return localeFormat;
  }

  formatDate(date) {
    let dateMask;
    let formattedValue;
    date = this.getDateToFormat(date);
    if (!this.format && date) {
      const options = {
        timeZone: this.useAbsoluteDate ? undefined : TIMEZONE
      };
      const dateTimeFormat = new Intl.DateTimeFormat(LOCALE, options);
      formattedValue = dateTimeFormat.format(new Date(date));
    } else {
      dateMask = this.format ? this.format.replace(/y/g, "Y") : this.format;
      if (date && dateMask) {
        let value = formatDate(date, dateMask);
        formattedValue = value ? value : date;
      }
    }

    return formattedValue;
  }

  formatDateTime(date) {
    let dateTimeMask;
    let formattedValue;
    if (!this.format && date) {
      const options = {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        timeZone: TIMEZONE
      };
      const dateTimeFormat = new Intl.DateTimeFormat(LOCALE, options);
      formattedValue = dateTimeFormat.format(new Date(date));
    } else {
      dateTimeMask = this.format ? this.format.replace(/y/g, "Y") : this.format;

      if (date && dateTimeMask) {
        let value = formatDate(date, dateTimeMask);
        formattedValue = value ? value : date;
      }
    }
    return formattedValue;
  }

  formatNumber(val) {
    let maskedValue = "";
    if (this.mask) {
      maskedValue = inputMask(val, this.mask);
    } else if (!this.mask && val && !isNaN(val)) {
      maskedValue = new Intl.NumberFormat(LOCALE).format(val);
    }
    return maskedValue ? maskedValue : val;
  }

  /* eslint-disable consistent-return */
  formatCurrency(amount) {
    let value = amount; //this might be a string like $5.00
    if (!isNaN(amount)) {
      try {
        value = formatCurrency(amount, {
          anlocale: this.locale || LOCALE || "en-US",
          money: this.currency || CURRENCY || "USD"
        });
        return value;
      } catch (e) {
        // handle error
      }
    }
    return value; //null or undefined or string
  }
  /* eslint-enable consistent-return */

  formatAddress(address) {
    if (!address) return "";

    let add = [
      address.street || address.Street,
      address.city || address.City,
      address.state || address.State,
      address.postalCode || address.PostalCode,
      address.country || address.Country
    ].filter(val => val != null);

    if (add.length === 0 && (address.Latitude || address.latitude)) {
      return (
        "Longitude: " +
        (address.longitude || address.Longitude) +
        "; Latitude: " +
        (address.latitude || address.Latitude)
      );
    }

    return add.join(", ");
  }

  formatField(input, type) {
    let val = input;
    /* eslint-disable default-case */
    switch (type) {
      case "number":
        val = this.formatNumber(val);
        break;
      case "currency":
        // $ **,***.**
        val = this.formatCurrency(val);
        break;
      case "date":
        // mm/dd/yy
        val = this.formatDate(val);
        break;
      case "datetime":
        // mon dd, yyyy hh:mm AM/PM
        val = this.formatDateTime(val);
        break;
      case "percentage":
      case "percent":
        val = parseFloat(input);
        val = !isNaN(val) ? val + "%" : "";
        break;
      case "phone":
        // (***) ***-****
        val = this.formatUsPhone(val);
        break;
      case "address":
        // stree,city,state,postalcode,country
        val = this.formatAddress(val);
        break;
      case "checkbox":
        // true,false
        val = typeof val === "boolean" ? val.toString() : val;
        break;
      case "url":
        // website link, hyperlink
        if (val && !this.preventNavigation) this.urlHref = val;
        break;
      case "text":
        // If text contains a boolean value, then return it as true/false
        val = typeof val === "boolean" ? val.toString() : val;
        break;
    }
    /* eslint-enable default-case */
    return val;
  }
  getDateToFormat(date) {
    if (
      this.useAbsoluteDate &&
      date &&
      new Date(date).toDateString() !== "Invalid Date" &&
      date.split("T").length > 1
    ) {
      return date.split("T")[0];
    }
    return date;
  }
}
