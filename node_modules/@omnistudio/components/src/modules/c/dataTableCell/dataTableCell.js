/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { LightningElement, api, track } from "lwc";
import { formatDate } from "c/utility";
export default class DataTableCell extends LightningElement {
  @api columnData;
  @api cellData;
  @api iconUrl;
  @api theme = "slds";
  @api rowData = {};
  @api dateFormat;
  @api isCustomUi;
  @api cellWrapperClass;

  _isCheckBoxFocused = false;
  _checkBoxEventCount = 1;
  hasError = false;
  @api
  get cellElem() {
    return this.cellData.label
      ? null
      : this.template.querySelector(".editableField");
  }

  get fieldType() {
    if (this.columnData && this.columnData.type && this.cellData) {
      return this.columnData.type;
    }
    return "string";
  }

  get outputFieldClass() {
    return `${this.theme}-show_inline-block`;
  }

  get iconClass() {
    return `hover-icon ${this.theme}-transition-hide`;
  }

  get showOutputField() {
    return this.cellData.label && this.columnData.type !== "icon";
  }

  get showIconField() {
    return (
      this.cellData.label &&
      this.columnData.type === "icon" &&
      this.cellData.value === true
    );
  }

  get checkBoxType() {
    return this.cellData.checkbox || this.cellData.icon;
  }
  get actionIconClass() {
    return `${this.theme}-p-around_xxx-small ${this.theme}-icon_container--circle ${this.theme}-float_left`;
  }
  get dataTableCellClass() {
    let cellClass = "";
    if (this.fieldType === "checkbox") {
      cellClass = "checkBoxCell";
    }
    if (this.isCustomUi === "true" || this.isCustomUi) {
      cellClass = cellClass + " tableRowCell";
    }
    if (this.cellData.label && this.theme === "nds") {
      cellClass = cellClass + " top-padding";
    }
    if (this.cellWrapperClass) {
      cellClass = cellClass + ` ${this.cellWrapperClass}`;
    }
    return cellClass;
  }
  get preventNavigation() {
    return this.columnData.type === "url" && this.columnData.preventNavigation;
  }

  @track percentMask = {
    mask: Number(),
    radix: "."
  };

  fireEvent(eventName, data) {
    let event = new CustomEvent(eventName, {
      bubbles: true,
      composed: true,
      detail: {
        result: data || ""
      }
    });
    this.dispatchEvent(event);
  }

  checkValidity(event) {
    this.hasError = !event.currentTarget.reportValidity();
  }

  editDataCell(event) {
    event.stopPropagation();
    this.fireEvent("click", this.cellData.value);
    // blur event gets triggered on checkbox on second click, making sure that click happened outside checkbox
    if (event.target.dataset && event.target.dataset.checkbox) {
      if (!this._isCheckBoxFocused) this.fireEvent("edit", event);
    } else if (!this.hasError) {
      this.fireEvent("edit", event);
    } else if (this.hasError) {
      event.target.value = this.cellData.date
        ? formatDate(this.cellData.value, this.dateFormat)
        : this.cellData.value;
      this.fireEvent("edit", event);
    }
  }

  onClickFieldValue(event) {
    event.stopPropagation();
    // onclick event gets triggered twice on checkbox, this is to avoid that
    if (event.target.dataset && event.target.dataset.checkbox) {
      if (this._checkBoxEventCount === 1) {
        this._checkBoxEventCount++;
        this.fireEvent("click", this.cellData.value);
      } else {
        this._checkBoxEventCount = 1;
      }
    } else {
      this.fireEvent("click", this.cellData.value);
    }
  }

  mouseoverField(event) {
    const target = event.currentTarget;
    const hoverIcon = target.querySelector(".hover-icon");
    if (!hoverIcon) {
      return;
    }
    hoverIcon.classList.remove(`${this.theme}-transition-hide`);
    event.stopPropagation();
  }

  mouseoutField(event) {
    const target = event.currentTarget;
    const hoverIcon = target.querySelector(".hover-icon");
    if (hoverIcon) {
      hoverIcon.classList.add(`${this.theme}-transition-hide`);
    }
    event.stopPropagation();
  }
  mouseoverLeaveBox() {
    this._isCheckBoxFocused = false;
  }
  focusCheckbox(event) {
    //checkbox needs to be focused in firebox to trigger blur event
    event.target.focus();
    this._isCheckBoxFocused = true;
  }
}
