/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { getSdkInstanceOut } from "./sdkInstanceOut";
import { DatasourceInputTypes } from "./datasourceInputTypesOut";

/**
 * sdkDataHandlerOut is used to call sdk utility metods based on request type.
 * @param {*} requestData
 * @return {*} promise which contains response data
 */
const sdkDataHandlerOut = requestData => {
  const sdkInstance = getSdkInstanceOut();
  const requestDataValue = requestData.value;
  let defaultRequest;
  let finalRequest;
  let inputMapObj =
    typeof requestDataValue.inputMap === "string"
      ? JSON.parse(requestDataValue.inputMap)
      : requestDataValue.inputMap || {};
  let optionsMapObj =
    typeof requestDataValue.optionsMap === "string"
      ? JSON.parse(requestDataValue.optionsMap)
      : requestDataValue.optionsMap || {};
  switch (requestData.type.toLowerCase()) {
    case DatasourceInputTypes.APEXREMOTE:
      defaultRequest = {
        method: "POST",
        path: `/services/apexrest/${sdkInstance.namespace}/v1/invoke`,
        body: {
          sClassName: requestDataValue.className,
          sMethodName: requestDataValue.methodName,
          input: requestDataValue.inputMap || "{}",
          options: requestDataValue.optionsMap || "{}"
        },
        options: requestDataValue.options || {}
      };
      finalRequest = Object.assign(defaultRequest, requestDataValue);
      return sdkInstance
        .apexRest(sdkInstance.apexRestInput(finalRequest))
        .execute();
    case DatasourceInputTypes.APEXREST:
      defaultRequest = {
        method: requestDataValue.methodType,
        path: requestDataValue.endpoint,
        body: requestDataValue.payload,
        options: requestDataValue.options
      };
      finalRequest = Object.assign(defaultRequest, requestDataValue);
      return sdkInstance
        .apexRest(sdkInstance.apexRestInput(finalRequest))
        .execute();
    case DatasourceInputTypes.REST:
      defaultRequest = {
        method: requestDataValue.methodType,
        path: requestDataValue.endpoint,
        body: requestDataValue.data,
        options: requestDataValue.options
      };
      finalRequest = Object.assign(defaultRequest, requestDataValue);
      return sdkInstance
        .apexRest(sdkInstance.apexRestInput(finalRequest))
        .execute();
    case DatasourceInputTypes.DATARAPTOR:
      requestDataValue.inputMap = inputMapObj;
      defaultRequest = {
        bundleName: requestDataValue.bundleName,
        inputMap: requestDataValue.inputMap
      };
      finalRequest = Object.assign(defaultRequest, requestDataValue);
      return sdkInstance
        .dataRaptor(sdkInstance.dataRaptorInput(finalRequest))
        .execute();
    case DatasourceInputTypes.INTEGRATIONPROCEDURE:
      requestDataValue.inputMap = inputMapObj;
      requestDataValue.optionsMap = optionsMapObj;
      defaultRequest = {
        procedureKey: requestDataValue.ipMethod,
        input: requestDataValue.inputMap,
        optionsMap: requestDataValue.optionsMap,
        rest: requestDataValue.rest || { method: "GET" }
      };
      finalRequest = Object.assign(defaultRequest, requestDataValue);
      return sdkInstance
        .integrationProcedure(
          sdkInstance.integrationProcedureInput(finalRequest)
        )
        .execute();
    case DatasourceInputTypes.SOQL:
      defaultRequest = {
        query: requestDataValue.query
      };
      finalRequest = Object.assign(defaultRequest, requestDataValue);
      return sdkInstance.soql(sdkInstance.soqlInput(finalRequest)).execute();
    case DatasourceInputTypes.SOSL:
      if (requestDataValue.fields) {
        let searchFor = requestDataValue.search;
        let fields = requestDataValue.fields;
        let limitTo = requestDataValue.limitTo;
        let objectMap = requestDataValue.objectMap;

        let findQuery = "Find {" + searchFor + "} IN " + fields;

        let returningObj = [];
        for (let key in objectMap) {
          let retObj = objectMap[key] ? key + "(" + objectMap[key] + ")" : key;
          returningObj.push(retObj);
        }

        let retObjStr = returningObj ? returningObj.join() : "";

        if (retObjStr) {
          findQuery = findQuery + " RETURNING " + retObjStr;
        }
        if (limitTo) {
          findQuery = findQuery + " LIMIT " + limitTo;
        }

        requestDataValue.search = findQuery;
      }
      defaultRequest = {
        query: requestDataValue.search
      };
      finalRequest = Object.assign(defaultRequest, requestDataValue);
      return sdkInstance.sosl(sdkInstance.soslInput(finalRequest)).execute();
    default:
      throw new Error(`Unknown datsource type ${data.type}`);
  }
};

export { sdkDataHandlerOut };
