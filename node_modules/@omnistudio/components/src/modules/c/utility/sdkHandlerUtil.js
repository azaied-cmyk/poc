/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { loadJsFromStaticResource } from "./utility";
import { getResourceUrl } from "c/salesforceUtils";
import { getSDKInstance, isSDKInstanceAvailable } from "./sdkUtil";
import { namespace } from "./namespace";

function fetchActionRegistryData(filterType) {
  return getResourceUrl({
    resourceName: "OmniStudioActionRegistry"
  }).then(resourceUrl => {
    if (resourceUrl) {
      return fetch(resourceUrl)
        .then(response => {
          return response.json();
        })
        .then(data => {
          return filterType ? filterRegisteryData(data, filterType) : data;
        })
        .catch(err => {
          return Promise.reject("Unable to fetch the data from registry" + err);
        });
    }
  });
}

function filterRegisteryData(registryObj, filterType) {
  let filteredData = [];
  if (registryObj && registryObj.length > 0 && filterType) {
    registryObj.forEach(item => {
      if (item.type === filterType) {
        filteredData.push(item);
      }
    });
  }
  return filteredData;
}

function initialiseSDK(orgNamespace, context, sdkConfig) {
  let sdkConfigObj = null;
  try {
    sdkConfigObj = JSON.parse(sdkConfig);
  } catch {
    return Promise.reject("Invalid JSON string for sdkConfig: " + sdkConfig);
  }
  return fetchSDKInstance(orgNamespace, context, sdkConfigObj);
}
function fetchSDKInstance(orgNamespace, context, sdkConfig) {
  if (sdkConfig) {
    try {
      sdkConfig =
        typeof sdkConfig === "object" ? sdkConfig : JSON.parse(sdkConfig);
    } catch {
      return Promise.reject("Invalid JSON string for sdkConfig: " + sdkConfig);
    }
    if (isSDKInstanceAvailable(orgNamespace, sdkConfig.sdkObject)) {
      let sdkInstance = getSDKInstance(orgNamespace, sdkConfig.sdkObject);
      return Promise.resolve(sdkInstance);
    }
    return loadJsFromStaticResource(
      context,
      sdkConfig.staticResourceName,
      sdkConfig.sdkPath
    ).then(() => {
      return getSDKInstance(orgNamespace, sdkConfig.sdkObject);
    });
  }
  return null;
}
function loadSDK(context, sdkConfig) {
  if (sdkConfig) {
    return initialiseSDK(namespace, context, sdkConfig);
  }
  return Promise.reject("Invalid SDK Configuration");
}
function invokeSDKMethod(parsedDs, context) {
  let tempMethodName =
    parsedDs.value.selectedSDKMethod.charAt(0).toUpperCase() +
    parsedDs.value.selectedSDKMethod.slice(1);
  let getInputMethod = "create" + tempMethodName + "Input";
  let input = {};
  try {
    input = JSON.parse(parsedDs.value.body);
  } catch {
    return Promise.reject(
      "Invalid JSON string for datasource: " + parsedDs.value.body
    );
  }
  if (typeof context[getInputMethod] === "function") {
    input = Object.assign(context[getInputMethod](), input);
  }
  return context[parsedDs.value.selectedSDKMethod](input).then(sdkResponse => {
    return sdkResponse;
  });
}

export { loadSDK, invokeSDKMethod, fetchActionRegistryData };
