/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { saveCard } from "c/flexCardUtils";
import { getAllCards } from "./getAllCards";
import { setCardById } from "./getCard";
import { getCardObjectFields } from "./getCardObjectFields";

let errors = [];
let adaptLayoutJsonForSave = json => {
  let cardObjectFields = getCardObjectFields(json);
  return Object.keys(json).reduce(function(outputObject, key) {
    if (
      /(^Id|^Name|^LastModifiedDate|__c)$/.test(key) ||
      key in cardObjectFields ||
      Object.values(cardObjectFields).includes(key)
    ) {
      outputObject[key] = json[key];
    }
    return outputObject;
  }, {});
};

//This is only required while creating new card/ card version /clone
//pass isNew as true for this check
let shouldSave = (item, json) => {
  if (item.isNew) {
    let cardObjectFields = getCardObjectFields(item);
    //parse definition if it comes in as string
    item[cardObjectFields.PropertySetConfig] =
      typeof item[cardObjectFields.PropertySetConfig] === "string"
        ? JSON.parse(item[cardObjectFields.PropertySetConfig])
        : item[cardObjectFields.PropertySetConfig];
    return new Promise(function(resolve, reject) {
      // check card name doesn't exist already
      return getAllCards().then(cards => {
        if (
          cards.find(function(card) {
            return (
              card.Name === item.Name &&
              card[cardObjectFields.AuthorName] ===
                item[cardObjectFields.AuthorName] &&
              card[cardObjectFields.VersionNumber] ===
                item[cardObjectFields.VersionNumber] &&
              card.Id !== item.Id
            );
          })
        ) {
          if (item.originalJson) {
            if (
              item.Name !== item.originalJson.Name &&
              (item[cardObjectFields.AuthorName] !==
                item.originalJson[cardObjectFields.AuthorName] ||
                item[cardObjectFields.VersionNumber] !==
                  item.originalJson[cardObjectFields.VersionNumber])
            ) {
              //make sure the name changed to a used name
              errors.push({
                message: "This name is already in use"
              });
            }
          } else {
            errors.push({
              message: "This name is already in use"
            });
          }
          reject(errors);
        }
        if (!item[cardObjectFields.AuthorName]) {
          errors.push({
            message: "Please provide a Card author"
          });
          reject(errors);
        }
        //check filter field key is not empty
        if (
          item[cardObjectFields.PropertySetConfig] &&
          item[cardObjectFields.PropertySetConfig].filter &&
          item[cardObjectFields.PropertySetConfig].filter.length
        ) {
          item[cardObjectFields.PropertySetConfig].filter.forEach(
            item[cardObjectFields.PropertySetConfig].filter,
            (value, key) => {
              if (key === "" || value === "") {
                errors.push({
                  message: "Please provide a Card filter key and value"
                });
                reject(errors);
              }
            }
          );
        }
        if (
          item[cardObjectFields.PropertySetConfig] &&
          item[cardObjectFields.PropertySetConfig].states &&
          item[cardObjectFields.PropertySetConfig].states.length === 0
        ) {
          errors.push({
            message: "Please provide a Card State"
          });
          reject(errors);
        }
        if (
          item[cardObjectFields.PropertySetConfig] &&
          item[cardObjectFields.PropertySetConfig].states &&
          item[cardObjectFields.PropertySetConfig].states.length > 0
        ) {
          item[cardObjectFields.PropertySetConfig].states.forEach(state => {
            if (
              !(
                state.name ||
                state.templateUrl ||
                (state.lwc && state.lwc.DeveloperName)
              )
            ) {
              errors.push({
                message:
                  "Please provide a Card State name and template/component"
              });
              reject(errors);
            }
          });
        }
        //locked card
        if (item.locked) {
          reject(new Error("locked card"));
        }
        item.originalJson = json;
        item.saving = true;
        item.errors = null;
        resolve(item);
      });
    });
  }
  return new Promise(function(resolve) {
    resolve();
  });
};
let saveLwcCard = card => {
  var jsonToSave = adaptLayoutJsonForSave(card);
  return new Promise(function(resolve, reject) {
    return shouldSave(card, jsonToSave)
      .then(() => {
        delete card.isNew;
        let cardObjectFields = getCardObjectFields(card);
        jsonToSave[cardObjectFields.DataSourceConfig] =
          typeof jsonToSave[cardObjectFields.DataSourceConfig] === "object"
            ? JSON.stringify(jsonToSave[cardObjectFields.DataSourceConfig])
            : jsonToSave[cardObjectFields.DataSourceConfig];
        if (jsonToSave.LastModifiedDate) {
          delete jsonToSave.LastModifiedDate;
        }
        let obj = {
          card: jsonToSave
        };
        setCardById(jsonToSave.Id, jsonToSave);
        return saveCard(obj)
          .then(updatedCard => {
            setCardById(jsonToSave.Id, updatedCard);
            resolve(updatedCard);
          })
          .catch(function(error) {
            reject(error);
          });
      })
      .catch(() => {
        return reject(new Error("Unable to save the card"));
      });
  });
};

export default saveLwcCard;
