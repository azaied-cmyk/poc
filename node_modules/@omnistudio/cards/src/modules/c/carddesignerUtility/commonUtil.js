/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { namespace } from "c/utility";
import { interpolate } from "c/flexCardUtility";
import { get, set, orderBy } from "c/lodash";
import { getCardObjectFields } from "./getCardObjectFields";
import { getCardDataById } from "./getCard";
import saveCard from "./saveCard";

let localSampleDataSourceResponse = {};

function copySelectedToClipboard(comp, compLabel) {
  if (!comp) {
    throw Error(`${compLabel} could not be queried`);
  }
  comp.select();
  comp.setSelectionRange(0, 99999);
  document.execCommand("copy");
}

function removeNamespace(obj) {
  let formattedObj = {};
  // eslint-disable-next-line array-callback-return
  Object.keys(obj).map(key => {
    formattedObj[key.replace(namespace, "")] = obj[key];
  });

  return formattedObj;
}

function removeCustomFieldName(obj) {
  let formattedObj = {};
  // eslint-disable-next-line array-callback-return
  Object.keys(obj).map(key => {
    formattedObj[key.replace("__c", "")] = obj[key];
  });
  return formattedObj;
}

function setLocalSampleDataSourceResponse(recordId, data) {
  localSampleDataSourceResponse[recordId] = data;
}

function getLocalSampleDataSourceResponse(recordId) {
  return localSampleDataSourceResponse[recordId];
}

function getParsedSampleData(res, isLayout, fullArray) {
  let dataObj = {};
  let cardObjectFields = getCardObjectFields(res);
  let def =
    typeof res[cardObjectFields.PropertySetConfig] === "string"
      ? JSON.parse(res[cardObjectFields.PropertySetConfig])
      : res[cardObjectFields.PropertySetConfig];
  if (!isLayout) {
    if (
      res[cardObjectFields.SampleDataSourceResponse] ||
      localSampleDataSourceResponse[res.Id]
    ) {
      let sampleData = res[cardObjectFields.SampleDataSourceResponse]
        ? JSON.parse(res[cardObjectFields.SampleDataSourceResponse])
        : localSampleDataSourceResponse[res.Id]
        ? JSON.parse(localSampleDataSourceResponse[res.Id])
        : "";
      let orderedBy = def?.dataSource?.orderBy;
      if (orderedBy?.name && Array.isArray(sampleData)) {
        let isReverse =
          orderedBy?.isReverse === "true" || orderedBy?.isReverse === true
            ? "desc"
            : "asc";
        sampleData = orderBy(sampleData, orderedBy.name, isReverse);
      }
      dataObj =
        Array.isArray(sampleData) && !fullArray ? sampleData[0] : sampleData;

      if (def?.dataSource?.value?.resultVar) {
        dataObj = get(dataObj, def.dataSource.value.resultVar);
        dataObj = Array.isArray(dataObj) && !fullArray ? dataObj[0] : dataObj;
      }
    }
  } else {
    dataObj = removeCustomFieldName(res);
  }

  return dataObj;
}

function convertNameToValidLWCCase(str) {
  return str
    .replace(/\s(.)/g, function(a) {
      return a.toUpperCase();
    })
    .replace(/\s/g, "")
    .replace(/^(.)/, function(b) {
      return b.toLowerCase();
    })
    .replace(/-(\w)/g, m => m[1].toUpperCase())
    .replace(/__/g, "_");
}

// Method converts LWC name to valid LWC element name which we are adding inside our auto generated html
function convertLWCBundleNameToValidHTMLElementName(str) {
  return str.replace(/([A-Z])/g, "-$1").toLowerCase();
}

function removeKeys(array, keys) {
  return array.map(obj => {
    keys.forEach(key => {
      delete obj[key];
    });
    return obj;
  });
}

function evalMultipleConditionsToString(group) {
  let conditionString = "";
  group.forEach((condition, index) => {
    if (condition.group) {
      if (condition.logicalOperator) {
        conditionString += conditionString
          ? " " + condition.logicalOperator + " ("
          : "";
        conditionString += evalMultipleConditionsToString(condition.group);
        conditionString += ")";
      } else {
        conditionString += evalMultipleConditionsToString(condition.group);
      }
    } else if (condition.field) {
      if (condition.field !== "$scope.data.status") {
        conditionString +=
          index > 0 && conditionString
            ? " " + condition.logicalOperator + " "
            : ""; //add logical operator
        conditionString +=
          condition.field + " " + condition.operator + " " + condition.value;
      }
    }
  });
  return conditionString;
}

function getParsedProperty(property, cardObj, record) {
  let prop = {};
  Object.keys(property).forEach(key => {
    if (
      typeof property[key] === "string" &&
      property[key].indexOf("{") !== -1
    ) {
      if (key === "cardNode" && property.cardNode) {
        let data = get(
          cardObj,
          getCardObjectFields(cardObj).SampleDataSourceResponse ||
            localSampleDataSourceResponse[cardObj.Id]
        );
        let records =
          data && typeof data === "string" ? JSON.parse(data) : data;
        records = records ? records : record ? [record] : records;
        records = Array.isArray(records) ? records : [records];
        let exp = property[key].replace(/[{}]/g, "");
        let parsedData;
        if (records) {
          parsedData = get({ records: records, record: record }, exp);
          parsedData = Array.isArray(parsedData)
            ? parsedData
            : typeof parsedData === "object"
            ? [parsedData]
            : {};
          prop[key] = Array.isArray(parsedData) ? parsedData[0] : parsedData;
        }
      } else if (property[key].replace(/[{}]/g, "") === "records") {
        let data =
          get(cardObj, getCardObjectFields(cardObj).SampleDataSourceResponse) ||
          localSampleDataSourceResponse[cardObj.Id];
        prop[key] = data && typeof data === "string" ? JSON.parse(data) : data;
      } else if (key.indexOf("stateAction") !== -1) {
        let propertyObj = JSON.parse(property[key]);
        prop[key] = interpolate(propertyObj, record);
      } else {
        //check for custom label first
        let labelRegex = /{Label\.(.*?)}/g;
        let val;
        if (labelRegex.test(property[key]) && cardObj) {
          val =
            cardObj.Label &&
            cardObj.Label[property[key].substring(7, property[key].length - 1)];
        } else {
          val = get({ record: record }, property[key].replace(/[{}]/g, ""));
        }
        prop[key] = val ? val : property[key];
      }
    } else {
      prop[key] = property[key];
    }
  });
  return prop;
}

function getContextTestVariables(contextVariables, card) {
  let contextVar = {};
  contextVariables.forEach(contextVariable => {
    set(contextVar, contextVariable.name, contextVariable.val);
  });
  let Session = card.Session ? card.Session : {};
  let cardDef =
    card.Definition || card[getCardObjectFields(card).PropertySetConfig];
  cardDef = typeof cardDef === "string" ? JSON.parse(cardDef) : cardDef;
  if (cardDef && cardDef.sessionVars) {
    cardDef.sessionVars.forEach(field => {
      Session[field.name] = field.val;
    });
  }
  contextVar.Session = Session;
  if (card.selectedCardsLabel) {
    contextVar[card.selectedCardsLabel] = card && card[card.selectedCardsLabel];
  }
  contextVar.Label = card && card.Label;
  return contextVar;
}

function setCardDefAndSave(key, value, recordId) {
  return new Promise(function(resolve, reject) {
    getCardDataById(recordId).then(_data => {
      let card = { ..._data };
      let cardObjectFields = getCardObjectFields(card);
      card[cardObjectFields.PropertySetConfig] =
        typeof card[cardObjectFields.PropertySetConfig] === "string"
          ? JSON.parse(card[cardObjectFields.PropertySetConfig])
          : card[cardObjectFields.PropertySetConfig];
      if (key === "_fieldList") {
        value.forEach(field => {
          if (field.name)
            card[cardObjectFields.PropertySetConfig][field.name] = field.value;
        });
      } else {
        card[cardObjectFields.PropertySetConfig][key] = value;
      }
      card[cardObjectFields.PropertySetConfig] = JSON.stringify(
        card[cardObjectFields.PropertySetConfig]
      );
      if (card[cardObjectFields.StylingConfiguration]) {
        card[cardObjectFields.StylingConfiguration] =
          typeof card[cardObjectFields.StylingConfiguration] === "string"
            ? card[cardObjectFields.StylingConfiguration]
            : JSON.stringify(card[cardObjectFields.StylingConfiguration]);
      }
      saveCard(card)
        .then(updatedCard => {
          resolve(updatedCard);
        })
        .catch(error => {
          reject(error);
        });
    });
  });
}

function getCurrentFormFactor(element, customStyle) {
  if (
    element.styleObject &&
    element.styleObject.size &&
    element.styleObject.size.isResponsive
  ) {
    if (customStyle.indexOf("desktop") !== -1) {
      return "large";
    } else if (customStyle.indexOf("tablet_l") !== -1) {
      return "medium";
    } else if (customStyle.indexOf("tablet_m") !== -1) {
      return "small";
    } else if (customStyle.indexOf("mobile") !== -1) {
      return "default";
    }
    return "large";
  }
  return "default";
}

function getAllFields(records, canContain) {
  canContain = canContain || {};
  records = !Array.isArray(records) ? [records] : records;
  let allKeys = [];
  let redObj = records.reduce(function(result, obj) {
    return Object.assign(result, obj);
  }, {});
  Object.keys(redObj).forEach(key => {
    if (
      redObj[key] === null ||
      typeof redObj[key] !== "object" ||
      canContain.object
    ) {
      allKeys.push(key);
    }
  });
  return allKeys;
}

/**
 * generateUniqueKey
 * @returns Returns the unique string with timestamp and random value
 */
const generateUniqueKey = () => {
  // Timestamp + Math.random to generate unique hash to avoid collisions
  // Math.random should be unique because of its seeding algorithm.
  // Convert it to base 36 (numbers + letters), and grab the first 9 characters after the decimal.
  return `${new Date().getTime()}-${Math.random()
    .toString(36)
    .substr(2, 9)}`;
};

export {
  removeNamespace,
  getParsedSampleData,
  convertNameToValidLWCCase,
  convertLWCBundleNameToValidHTMLElementName,
  removeKeys,
  evalMultipleConditionsToString,
  getParsedProperty,
  getCurrentFormFactor,
  getAllFields,
  setLocalSampleDataSourceResponse,
  getLocalSampleDataSourceResponse,
  setCardDefAndSave,
  copySelectedToClipboard,
  generateUniqueKey
};
