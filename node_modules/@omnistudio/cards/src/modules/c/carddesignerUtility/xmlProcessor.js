/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { cloneDeep } from "c/lodash";
let parser = new DOMParser();

//Convert Xml into JSON
function convertXMLtoJSON(xml) {
  var obj = {};

  if (xml.nodeType === 1) {
    //ELEMENT NODE
    if (xml.attributes.length > 0) {
      obj["@attributes"] = {};
      let xmlAttrs = Array.from(xml.attributes);
      xmlAttrs.forEach((xmlAttr, index) => {
        let attr = xml.attributes.item(index);
        obj["@attributes"][attr.nodeName] = attr.nodeValue;
      });
    }
  } else if (xml.nodeType === 3 && xml.nodeValue && xml.nodeValue.trim()) {
    //TEXT NODE
    obj = xml.nodeValue;
  }

  if (xml.hasChildNodes()) {
    //check textnode count
    let textNodesList = [].slice.call(xml.childNodes).filter(function(node) {
      return node.nodeType === 3;
    });

    if (xml.childNodes.length === textNodesList.length) {
      obj = [].slice.call(xml.childNodes).reduce(function(text, node) {
        return text + node.nodeValue;
      }, "");
    } else {
      let childNodes = Array.from(xml.childNodes);
      childNodes.forEach((cnode, index) => {
        let node = xml.childNodes.item(index);
        let nodeName = node.nodeName;
        if (nodeName === "#text") {
          return;
        }
        if (typeof obj[nodeName] == "undefined") {
          obj[nodeName] = convertXMLtoJSON(node);
        } else {
          if (typeof obj[nodeName].push == "undefined") {
            let val = obj[nodeName];
            obj[nodeName] = [];
            obj[nodeName].push(val);
          }
          obj[nodeName].push(convertXMLtoJSON(node));
        }
      });
    }
  }
  return obj;
}

//Convert json back to XML
function convertJSONtoXML(node, jsonObj) {
  let result = "";
  let isArr = Array.isArray(jsonObj);
  if (jsonObj && typeof jsonObj === "object" && !isArr) {
    let attributes = generateAttributes(jsonObj["@attributes"]);
    delete jsonObj["@attributes"];
    result += `<${node} ${attributes}>`;
    for (const property in jsonObj) {
      if (property !== "#text") {
        result += convertJSONtoXML(property, jsonObj[property]);
      }
    }
    result += `</${node}>`;
  } else if (jsonObj && isArr) {
    jsonObj.forEach(obj => {
      let objType = typeof obj;
      if (objType === "object") {
        result += convertJSONtoXML(node, obj);
      } else if (objType === "string") {
        result += `<${node}>${obj}</${node}>`;
      }
    });
  } else if (typeof jsonObj === "string") {
    result += `<${node}>${jsonObj}</${node}>`;
  }
  return result;
}

function generateAttributes(obj) {
  let attributes = "";
  if (obj) {
    // eslint-disable-next-line guard-for-in
    for (const prop in obj) {
      attributes += ` ${prop}="${obj[prop]}"`;
    }
  }
  return attributes;
}

function processXmlJSON(json) {
  let modifiedConfig = cloneDeep(json.targetConfigs.targetConfig);
  let configs = json.targetConfigs.targetConfig;
  configs.forEach((con, index) => {
    let propertyArr = Array.isArray(con.property)
      ? con.property
      : [con.property];
    modifiedConfig[index].property = propertyArr;
    let splitTarget = con["@attributes"].targets.split(",");

    splitTarget.forEach((t, sindex) => {
      if (sindex === 0) {
        modifiedConfig[index]["@attributes"].targets = t;
      } else {
        let newCon = { ...con };
        newCon["@attributes"].targets = t;
        modifiedConfig.push(newCon);
      }
    });
  });
  return modifiedConfig;
}

function convertMetatoJSON(metadata) {
  let targetConfigsXml = atob(metadata.targetConfigs);
  let xml = parser.parseFromString(
    `<targetConfigs>${targetConfigsXml}</targetConfigs>`,
    "text/xml"
  );
  return processXmlJSON(convertXMLtoJSON(xml));
}

export { convertMetatoJSON, convertJSONtoXML };
