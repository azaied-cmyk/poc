/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
/* eslint-disable lwc/no-inner-html */
import {
  generateRestRequest,
  getLWCBundles,
  getLwcBundleById,
  getVisualforceDomain,
  isRemoteSiteSettingExists
} from "c/flexCardUtils";
import { convertNameToValidLWCCase } from "./commonUtil";
import { generateLWCFiles } from "./componentGenerator";
import { setLwcResourceData, lwcResources } from "./getLwcResource";
import { getCardObjectFields } from "./getCardObjectFields";
import { convertJSONtoXML } from "./xmlProcessor";

import { find, findIndex, cloneDeep } from "c/lodash";

const urlPrefix = "/services/data/v46.0/tooling/",
  sobjectsUrl = urlPrefix + "sobjects/",
  batchUrl = urlPrefix + "composite/batch";

let lwcBundles = [];
let lwcbundlePromise;
const lwcPrefix = "cf";
let isDeploymentInProgress = false;
let parser = new DOMParser();
let serializer = new XMLSerializer();
function getAllLwcBundles(doBypassCache) {
  if (lwcBundles.length <= 0 || doBypassCache) {
    if (!lwcbundlePromise) {
      lwcbundlePromise = getAllBundles("");
    }
    return lwcbundlePromise;
  }
  return new Promise(resolve => {
    resolve(lwcBundles);
  });
}

function getAllBundles(nextRecordsUrl) {
  return new Promise((resolve, reject) => {
    getLWCBundles({ nextRecordsUrl: nextRecordsUrl })
      // eslint-disable-next-line no-confusing-arrow
      // eslint-disable-next-line consistent-return
      .then(res => {
        if (res && res.done) {
          lwcBundles = lwcBundles.concat(res.records);
          resolve(lwcBundles);
        } else {
          lwcBundles = lwcBundles.concat(res.records);
          if (res && res.nextRecordsUrl) {
            resolve(getAllBundles(res.nextRecordsUrl));
          } else {
            resolve(lwcBundles);
          }
        }
      })
      .catch(error => {
        reject(error);
      });
  });
}

function getLwcBundleByName(nameOfLwc) {
  return find(lwcBundles, {
    DeveloperName: nameOfLwc,
    ManageableState: "unmanaged"
  });
}

function addLwcBundle(lwc) {
  lwcBundles.push(lwc);
}

function createLwcBundle(lwcName, metadata) {
  return new Promise((resolve, reject) => {
    //some case when description comes as empty prevents deployment
    if (metadata && metadata.description === "") {
      delete metadata.description;
    }
    submitRequest({
      url: `${sobjectsUrl}LightningComponentBundle`,
      data: {
        FullName: lwcName,
        Metadata: metadata || {}
      }
    })
      .then(result => {
        if (!result.success) {
          reject(
            result.body ? result.body : result.errors && result.errors.join(",")
          );
          return;
        }
        getLwcBundleById({ Id: result.id }).then(res => {
          if (res.done) {
            resolve(res.records[0]);
          }
        });
      })
      .catch(error => {
        if (!Array.isArray(error)) error = [error];
        const errors = new Set(
          // eslint-disable-next-line valid-typeof
          // eslint-disable-next-line no-confusing-arrow
          error.map(e => (typeof e === "string" ? e : e.message || e))
        );
        reject([...errors]);
      });
  });
}

function submitRequest(request) {
  return new Promise((resolve, reject) => {
    let baseUrl =
      window.location.protocol +
      "//" +
      window.location.hostname +
      (window.location.port ? ":" + window.location.port : "");
    let url = `${baseUrl}${request.url}`;

    generateRestRequest({
      endpoint: url,
      type: request.method || "POST",
      body: JSON.stringify(request.data)
    })
      .then(response => {
        let res = JSON.parse(response);
        resolve(res);
      })
      .catch(response => {
        if (response.data) {
          reject(response.data);
        } else if (response.body) {
          reject(response.body);
        } else {
          reject(response);
        }
      });
  });
}
function processPartialBatch(resources) {
  return new Promise((resolve, reject) => {
    const request = {
      batchRequests: resources,
      haltOnError: true
    };
    submitRequest({ url: batchUrl, data: request })
      .then(response => {
        if (response.hasErrors) {
          const errors = response.results
            .filter(
              result => result.statusCode < 200 || result.statusCode > 299
            ) // Only the errors
            .map(result => result.result) // Return the array or results of the result
            .reduce(
              (accumulator, result) =>
                accumulator.concat(result.map(r => r.message)),
              []
            ) // Flatten array of arrays (only the message)
            // eslint-disable-next-line no-shadow
            .reduce((errors, error) => errors.add(error), new Set()); // Convert to a set, so no duplicate errors

          reject([...errors]);
        } else {
          resolve(response);
        }
      })
      .catch(reject);
  });
}

function createLightningResourceRequest(resource, method) {
  var baseUrl =
    resource && resource.metadata
      ? sobjectsUrl + "LightningComponentBundle"
      : sobjectsUrl + "LightningComponentResource";
  const request = {
    url: baseUrl,
    method: method || "POST",
    richInput: null
  };
  switch (method) {
    case "PATCH":
      request.richInput = !resource.metadata
        ? {
            Source: resource.Source
          }
        : {
            Metadata: resource.metadata
          };
      request.url = baseUrl + "/" + resource.Id;
      break;
    case "DELETE":
      request.url = baseUrl + "/" + resource.id;
      break;
    default:
      request.richInput = resource;
      break;
  }
  return request;
}

function updateResources(resources, metaObject) {
  return new Promise((resolve, reject) => {
    const batches = !(
      Object.keys(resources).length === 0 && resources.constructor === Object
    )
      ? resources.map(
          resource =>
            createLightningResourceRequest(
              resource,
              resource.LightningComponentBundleId ? "POST" : "PATCH"
            ) //When we are creating new resource instead of updating we need to pass POST.
        )
      : [createLightningResourceRequest({}, "PATCH", metaObject)];
    const size = 25;
    const chunks = Array.from(Array(Math.ceil(batches.length / size)), (_, i) =>
      batches.slice(i * size, i * size + size)
    );

    // We can process only 25 elements at the time using batch
    return chunks
      .reduce((previousPromise, chunk) => {
        return previousPromise.then(() => processPartialBatch(chunk));
      }, Promise.resolve({ hasErrors: false }))
      .then(resolve)
      .catch(error => {
        if (!Array.isArray(error)) error = [error];
        const errors = new Set(
          // eslint-disable-next-line valid-typeof
          // eslint-disable-next-line no-confusing-arrow
          error.map(e => (typeof e === "string" ? e : e.message || e))
        );
        reject([...errors]);
      });
  });
}

function updateCardResource(cardObj) {
  if (!isDeploymentInProgress) {
    let cardObjectFields = getCardObjectFields(cardObj);
    let isActive = cardObj[cardObjectFields.IsActive];
    let nameOfLwc = isActive
      ? cardObj.Name
      : cardObj.Name +
        "_" +
        (cardObj[cardObjectFields.VersionNumber] || "legacy") +
        "_" +
        cardObj[cardObjectFields.AuthorName];
    nameOfLwc = convertNameToValidLWCCase(lwcPrefix + "-" + nameOfLwc);
    let updatedResources = checkIfChangeInSource(cardObj);
    if (updatedResources.length > 0) {
      isDeploymentInProgress = true;
      return new Promise((resolve, reject) => {
        updateResources(updatedResources, {})
          .then(res => {
            if (!res.hasErrors) {
              //When we create new file for styleDefinition we need to update its Id in local resource
              //it will always be at 0th index as adding its resource request using unshift.
              if (res.results[0].result && !updatedResources[0].Id) {
                updatedResources[0].Id = res.results[0].result.id;
              }
            }
            updateLocalResource(nameOfLwc, updatedResources);
            isDeploymentInProgress = false;
            resolve(true);
            // eslint-disable-next-line no-console
            console.log(res);
          })
          .catch(err => {
            isDeploymentInProgress = false;
            reject(err);
          });
      });
    }
  } else {
    return Promise.reject("Deployment is in progress");
  }
  return new Promise(resolve => {
    resolve(true);
  });
}

function checkIfChangeInSource(cardObj) {
  let cardObjectFields = getCardObjectFields(cardObj);
  let updatedResources = [];
  let isActive = cardObj[cardObjectFields.IsActive];
  let definition = cardObj[cardObjectFields.PropertySetConfig];
  if (definition && typeof definition === "string") {
    definition = JSON.parse(definition);
  }
  let nameOfLwc = isActive
    ? cardObj.Name
    : cardObj.Name +
      "_" +
      cardObj[cardObjectFields.VersionNumber] +
      "_" +
      cardObj[cardObjectFields.AuthorName];
  nameOfLwc = convertNameToValidLWCCase(lwcPrefix + "-" + nameOfLwc);
  let lwcBundleData = find(lwcBundles, {
    DeveloperName: nameOfLwc,
    ManageableState: "unmanaged"
  });
  let files = generateLWCFiles(nameOfLwc, cardObj, "card");
  if (isActive) {
    let xmlPath = `lwc/${nameOfLwc}/${nameOfLwc}.js-meta.xml`;
    let fileExist = find(lwcResources[nameOfLwc], {
      FilePath: xmlPath,
      LightningComponentBundleId: lwcBundleData && lwcBundleData.Id
    });
    let updatedXml = fileExist
      ? checkIfChangeInXml(lwcBundleData, definition)
      : "";
    if (updatedXml && fileExist && updatedXml.trim() !== fileExist.Source) {
      let dummyXml = getDummyXml(lwcBundleData);
      files.unshift({
        name: `${nameOfLwc}.js-meta.xml`,
        source: dummyXml,
        filepath: xmlPath,
        format: "xml"
      });
      files.push({
        name: `${nameOfLwc}.js-meta.xml`,
        source: updatedXml,
        filepath: xmlPath,
        format: "xml"
      });
    }
  }
  files.forEach(file => {
    if (
      file.name.indexOf(".html") !== -1 ||
      file.name.indexOf(".js") !== -1 ||
      file.name.indexOf(".css") !== -1 ||
      file.name.indexOf(".xml") !== -1
    ) {
      let cardExists = find(lwcResources[nameOfLwc], {
        FilePath: file.filepath,
        LightningComponentBundleId: lwcBundleData && lwcBundleData.Id
      });
      if (cardExists && file.source) {
        if (file.source.trim() !== cardExists.Source) {
          updatedResources.push({
            Id: cardExists.Id,
            Source: file.source
          });
        }
      } else if (
        lwcResources[nameOfLwc] &&
        lwcResources[nameOfLwc].length > 0
      ) {
        //This is added to make sure for old cards we include styledefinition.
        //Now checking if local resource is available then only add the missing file otherwise do nothing
        updatedResources.unshift({
          FilePath: file.filepath,
          Format: "js",
          LightningComponentBundleId: lwcBundleData.Id,
          Source: file.source
        });
      }
    }
  });

  return updatedResources;
}

function getDummyXml(lwcBundleData) {
  let lwcComponentName = lwcBundleData.DeveloperName;
  let lwc = find(lwcResources[lwcComponentName], {
    FilePath: `lwc/${lwcComponentName}/${lwcComponentName}.js-meta.xml`,
    LightningComponentBundleId: lwcBundleData && lwcBundleData.Id
  });
  let xmlStr = lwc.Source;
  let xmlDoc = parser.parseFromString(xmlStr, "text/xml");
  let tConfigNode = xmlDoc.getElementsByTagName("targetConfigs");
  let targetNode = xmlDoc.getElementsByTagName("targets");
  if (tConfigNode.length !== 0) {
    tConfigNode[0].parentNode.removeChild(tConfigNode[0]);
  }
  if (targetNode.length !== 0) {
    targetNode[0].parentNode.removeChild(targetNode[0]);
  }
  return serializer.serializeToString(xmlDoc);
}

function checkIfChangeInXml(lwcBundleData, definition) {
  if (lwcBundleData?.DeveloperName && definition.xmlJson) {
    let lwcComponentName = lwcBundleData.DeveloperName;
    let lwc = find(lwcResources[lwcComponentName], {
      FilePath: `lwc/${lwcComponentName}/${lwcComponentName}.js-meta.xml`,
      LightningComponentBundleId: lwcBundleData && lwcBundleData.Id
    });
    let xmlStr = lwc.Source;
    let xmlDoc = parser.parseFromString(xmlStr, "text/xml");

    let tConfigNode = xmlDoc.getElementsByTagName("targetConfigs");
    let targetNode = xmlDoc.getElementsByTagName("targets");
    if (targetNode.length === 0) {
      let newEle = xmlDoc.createElement("targets");
      xmlDoc
        .getElementsByTagName("LightningComponentBundle")[0]
        .appendChild(newEle);
    }
    if (tConfigNode.length === 0) {
      let newEle = xmlDoc.createElement("targetConfigs");
      xmlDoc
        .getElementsByTagName("LightningComponentBundle")[0]
        .appendChild(newEle);
    }

    // eslint-disable-next-line @lwc/lwc/no-inner-html
    let targetConfigs = xmlDoc.getElementsByTagName("targetConfigs")[0]
      .innerHTML;
    let generatedConfig = convertJSONtoXML("targetConfig", definition.xmlJson);
    if (targetConfigs !== generatedConfig) {
      if (definition?.xmlObject?.targets?.target) {
        let generatedtargets = convertJSONtoXML(
          "target",
          definition.xmlObject.targets.target
        );
        // eslint-disable-next-line @lwc/lwc/no-inner-html
        xmlDoc.getElementsByTagName("targets")[0].innerHTML = generatedtargets;
      }
      // eslint-disable-next-line @lwc/lwc/no-inner-html
      xmlDoc.getElementsByTagName(
        "targetConfigs"
      )[0].innerHTML = generatedConfig;
      return serializer.serializeToString(xmlDoc);
    }
    return "";
  }
  return "";
}

function updateLocalResource(nameOfLwc, updatedResources) {
  let resourceExists = cloneDeep(lwcResources[nameOfLwc]);
  if (resourceExists) {
    updatedResources.forEach(resource => {
      let index = findIndex(resourceExists, {
        Id: resource.Id
      });
      if (index !== -1) {
        resourceExists[index].Source = resource.Source;
      } else {
        //When we add a new file while updating LWC (for now styleDefinition)
        resourceExists.push({
          FilePath: resource.FilePath,
          Id: resource.Id,
          LightningComponentBundleId: resource.LightningComponentBundleId,
          Source: resource.Source
        });
      }
    });
    setLwcResourceData(nameOfLwc, resourceExists);
  }
}

let getVfDomain = () => {
  let cachedVfBaseUrl = sessionStorage.getItem("visualforceDomain");
  if (!cachedVfBaseUrl) {
    getVisualforceDomain().then(vfBaseUrl => {
      sessionStorage.setItem("visualforceDomain", vfBaseUrl);
    });
  }
};

function isRemoteSiteSetting() {
  return new Promise((resolve, reject) => {
    getVfDomain();
    let lightningBaseUrl =
      window.location.protocol +
      "//" +
      window.location.hostname +
      (window.location.port ? ":" + window.location.port : "");
    sessionStorage.setItem("lightningBaseUrl", lightningBaseUrl);
    let request1 = isRemoteSiteSettingExists({
      type: "lightning",
      baseUrl: lightningBaseUrl
    });
    let request2 = isRemoteSiteSettingExists({
      type: "visualforce",
      baseUrl: lightningBaseUrl
    });
    Promise.all([request1, request2])
      .then(results => {
        let RemoteSiteSettingAlreadyExists = true;
        results.forEach(data => {
          let result = data ? JSON.parse(data) : {};
          if (!result.records || !result.records.length) {
            RemoteSiteSettingAlreadyExists = false;
            reject(false);
          }
        });
        if (RemoteSiteSettingAlreadyExists) {
          resolve(true);
        }
      })
      .catch(error => {
        reject(false);
        let errMsg =
          error && error.body
            ? error.body.message
              ? error.body.message
              : JSON.stringify(error.body)
            : "";
        console.error("Remote Site Setting Error: " + errMsg);
      });
  });
}

function addRemoteSiteSetting() {
  let fullName = "EnableFlexCards" + Date.now();
  let baseUrl =
    window.location.protocol +
    "//" +
    window.location.hostname +
    (window.location.port ? ":" + window.location.port : "");
  return new Promise((resolve, reject) => {
    submitRequest({
      url: `${sobjectsUrl}RemoteProxy`,
      data: {
        FullName: fullName,
        Metadata: {
          isActive: true,
          url: baseUrl
        }
      }
    })
      .then(result => {
        if (!result.success) {
          reject(result.errors);
          return;
        }
        resolve(result.id);
      })
      .catch(error => {
        reject([...new Set(error.map(e => e))]);
      });
  });
}

export {
  createLwcBundle,
  getAllLwcBundles,
  addLwcBundle,
  updateResources,
  updateCardResource,
  checkIfChangeInSource,
  updateLocalResource,
  isRemoteSiteSetting,
  addRemoteSiteSetting,
  getLwcBundleByName
};
