/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import {
  getAllFlexCardDefinitions,
  getAllCardsByRecordTypeMethod,
  getAllCardsDetailsByRecordTypeMethod
} from "c/flexCardUtils";
import { getCardObjectFields } from "./getCardObjectFields";

let childToParentCardMap = {};
let parentCardList = [];
let allCardsByRecordType;
/**
 * Get all available Cards
 * @param Object VlocityCard
 */
export function getAllCards() {
  return getAllFlexCardDefinitions().then(cards => {
    const transformedElements = [];
    cards.forEach(elementPreConvert => {
      let element = Object.assign({}, elementPreConvert);
      transformedElements.push(element);
    });
    return Object.assign([], transformedElements);
  });
}

let fetchParentCard = name => {
  if (childToParentCardMap[name] && childToParentCardMap[name].length) {
    childToParentCardMap[name].forEach(cardName => {
      if (parentCardList.indexOf(cardName) === -1) {
        parentCardList.push(cardName);
      }
      fetchParentCard(cardName);
    });
  }
};

export function getAllParentCards(cardName) {
  if (!parentCardList.length) {
    fetchParentCard(cardName);
  }
  return parentCardList;
}

export function getAllCardsByRecordType(recordType) {
  return getAllCardsByRecordTypeMethod({ recordType: recordType }).then(
    cards => {
      const transformedElements = [];
      cards.forEach(elementPreConvert => {
        let element = Object.assign({}, elementPreConvert);
        transformedElements.push(element);
      });
      return Object.assign([], transformedElements);
    }
  );
}
export function getAllChildCards() {
  if (allCardsByRecordType) {
    return allCardsByRecordType;
  }
  allCardsByRecordType = getAllCardsByRecordType("Flex").then(cards => {
    let childCards = [];
    if (cards && cards.length > 0) {
      cards.forEach(card => {
        let cardObjectFields = getCardObjectFields(card);
        if (
          card[cardObjectFields.IsChildCard] ||
          (card[cardObjectFields.Type] &&
            card[cardObjectFields.Type].toLowerCase() === "child")
        ) {
          if (card[cardObjectFields.PropertySetConfig]) {
            let cardDef = card[cardObjectFields.PropertySetConfig];
            cardDef =
              cardDef && typeof cardDef === "string" ? JSON.parse(cardDef) : {};
            if (cardDef.states) {
              cardDef.states.forEach(state => {
                if (state.childCards && state.childCards.length) {
                  state.childCards.forEach(childCard => {
                    if (!childToParentCardMap[childCard]) {
                      childToParentCardMap[childCard] = [];
                    }
                    childToParentCardMap[childCard].push(card.Name);
                  });
                }
              });
            }
          }
          if (card[cardObjectFields.IsActive]) {
            let obj = card;
            obj.property = {};
            childCards.push(obj);
          }
        }
      });
    }
    return childCards;
  });
  return allCardsByRecordType;
}
export function getAllCardsDetailsByRecordType(recordType, scope, filters) {
  return getAllCardsDetailsByRecordTypeMethod({
    recordType: recordType,
    scope: scope,
    filters: filters
  }).then(cards => {
    const transformedElements = [];
    cards.forEach(elementPreConvert => {
      let element = Object.assign({}, elementPreConvert);
      transformedElements.push(element);
    });
    return Object.assign([], transformedElements);
  });
}
