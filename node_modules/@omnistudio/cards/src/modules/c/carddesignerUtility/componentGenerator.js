/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { convertNameToValidLWCCase } from "./commonUtil";
import {
  namespace,
  isInsidePckgPromise,
  lwcPropertyNameConversion
} from "c/utility";
import { cloneDeep, find, filter, omit } from "c/lodash";
import {
  requiredPermissionsError,
  firstOmniPkgNamespacePrefix
} from "c/flexCardUtils";
import { getAllChildCards } from "./getAllCards";
import { getAllLwcBundles } from "./deployment";
import { getCardObjectFields } from "./getCardObjectFields";

let nsPrefix = "c";
let lwcPrefix = "cf";
const exposedAPIPrefix = "cf";
let isInsidePackge = false;
let renderedElementCount = "";
let styleDefinition = {};
const defaultXmlConfig = {
  targetConfigs: `<targetConfig targets="lightning__AppPage">
                      <property name="debug" type="Boolean"/>
                      <property name="recordId" type="String"/>
                  </targetConfig>
                  <targetConfig targets="lightning__RecordPage">
                      <property name="debug" type="Boolean"/>
                  </targetConfig>`,
  targets: [
    "lightning__RecordPage",
    "lightning__AppPage",
    "lightning__HomePage"
  ],
  api: 51
};

const pubsubEventVarPrefx = "pubsubEvent";
const customEventVarPrefx = "customEvent";

let isRepeatable = true;
let isStateActiveHtml = true;
isInsidePckgPromise().then(res => {
  if (res) {
    isInsidePackge = true;
    firstOmniPkgNamespacePrefix().then(firstPckgNS => {
      let orgNamespaceToUse = firstPckgNS || namespace;
      nsPrefix = orgNamespaceToUse ? orgNamespaceToUse.replace("__", "") : "c";
    });
  }
});
let actionElementsSlotObject = {};
let childCards = [];
getAllChildCards().then(cards => {
  childCards = cards;
});

let allLwcBundles = [];
getAllLwcBundles().then(res => {
  allLwcBundles = res;
});

//HTML
function generateStateHtml(cardDef, index, theme, isactive, item) {
  let omniSupport = cardDef && cardDef.osSupport;
  let state = cardDef.states[index];
  isRepeatable =
    cardDef.isRepeatable || typeof cardDef.isRepeatable === "undefined";
  isStateActiveHtml = isactive;
  let stateObj = isRepeatable ? "record={record}" : "";
  if (state) {
    let elements = state.components && state.components["layer-0"].children;
    if (elements) {
      let stateTrackingHtml = ` tracking-obj={_childCardTrackingObj} `;
      renderedElementCount = "";
      return `<${nsPrefix}-flex-card-state ${
        isactive && isRepeatable
          ? "if:true={record}  key={record._flex.uniqueKey} data-recordid={record.Id}"
          : ""
      } ${stateObj} data-statue="${isactive}"  data-index="${index}" data-rindex={rindex} class="cf-vlocity-state-${index} cf-vlocity-state ${getElementStyle(
        //Hardcoding styles for state as they dont support runtime styling
        state,
        "sizeClass"
      )}" ${stateTrackingHtml}>
      <div if:true={cardLoaded} class="${theme}-grid ${theme}-wrap ${getElementStyle(
        //Hardcoding styles for state as they dont support runtime styling
        state,
        "class"
      )}" style="${getElementStyle(state, "style")}">
          ${elements
            .map((element, elementIndex) => {
              renderedElementCount = "state" + index + "element" + elementIndex;
              if (element.element === "customLwc") {
                let ele = cloneDeep(element);
                ele.element =
                  ele.property && ele.property.customlwcname
                    ? ele.property.customlwcname
                    : ele.element;
                if (ele.property && ele.property.customlwcname)
                  delete ele.property.customlwcname;
                return generateElementDiv(
                  ele,
                  theme,
                  "customLwc",
                  omniSupport,
                  item
                );
              }
              //232 base radio input elements support
              if (
                element.element === "baseInputElement" &&
                (element.name === "RadioGroup" ||
                  element.name === "Radio Image Group" ||
                  element.name === "Radio Color Pick Group")
              ) {
                element.element = "flexRadioInput";
              }
              return generateElementDiv(element, theme, "", omniSupport, item);
            })
            .join("")}
        </div>
      </${nsPrefix}-flex-card-state>`;
    }
  }
  return "";
}

function generateBlockDiv(element, theme, omniSupport, item) {
  let renderedElementBlockCount = renderedElementCount;
  return `<div class="${theme}-grid ${theme}-wrap">
          ${element.children
            .map((child, blockElementIndex) => {
              renderedElementCount =
                renderedElementBlockCount + "block_element" + blockElementIndex;
              if (child.element === "customLwc") {
                let ele = cloneDeep(child);
                ele.element =
                  ele.property && ele.property.customlwcname
                    ? ele.property.customlwcname
                    : ele.element;
                if (ele.property && ele.property.customlwcname)
                  delete ele.property.customlwcname;
                return generateElementDiv(
                  ele,
                  theme,
                  "customLwc",
                  omniSupport,
                  item
                );
              }
              return generateElementDiv(child, theme, "", omniSupport, item);
            })
            .join("")}
        </div>`;
}

function getElementStyle(element, type, index) {
  if (
    element.styleObjects &&
    element.styleObjects.length > 0 &&
    typeof index !== "undefined"
  ) {
    return (
      element.styleObjects[index] &&
      (element.styleObjects[index].styleObject[type] || "")
    );
  }
  if (element.styleObject && element.styleObject[type]) {
    return element.styleObject[type];
  }
  return "";
}

function getConditionalElementClass(element) {
  if (element.property["data-conditions"]) {
    return "condition-element";
  }
  return "";
}

function isFlexAction(ele) {
  return ele.element === "action";
}

function isFlexMenuItem(ele) {
  let isMenuItem = ele?.property?.stateAction?.isMenuItem;
  return isMenuItem === "true" || isMenuItem === true;
}

function getActionType(ele) {
  let type =
    (isFlexAction(ele) || isFlexMenuItem(ele)) && ele.property.stateAction
      ? ele.property.stateAction.type
      : "";
  return type;
}

function actionWithEvents(ele) {
  let type = getActionType(ele);
  return (
    type === "cardAction" ||
    type === "updateOmniScript" ||
    type === "DataAction"
  );
}

function attachEventOnTemplate(ele) {
  let type = getActionType(ele);
  let eventStr = "";
  switch (type) {
    case "cardAction":
      eventStr =
        " onselectcards={updateSelectedCards} onsetvalue={updateAction} ";
      break;
    case "updateOmniScript":
      eventStr = " onupdateos={updateOmniscript} ";
      break;
    case "DataAction":
      eventStr = " onfireactionevent={actionEvtHandler} ";
      break;
  }
  return eventStr;
}

function generateElementDiv(element, theme, type, omniSupport, item) {
  let ele = cloneDeep(element);
  let elementName = lwcPropertyNameConversion(`${nsPrefix}-${ele.element}`);
  if (ele.element === "childCardPreview") {
    let childDevName = getDevNamefromCardname(ele.property.cardName);
    // if isRecursive and if card is Active then use active card name
    let cardObjectFields = getCardObjectFields(item);
    let isActive = item[cardObjectFields.IsActive];
    if (ele.property && ele.property.isRecursive && isActive) {
      childDevName = getDevNamefromCardname(item.Name);
    }
    let selectedCustomLwcList = filter(allLwcBundles, {
      DeveloperName: childDevName
    });
    let selectedCustomLwc;

    //check if only one state childcard exist and use that in case of multiple lwc use the unmanged one
    if (selectedCustomLwcList && selectedCustomLwcList.length === 1) {
      selectedCustomLwc = selectedCustomLwcList[0];
    } else {
      selectedCustomLwc = find(selectedCustomLwcList, {
        ManageableState: "unmanaged"
      });
    }

    let cNamespace =
      (isInsidePackge &&
        selectedCustomLwc &&
        selectedCustomLwc.ManageableState !== "unmanaged" &&
        selectedCustomLwc.NamespacePrefix) ||
      "c";
    elementName = lwcPropertyNameConversion(`${cNamespace}-${childDevName}`);
    if (ele.property && ele.property.cardName) {
      ele.property.recordId = "{recordId}";
      ele.property.objectApiName = "{objectApiName}";
      ele.property.parentRecord = "{record}";
      ele.property.parentMergefields = "{card}";
      ele.property.records = "{_records}";
      delete ele.property.selectedState;
    }
  } else if (type === "customLwc") {
    let selectedCustomLwc = find(allLwcBundles, { DeveloperName: ele.element });
    let cNamespace =
      (isInsidePackge &&
        selectedCustomLwc &&
        selectedCustomLwc.ManageableState !== "unmanaged" &&
        selectedCustomLwc.NamespacePrefix) ||
      "c";
    elementName = lwcPropertyNameConversion(`${cNamespace}-${ele.element}`);
  }
  let isFlyoutAction = false;
  if (isFlexAction(ele)) {
    let stateAction = ele.property.stateAction;
    isFlyoutAction =
      stateAction &&
      stateAction.parent !== "menu" &&
      stateAction.type === "Flyout";
  }
  let template;
  let trackingHtml = ` tracking-obj={_childCardTrackingObj} `;
  if (isFlyoutAction) {
    updateStyleDefinitionJSON(renderedElementCount, ele);
    template = `<div data-style-id="${renderedElementCount}" class="${
      ele.class
    } ${getElementStyle(ele, "class", 0)} ${getElementStyle(
      ele,
      "sizeClass",
      0
    )} ${getConditionalElementClass(
      ele
    )}" data-rindex={rindex} style="${getElementStyle(
      element,
      "style",
      0
    )}" ${generateEachPropertyForElement(ele, "data-conditions")}>
    <${elementName} data-style-id="${renderedElementCount}_child" ${
      ele.element === "action"
        ? trackingHtml
        : " onupdateos={updateOmniscript} onselectcards={updateSelectedCards} onsetvalue={updateAction} onfireactionevent={actionEvtHandler} "
    } ${generateElementProperty(
      ele
    )} theme="${theme}" ${preloadingConditionalElement(
      ele,
      renderedElementCount
    )}>${generateFlyoutActionElement(ele)}</${elementName}>
    </div>`;
  } else if (ele.element === "flexMenu") {
    updateStyleDefinitionJSON(renderedElementCount, ele);
    let menuItemsArray = ele.property.menuItems;
    delete ele.property.menuItems;
    template = `<div data-style-id="${renderedElementCount}" class="${
      ele.class
    } ${getElementStyle(ele, "class", 0)} ${getElementStyle(
      ele,
      "sizeClass",
      0
    )} ${getConditionalElementClass(
      ele
    )}" data-rindex={rindex} style="${getElementStyle(
      element,
      "style",
      0
    )}" ${generateEachPropertyForElement(ele, "data-conditions")}>
    <${elementName} data-style-id="${renderedElementCount}_child" 
    onupdateos={updateOmniscript} onselectcards={updateSelectedCards} onsetvalue={updateAction} ${generateElementProperty(
      ele
    )}
    theme="${theme}" ${preloadingConditionalElement(
      ele,
      renderedElementCount
    )}> 
     ${generateFlexMenuItems(menuItemsArray, theme, renderedElementCount)}
    </${elementName}>
    </div>`;
  } else if (ele.element === "block") {
    let actionEnabledHtml = "";
    if (ele.property && ele.property.action) {
      actionEnabledHtml = getActionEnabledProperties(ele, theme);
    }
    updateStyleDefinitionJSON(
      renderedElementCount,
      ele,
      `${actionEnabledHtml ? " slds-text-link_reset " : ""}`
    );
    template = `<div data-style-id="${renderedElementCount}" class="${
      ele.class
    } ${actionEnabledHtml ? " slds-text-link_reset " : ""} ${getElementStyle(
      ele,
      "class",
      0
    )} ${getElementStyle(ele, "sizeClass", 0)} ${getConditionalElementClass(
      ele
    )}" data-rindex={rindex} style="${getElementStyle(
      element,
      "style",
      0
    )}" ${generateEachPropertyForElement(ele, "data-conditions")}>
    <${elementName} data-style-id="${renderedElementCount}_child" ${generateElementProperty(
      ele
    )} theme="${theme}" ${preloadingConditionalElement(
      ele,
      renderedElementCount
    )} ${actionEnabledHtml}>${generateBlockDiv(
      ele,
      theme,
      omniSupport,
      item
    )}</${elementName}>
    </div>`;
  } else if (type === "customLwc") {
    let customLwcElementName = lwcPropertyNameConversion(
      `${nsPrefix}-customLwcWrapper`
    );
    let customLwcProperties = cloneDeep(ele.property);
    let apiVars = ["{record}", "{records}", "{recordId}", "{objectApiName}"];
    let keys = Object.keys(ele.property);
    keys.forEach(key => {
      let value = ele.property[key];
      if (
        typeof value === "string" &&
        apiVars.indexOf(value) === -1 &&
        value.indexOf("{") !== -1
      ) {
        delete ele.property[key];
      } else {
        delete customLwcProperties[key];
      }
    });
    let propertyValue = customLwcProperties
      ? `'\\${JSON.stringify(customLwcProperties)}'`
      : "";
    updateStyleDefinitionJSON(renderedElementCount, ele);
    template = `<div data-style-id="${renderedElementCount}" class="${
      ele.class
    } ${getElementStyle(ele, "class", 0)} ${getElementStyle(
      ele,
      "sizeClass",
      0
    )}" data-rindex={rindex} style="${getElementStyle(
      element,
      "style",
      0
    )}" ${generateEachPropertyForElement(ele, "data-conditions")}>
    <${customLwcElementName} class="${getConditionalElementClass(
      ele
    )}" element-name="${elementName}" property=${propertyValue} data-rindex={rindex} records={records} record={record} record-id={recordId} card={card} ${preloadingConditionalElement(
      ele,
      renderedElementCount
    )}><${elementName}  ${generateElementProperty(
      ele
    )}></${elementName}></${customLwcElementName}>
    </div>`;
  } else {
    updateStyleDefinitionJSON(renderedElementCount, ele);
    template = `<div data-style-id="${renderedElementCount}" class="${
      ele.class
    } ${getElementStyle(ele, "class", 0)} ${getElementStyle(
      ele,
      "sizeClass",
      0
    )} ${getConditionalElementClass(
      ele
    )}" data-rindex={rindex} style="${getElementStyle(
      ele,
      "style",
      0
    )}" ${generateEachPropertyForElement(ele, "data-conditions")}>`;
    if (actionWithEvents(ele)) {
      let eventStr = attachEventOnTemplate(ele);
      template += `<${elementName} data-style-id="${renderedElementCount}_child" ${trackingHtml} ${generateElementProperty(
        ele
      )} theme="${theme}" ${preloadingConditionalElement(
        ele,
        renderedElementCount
      )} ${eventStr}></${elementName}>
      </div>`;
    } else if (ele.element === "childCardPreview") {
      let osAttributes =
        omniSupport && isStateActiveHtml
          ? getOmniAttributes(ele.property.cardName)
          : "";
      if (ele.property.cardName) {
        delete ele.property.cardName;
      }
      template += `<${elementName} data-style-id="${renderedElementCount}_child" ${trackingHtml} is-inside-parent={insideParent} parent-uniquekey={uniqueKey} ${generateElementProperty(
        ele
      )} theme="${theme}" ${osAttributes} ${preloadingConditionalElement(
        ele,
        renderedElementCount
      )} onupdateparent={updateParentData}></${elementName}>
    </div>`;
    } else {
      let actionEnabledHtml = "";
      if (ele.property && ele.property.action) {
        actionEnabledHtml = getActionEnabledProperties(ele, theme);
      }

      if (isFlexAction(ele)) {
        template += `<${elementName} data-style-id="${renderedElementCount}_child" ${trackingHtml} ${generateElementProperty(
          ele
        )} theme="${theme}" ${actionEnabledHtml} ${preloadingConditionalElement(
          ele,
          renderedElementCount
        )}></${elementName}>
      </div>`;
      } else if (
        ele.element === "flexToggle" &&
        typeof ele.property.updateDS !== "undefined"
      ) {
        let updateDS = ele.property.updateDS;
        let key =
          ele.property.type === "checkbox" || ele.property.type === "button"
            ? "value"
            : "checked";
        let fieldName = ele.property[key].match(/\{([a-zA-Z.0-9_]*)\}/g)
          ? ele.property[key].substring(1).replace(/[{}]/g, "")
          : "";
        delete ele.property.updateDS;
        template += `<${elementName} data-style-id="${renderedElementCount}_child" ${generateElementProperty(
          ele
        )} theme="${theme}" ${
          updateDS && fieldName
            ? (!actionEnabledHtml
                ? "onchange={setValueOnToggle} "
                : "data-onchange='setValue' ") +
              "data-fieldname='" +
              fieldName +
              "'"
            : ""
        } ${actionEnabledHtml} ${preloadingConditionalElement(
          ele,
          renderedElementCount
        )}></${elementName}>
      </div>`;
      } else {
        template += `<${elementName} data-style-id="${renderedElementCount}_child" ${
          ele.element === "flexImg" && !ele.property.card ? "card={card}" : ""
        } ${generateElementProperty(
          ele
        )} theme="${theme}" ${actionEnabledHtml} ${preloadingConditionalElement(
          ele,
          renderedElementCount
        )}></${elementName}>
      </div>`;
      }
    }
  }
  return template;
}

function generateFlexMenuItems(menuItemsArray, theme, renderedElementCount) {
  let menuItems = ``;
  let actionData = {};
  let menuItemData = {};
  actionData.element = "action";
  let isFlyoutAction;
  menuItemsArray.forEach((menuItem, index) => {
    let renderedElementCountMenuItem = `${renderedElementCount}_menuitem_${index}`;
    actionData.property = menuItem.actionData;
    actionData.property.stateAction.isMenuItem = true;
    menuItemData.iconPosition = menuItem.iconPosition;
    isFlyoutAction = menuItem.actionData.stateAction.type === "Flyout";
    actionData.property["data-conditions"] =
      actionData.property?.stateAction?.actionConditions;
    updateStyleDefinitionJSON(renderedElementCountMenuItem, actionData);
    let eventStr = actionWithEvents(actionData)
      ? attachEventOnTemplate(actionData)
      : "";
    menuItems += `<${nsPrefix}-flex-menu-item 
    name="${menuItem.name}"
    theme="${theme}"
    data-style-id="${renderedElementCountMenuItem}"
    ${generateEachPropertyForElement(actionData, "data-conditions")}
    class="${getConditionalElementClass(actionData)}"
    >
    <${nsPrefix}-action ${generateElementProperty(
      actionData
    )} theme="${theme}" extra-class="${theme}-dropdown__item" 
      action-wrapperclass="${
        menuItem.status ? theme + "-has-" + menuItem.status : ""
      }"
      action-labelclass="${theme}-truncate menu-item-label"
      menu-item-data="${encodeURIComponent(JSON.stringify(menuItemData))}"
      icon-size="x-small"
      icon-extraclass="${theme +
        "-icon-text-default " +
        theme +
        (menuItem.iconPosition &&
        menuItem.iconPosition.toLowerCase() === "right"
          ? "-m-left_small " + theme + "-shrink-none"
          : "-m-right_x-small")}"
      ${eventStr}>
     ${generateFlyoutMenuItem(isFlyoutAction, actionData)}</${nsPrefix}-action>
    </${nsPrefix}-flex-menu-item>`;
  });
  return menuItems;
}

function generateFlyoutMenuItem(isFlyoutAction, element) {
  if (isFlyoutAction) {
    return generateFlyoutActionElement(element);
  }
  return "";
}

function getOmniAttributes(cardName) {
  if (childCards && childCards.length > 0) {
    let selectedCard = find(childCards, { Name: cardName });
    let cardObjectFields = getCardObjectFields(selectedCard);
    let osSupport = false;
    if (selectedCard && selectedCard[cardObjectFields.PropertySetConfig]) {
      let cardDef =
        typeof selectedCard[cardObjectFields.PropertySetConfig] === "string"
          ? JSON.parse(selectedCard[cardObjectFields.PropertySetConfig])
          : {};
      osSupport = cardDef.osSupport;
    }
    return osSupport
      ? ` omni-json-def={omniJsonDef} omni-script-header-def={omniScriptHeaderDef} omni-custom-state={omniCustomState} omni-json-data={omniJsonData} ${
          isRepeatable ? "omni-support-key={record._flex.uniqueKey}" : ""
        } `
      : "";
  }
  return "";
}

function getActionEnabledProperties(ele, theme) {
  if (ele.property) {
    ele.property.extraclass = `${
      ele.property.extraclass ? ele.property.extraclass : ""
    } ${theme}-text-link_reset`;
  }
  actionElementsSlotObject[
    "index" + Object.keys(actionElementsSlotObject).length
  ] = generateFlyoutForTriggerActionElement(
    ele.property.action.actionData,
    "index" + Object.keys(actionElementsSlotObject).length
  );
  return `${
    ele.property.action.eventType ? ele.property.action.eventType : "onclick"
  }={executeAction} data-action-index="index${Object.keys(
    actionElementsSlotObject
  ).length - 1}"`;
}

/*
This method adds if:true to parent div of the element only if we uncheck preload component in designer
If we say Preload is true then we dont have to add this in HTML
*/
function preloadingConditionalElement(element, identifier) {
  if (
    isRepeatable &&
    isStateActiveHtml &&
    element &&
    element.property &&
    element.property.hasOwnProperty("data-preloadConditionalElement") &&
    !element.property["data-preloadConditionalElement"]
  ) {
    return `if:true={record._flex.${identifier}_child}`;
  }
  return ``;
}

function generateElementProperty(element) {
  let cmp = `${sortParameterBasedOnDependency(
    Object.keys(element.property).map(key => {
      return generateEachPropertyForElement(element, key);
    }),
    element.element || element.flyoutType
  ).join("")}`;
  return cmp;
}

function generateEachPropertyForElement(element, key) {
  let propertyText = "";
  if (element.property.hasOwnProperty(key)) {
    let value = element.property[key];
    let val = `"${value}"`;
    let hasDQuote = /".*?"/g;
    let hasHtmlTag = /<\/?[a-z][\s\S]*>/g;
    if (
      typeof value === "string" &&
      value.charAt(0) === "{" &&
      value.charAt(value.length - 1) === "}"
    ) {
      val = value;
    }

    if (typeof value === "object" || Array.isArray(value)) {
      //replace single quote with html single quote character reference
      let propertyValue = JSON.stringify(value).replace(/'/g, "&#39;");
      val = `'\\${propertyValue}'`;
    } else if (hasDQuote.test(value) || hasHtmlTag.test(value)) {
      val = `'${value}'`;
    }

    //special case as outputField label interpolates itself
    if (
      element.element === "outputField" &&
      (key === "label" ||
        key === "placeholder" ||
        key === "fieldName" ||
        key === "fieldLevelHelp") &&
      typeof value === "string" &&
      value.indexOf("{") !== -1
    ) {
      val = `"\\${value}"`;
    }

    if (
      element.element === "block" &&
      key === "label" &&
      typeof value === "string" &&
      value.indexOf("{") !== -1 &&
      value.indexOf("\\") === -1
    ) {
      val = `"\\${value}"`;
    }

    if (
      (element.element === "childCardPreview" ||
        element.flyoutType === "childCard") &&
      key === "cardNode" &&
      typeof value === "string" &&
      value.indexOf("{") !== -1
    ) {
      val = `"\\${value}"`;
    } else if (
      (element.element === "childCardPreview" ||
        element.flyoutType === "childCard") &&
      key === "cardNode" &&
      value &&
      typeof value === "string" &&
      value.indexOf("{") === -1
    ) {
      key = "parentData";
      val = "{_dataNode}";
    }
    // For FlexChart escape mergefield for title
    if (
      element.element === "flexChart" &&
      key === "title" &&
      value.startsWith("{") &&
      value.indexOf("{") !== -1 &&
      value.indexOf("\\") === -1
    ) {
      val = `"\\${value}"`;
    }
    let isBoolean =
      value === "true" ||
      value === true ||
      value === "false" ||
      value === false;
    if (
      isBoolean &&
      (key === "disabled" || key === "required" || key === "checked")
    ) {
      propertyText = value === "true" || value === true ? ` ${key} ` : "";
    } else {
      propertyText = ` ${lwcPropertyNameConversion(key)}=${val} `;
    }
  }
  return propertyText;
}

function sortParameterBasedOnDependency(parametersArray, type) {
  parametersArray.sort(param => {
    if (
      param.indexOf("={record}") !== -1 ||
      param.indexOf("={card}") !== -1 ||
      param.indexOf("={recordId}") !== -1 ||
      param.indexOf("={_records}") !== -1
    ) {
      return -1;
    }
    return 1;
  });
  if (type === "childCardPreview" || type === "childCard") {
    for (let i = 0; i < parametersArray.length; ++i) {
      if (
        parametersArray[i].indexOf("card-node=") !== -1 ||
        parametersArray[i].indexOf("parent-data=") !== -1
      ) {
        parametersArray.unshift(parametersArray.splice(i, 1)[0]);
        break;
      }
    }
    const indexOfRecords = parametersArray.indexOf(" records={_records} ");
    const indexOfParentRecord = parametersArray.indexOf(
      " parent-record={record} "
    );
    if (indexOfRecords < indexOfParentRecord) {
      let parentRecord = parametersArray.splice(indexOfParentRecord, 1)[0];
      parametersArray.splice(indexOfRecords, 0, parentRecord);
    }
  }
  return parametersArray;
}

function generateFlyoutForTriggerActionElement(action, index) {
  let stateAction = action.stateAction;
  let customLwcElementName = lwcPropertyNameConversion(
    `${nsPrefix}-customLwcWrapper`
  );
  if (stateAction.flyoutType) {
    let selectedCustomLwc =
      stateAction.flyoutType === "customLwc"
        ? find(allLwcBundles, { DeveloperName: stateAction.flyoutLwc })
        : {};
    let defaultNs =
      (isInsidePackge &&
        selectedCustomLwc &&
        selectedCustomLwc.ManageableState !== "unmanaged" &&
        selectedCustomLwc.NamespacePrefix) ||
      "c"; //generate OS and Childcard will have namespace as c
    return `<div slot="flyout" if:true={action.${index}}>${createFlyoutTemplate(
      "",
      stateAction,
      customLwcElementName,
      defaultNs,
      `{action.${index}}`
    )}</div>`;
  }
  return "";
}

function generateFlyoutActionElement(element) {
  let action = isFlexAction(element) ? { ...element.property.stateAction } : {};
  let selectedCustomLwc =
    action.flyoutType === "customLwc"
      ? find(allLwcBundles, { DeveloperName: action.flyoutLwc })
      : {};
  let defaultNs =
    (isInsidePackge &&
      selectedCustomLwc &&
      selectedCustomLwc.ManageableState !== "unmanaged" &&
      selectedCustomLwc.NamespacePrefix) ||
    "c"; //generate OS and Childcard will have namespace as c
  let customLwcElementName = lwcPropertyNameConversion(
    `${nsPrefix}-customLwcWrapper`
  );

  return `<div slot="flyout"> ${createFlyoutTemplate(
    "",
    action,
    customLwcElementName,
    defaultNs
  )}</div>`;
}

function createFlyoutTemplate(
  Id,
  action,
  customLwcElementName,
  defaultNs,
  listenerAction
) {
  let isOsFlyout = action.flyoutType === "OmniScripts";
  let lwcname = action.flyoutLwc;
  let elementName = lwcPropertyNameConversion(`${defaultNs}-${lwcname}`);
  let template = "";
  if (action.flyoutType === "childCard") {
    lwcname = convertNameToValidLWCCase("cf-" + action.flyoutLwc);
    elementName = lwcPropertyNameConversion(`${defaultNs}-${lwcname}`);
    action.property = { ...action.flyoutParams } || {};
    let parentAttribute = { ...action.property };
    let property = {};
    property.recordId = "{recordId}";
    property.objectApiName = "{objectApiName}";
    property.parentAttribute = parentAttribute;
    property.parentMergefields = "{card}";
    if (action.cardNode) {
      property.cardNode = action.cardNode;
    }
    property.parentRecord = "{record}";
    property.records = "{_records}";
    action.property = { ...property };
    template = ` <${elementName} data-style-id="${renderedElementCount}_child" ${generateElementProperty(
      action
    )} ${Id ? "style='display:none'  data-id=" + Id : ""}></${elementName}>`;
    return template;
  }

  action.property = action.flyoutParams ? { ...action.flyoutParams } : {};
  let customLwcProperties = cloneDeep(action.property);
  let propertyValue = action.flyoutParams
    ? `'\\${JSON.stringify(action.flyoutParams)}'`
    : "";
  if (isOsFlyout) {
    propertyValue = action.flyoutParams
      ? `'\\${JSON.stringify({
          prefill: JSON.stringify(action.flyoutParams)
        })}'`
      : "";
  } else {
    let apiVars = ["{record}", "{records}", "{recordId}", "{objectApiName}"];
    let keys = Object.keys(action.property);
    keys.forEach(key => {
      let value = action.property[key];
      if (apiVars.indexOf(value) === -1 && value.indexOf("{") !== -1) {
        delete action.property[key];
      } else {
        delete customLwcProperties[key];
      }
    });
    propertyValue = customLwcProperties
      ? `'\\${JSON.stringify(customLwcProperties)}'`
      : "";
  }
  template = ` <${elementName}  ${
    isOsFlyout ? ` layout='${action.layoutType}' ` : ""
  } ${Id ? "style='display:none'  data-id=" + Id : ""} ${
    propertyValue && !isOsFlyout ? " " + generateElementProperty(action) : ""
  } ></${elementName}>`;

  if (propertyValue) {
    template = `<${customLwcElementName} element-name="${elementName}" property=${propertyValue} records={records} record-id={recordId} record={record}  card={card} ${
      listenerAction ? ` action=${listenerAction} ` : ""
    }>
    ${template}
    </${customLwcElementName}>`;
  }
  return template;
}

//card html
function generateCardHtml(cardDef, theme, item) {
  let cardHtml = "";
  let stateActiveHtml = "";
  let stateInActiveHtml = "";
  let listenToWidthResize = cardDef && cardDef.listenToWidthResize;
  styleDefinition = {};
  cardDef.states.forEach((state, index) => {
    stateActiveHtml += generateStateHtml(cardDef, index, theme, true, item);
    stateInActiveHtml += generateStateHtml(cardDef, index, theme, false, item);
  });

  if (cardDef.isRepeatable || typeof cardDef.isRepeatable === "undefined") {
    cardHtml = `<template if:true={hasRecords}>
                        <template for:each={_records} for:item="record" for:index="rindex">
                            ${stateActiveHtml}
                        </template>
                      </template>
                      <template if:false={hasRecords}>
                            ${stateInActiveHtml}
                      </template>`;
  } else {
    cardHtml = `<template if:true={hasRecords}>
                      ${stateActiveHtml}
                </template>
                <template if:false={hasRecords}>
                      ${stateInActiveHtml}
                </template>`;
  }
  let actionHtml = "";
  Object.keys(actionElementsSlotObject).forEach(ele => {
    actionHtml += actionElementsSlotObject[ele];
  });

  return `<template>
            <div class="${theme}-grid ${theme}-wrap ${theme}-is-relative ${
    listenToWidthResize ? "containersize" : ""
  }">
            ${generateToast(theme)}
            ${generateLoader(theme)}
            <template if:false={hasPermission}>
              ${requiredPermissionsError}
            </template>
            <template if:true={hasPermission}>
              ${cardHtml}
            </template>
            <template if:true={hasError}>
            {error}
            </template>
            ${generateEventListenerElement(cardDef)}
            <${nsPrefix}-action class="execute-action" re-render-flyout action-wrapperclass="slds-hide" onupdateos={updateOmniscript} onselectcards={updateSelectedCards} onsetvalue={updateAction} onfireactionevent={actionEvtHandler}>
            ${actionHtml}
            </${nsPrefix}-action>
            </div>
          </template>`;
}

//card js
function generateCardJs(
  lwcComponentName,
  theme,
  customLabels,
  cardDef,
  cardRecordId,
  customCssAttachmentId
) {
  const eventConfig = generateEventListenerAction(cardDef);
  let eventListener = eventConfig.register;
  let removeEventListeners = eventConfig.unregister;
  let extendingMixins = "";
  let omniSupport = cardDef && cardDef.osSupport;
  let multilanguageSupport = cardDef && cardDef.multilanguageSupport;
  let listenToWidthResize = cardDef && cardDef.listenToWidthResize;
  let globalCSS = cardDef && cardDef.globalCSS;
  let sessionVars = cardDef && cardDef.sessionVars;
  let styleSheet = cardDef && cardDef.customStyleSheet;
  let customStyleSheetPath =
    theme === "nds"
      ? "/assets/styles/vlocity-newport-design-system.min.css"
      : "/assets/styles/salesforce-lightning-design-system-vf.min.css";
  extendingMixins = omniSupport
    ? "FlexCardMixin(OmniscriptBaseMixin(LightningElement))"
    : "FlexCardMixin(LightningElement)";
  return (
    `import { FlexCardMixin } from "${nsPrefix}/flexCardMixin";
    import {interpolateWithRegex, interpolateKeyValue, fetchCustomLabels, loadCssFromStaticResource } from "${nsPrefix}/flexCardUtility";
    ${
      theme === "nds"
        ? `import { load } from "${nsPrefix}/newportLoader";
          `
        : ``
    }
          import { LightningElement, api, track } from "lwc";
          ${
            globalCSS && customCssAttachmentId && !styleSheet
              ? `import { loadStyle } from "lightning/platformResourceLoader";`
              : ""
          }
          import pubsub from "${nsPrefix}/pubsub";
          ${
            omniSupport
              ? `import { OmniscriptBaseMixin } from "${nsPrefix}/omniscriptBaseMixin";`
              : ""
          }
          import data from "./definition";
          
          import styleDef from "./styleDefinition";
              
          ` +
    `export default class ${lwcComponentName} extends ` +
    extendingMixins +
    `{
              @api debug;
              @api recordId;
              @api objectApiName;
              ${
                omniSupport
                  ? `@track _omniSupportKey = '${lwcComponentName}';
                  @api get omniSupportKey() {
                    return this._omniSupportKey;
                  }
                  set omniSupportKey(parentRecordKey) {
                    this._omniSupportKey = this._omniSupportKey  + '_' + parentRecordKey;
                  }`
                  : ""
              }
              @track record;
              ${sessionVars ? generateApiVariables(sessionVars) : ""}

              _regexPattern = /\\{([a-zA-Z.0-9_]+)\\}/g; //for {} fields by default
              ` +
    getCustomLabelTrackVariable(customLabels) +
    `
              ${pubsubEventVarPrefx} = [];
              ${customEventVarPrefx} = [];
              
              connectedCallback() {
                super.connectedCallback();
                this.registerEvents();
                this.setStyleDefinition(styleDef);
                data.Session = {} //reinitialize on reload
                ${
                  styleSheet
                    ? `
                      loadCssFromStaticResource(this, "${styleSheet}", "${customStyleSheetPath}").then(() => {
                      this.setDefinition(data);
                      this.isProcessing = false;
                      }).catch(() => {
                      this.setDefinition(data);
                    });`
                    : ""
                }
                ${
                  listenToWidthResize
                    ? `this.flexiPageWidthAwareCB = this.flexiPageWidthAware.bind(this);
                  window.addEventListener('resize', this.flexiPageWidthAwareCB);`
                    : ``
                }
                ${
                  customLabels && Object.keys(customLabels).length > 0
                    ? `this.customLabels = this.Label;
                      ${
                        multilanguageSupport
                          ? `
                        fetchCustomLabels(Object.keys(this.Label)).then(labels => {
                          this.Label = labels;
                          let card = {...this.card};
                          card.Label = labels;
                          this.card = card;
                          this.customLabels = this.Label;
                      });`
                          : ""
                      }`
                    : ""
                }
                ${
                  theme !== "nds" && !styleSheet
                    ? "this.setDefinition(data);"
                    : ""
                }
                ${
                  globalCSS && customCssAttachmentId
                    ? `this.setAttribute(
                  "class",
                  "card-${cardRecordId}"
                );
                this.getCommunityPrefix().then((result) => {
                  loadStyle(this, result +"/servlet/servlet.FileDownload?file=${customCssAttachmentId}").then(() =>{
                    //Loading Custom CSS.
                  })
                });`
                    : ""
                }
                ${
                  theme === "nds" && !styleSheet
                    ? `
                load(this)
                .then(() => {
                  ${theme === "nds" ? "this.setDefinition(data);" : ""}
                  this.isProcessing = false;
                  //this.isNewport = false;
                })
                .catch(() => {
                  ${theme === "nds" ? "this.setDefinition(data);" : ""}
                });
                `
                    : ""
                }
              }
              
              disconnectedCallback(){
                super.disconnectedCallback();
                    ${
                      omniSupport
                        ? "this.omniSaveState(this.records,this.omniSupportKey,true);"
                        : ""
                    }
                    ${
                      listenToWidthResize
                        ? `window.removeEventListener('resize', this.flexiPageWidthAwareCB);`
                        : ``
                    }

                  this.unregisterEvents();
              }
                  
              executeAction(event) {
                let dataset = event.currentTarget.dataset;
                if (dataset && dataset.onchange === 'setValue' ) {
                  this.setValueOnToggle(event);
                }
                if(dataset && typeof dataset.actionIndex !== 'undefined') {
                  let actionIndex = dataset.actionIndex;
                  this.elementIndex = event.currentTarget && event.currentTarget.closest(".cf-vlocity-state") ? event.currentTarget.closest(".cf-vlocity-state").dataset.rindex : null;
                  if (this.records) {
                    this.record = this.records[this.elementIndex];
                  }
                  this.action = {};
                  this.action[actionIndex] = true;
                  this.template.querySelector('.execute-action').executeAction(event, this.card);
                }
                event.stopPropagation();
              }

              registerEvents() {
                ${eventListener}
              }

              unregisterEvents(){
                ${removeEventListeners}
              }
            
              renderedCallback() {
                super.renderedCallback();
                ${
                  listenToWidthResize
                    ? `
                if(!this.containerWidthInitialised) {
                  this.containerWidthInitialised = true;
                  this.flexiPageWidthAware();
                }`
                    : ``
                }
              }

              handleEventAction(eventObj, eventIndex, event) {
                eventObj.actionList = eventObj.actionList || (eventObj.actionData ? [eventObj.actionData] : []);
                let stateIndex = 0;
                if (eventObj.eventtype === 'event' && event?.target){
                  if(this.elementIndex && event?.target?.classList.contains("execute-action")) {
                    stateIndex = this.elementIndex;
                  } else {
                    const stateElement = event.target.closest(".cf-vlocity-state")
                     ? event.target.closest(".cf-vlocity-state")
                     : null;
                    if (stateElement?.dataset.rindex) {
                    stateIndex = parseInt(stateElement.dataset.rindex, 10);
                    }
                  }
                }
                if(eventObj.actionList && eventObj.actionList.length > 0){
                  this.fireMultipleActionRecursively(eventObj, 0, null, eventIndex, event, stateIndex, data);
                }
              }
          }`
  );
}

function generateApiVariables(sessionVars) {
  let sessionHandler = "@track _sessionApiVars = {};";
  sessionVars.forEach(session => {
    if (session.isApi) {
      sessionHandler += `
        @api set ${exposedAPIPrefix}${session.name}(val) {
          if(typeof val !== "undefined") {
            this._sessionApiVars["${session.name}"] = val;
          }
        } get ${exposedAPIPrefix}${session.name}() {
          return this._sessionApiVars["${session.name}"] || "${session.val}";
        }
      `;
    }
  });
  return sessionHandler;
}

function getCustomLabelTrackVariable(customLabels) {
  if (customLabels && Object.keys(customLabels).length > 0) {
    let variableString = "@track Label={";
    Object.keys(customLabels).forEach((key, index) => {
      variableString += `${key}:"${customLabels[key]}"${
        Object.keys(customLabels).length - 1 === index ? "" : ","
      }
      `;
    });
    variableString += "};";
    return variableString;
  }
  return ``;
}

//Loader support
function generateLoader(theme) {
  return `<div if:false={cardLoaded} class="${theme}-is-absolute vloc-loader_override" style="height: 100%; width: 100%; min-height:50px; background: white; z-index: 99;">
  <div>
   <${nsPrefix}-spinner
      variant="brand"
      alternative-text="Loading content..."
      size="${theme === "slds" ? "medium" : "small"}"
      theme="${theme}"
      ></${nsPrefix}-spinner>
  </div>
</div>`;
}

function generateToast(theme) {
  return `<div style="position: fixed;z-index: 999999;top: 0;right: 0;">
  <${nsPrefix}-toast class="flexcard-toast-element" theme="${theme}" title="" message="" styletype=""> </${nsPrefix}-toast>
</div>`;
}

//Event Listener Support
function generateEventListenerElement(cardDef) {
  let flyoutSlots = "";
  if (cardDef.events) {
    cardDef.events.forEach((eve, eventIndex) => {
      //Convert previously configured single action into multiple action array
      eve.actionList =
        eve.actionList || (eve.actionData ? [eve.actionData] : []);
      if (eve.actionList) {
        eve.actionList.forEach((action, actionIndex) => {
          flyoutSlots += generateFlyoutForTriggerActionElement(
            action,
            `listener${eventIndex}action${actionIndex}`
          );
        });
      }
    });
  }
  return `
      <${nsPrefix}-action action-wrapperclass="slds-hide" re-render-flyout class="action-trigger slds-col" onupdateos={updateOmniscript} onselectcards={updateSelectedCards} onsetvalue={updateAction} onfireactionevent={actionEvtHandler}>
      ${flyoutSlots}
      </${nsPrefix}-action>
  `;
}

function getDynamicChannelName(name) {
  const regex = /\{([a-zA-Z.0-9_[\]]*)\}/g;
  let dynamicName;
  dynamicName = name.replace(regex, function(match, exp) {
    if (exp && exp === "recordId") {
      return "${this.recordId}";
    }
    return match;
  });
  return dynamicName;
}

function generateEventListenerAction(cardDef) {
  let pubSubRegisterConfig = "";
  let pubSubUnregisterConfig = "";
  let customEvents = [];
  if (cardDef.events) {
    let groupEvents = {};
    cardDef.events.forEach((eve, index) => {
      const channelName = getDynamicChannelName(eve.channelname);
      if (eve.eventtype === "pubsub") {
        if (!groupEvents[channelName]) {
          groupEvents[channelName] = [];
        }
        groupEvents[channelName].push(
          `${eve.eventname}: this.handleEventAction.bind(this, data.events[${index}],${index})`
        );
      } else {
        customEvents.push({
          [eve.eventname]: `this.handleEventAction.bind(this, data.events[${index}],${index})`
        });
      }
    });
    Object.keys(groupEvents).forEach((key, index) => {
      pubSubRegisterConfig += `
        this.${pubsubEventVarPrefx}[${index}] = {
          ${groupEvents[key].join(",\n")}
        };

        pubsub.register(\`${key}\`,this.${pubsubEventVarPrefx}[${index}]);\n`;

      pubSubUnregisterConfig += `pubsub.unregister(\`${key}\`,this.${pubsubEventVarPrefx}[${index}]);\n`;
    });
    if (customEvents.length > 0) {
      customEvents.forEach((eve, index) => {
        Object.keys(eve).forEach(cusEve => {
          pubSubRegisterConfig += `
            this.${customEventVarPrefx}[${index}] = ${eve[cusEve]};\n
            this.template.addEventListener('${cusEve}',this.${customEventVarPrefx}[${index}]);\n
          `;
          pubSubUnregisterConfig += `
            this.template.removeEventListener('${cusEve}',this.${customEventVarPrefx}[${index}]);\n`;
        });
      });
    }
  }
  return { register: pubSubRegisterConfig, unregister: pubSubUnregisterConfig };
}

//getDefinitoon
function generateDefinition(object) {
  let cardObjectFields = getCardObjectFields(object);
  var itemDefinition = object[cardObjectFields.PropertySetConfig];
  if (itemDefinition.bypassSave) delete itemDefinition.bypassSave;
  if (itemDefinition && typeof itemDefinition === "string") {
    itemDefinition = JSON.parse(itemDefinition);
  }
  if (
    itemDefinition &&
    itemDefinition.dataSource &&
    itemDefinition.dataSource.contextVariables &&
    itemDefinition.dataSource.contextVariables.length > 0
  ) {
    itemDefinition.dataSource.contextVariables = [];
  }
  itemDefinition.Id = object.Id;
  itemDefinition[cardObjectFields.OmniUiCardKey] =
    object[cardObjectFields.OmniUiCardKey];
  itemDefinition[cardObjectFields.Type] = object[cardObjectFields.Type];
  if ("IsChildCard" in cardObjectFields) {
    itemDefinition[cardObjectFields.IsChildCard] =
      object[cardObjectFields.IsChildCard];
  }

  //Perf fix xml data is not required on def
  return `let definition =
      ${JSON.stringify(omit(itemDefinition, ["xmlObject", "xmlJson"]))};
  export default definition`;
}

function updateStyleDefinitionJSON(id, ele, additionalClasses) {
  //Adding runtime styling only when its a conditional element or it support conditional style and for others adding default style
  if (
    ele.styleObjects?.length > 1 ||
    (ele.styleObjects?.length > 0 && ele.property["data-conditions"])
  ) {
    styleDefinition[id] = [];
    ele.styleObjects.forEach((style, index) => {
      let styleObject = updateStyleDefinitionJSONStyleObject(
        ele,
        additionalClasses,
        style,
        index
      );
      styleDefinition[id].push(styleObject);
    });
  } else if (ele.property["data-conditions"]) {
    styleDefinition[id] = [];
    let styleObject = updateStyleDefinitionJSONStyleObject(
      ele,
      additionalClasses
    );
    styleDefinition[id].push(styleObject);
  }
}

function updateStyleDefinitionJSONStyleObject(
  ele,
  additionalClasses,
  style,
  index
) {
  return {
    conditions: style ? style.conditions : "default",
    styleObject: {
      class: `${ele.class ? ele.class : ""} ${getConditionalElementClass(
        ele
      )} ${getElementStyle(ele, "class", index)} ${getElementStyle(
        ele,
        "sizeClass",
        index
      )} ${additionalClasses ? additionalClasses : ""}`,
      style: getElementStyle(ele, "style", index),
      styleProperties: getElementStyle(ele, "elementStyleProperties", index)
    }
  };
}

//get style definition
function generataStyleDefinition() {
  return `let styleDefinition =
      ${JSON.stringify(styleDefinition)};
  export default styleDefinition`;
}

function getComponentSvg() {
  return `<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 200 200" height="200px" width="200px">
  <g fill-rule="evenodd" fill="#059DD3" stroke-width="1" stroke="none">
      <path d="M148,47.9c-4.2-11.3-15.1-18.8-27-18.8c-4,0-7.8,0.8-11.4,2.3c-8.4-8-19.4-12.4-31.1-12.4c-23.7,0-43.4,18.4-45.1,42
          C19.1,67,9.8,80.9,9.8,96.5c0,21.2,17.3,38.5,38.5,38.5c4.1,0,9,0,14.3,0l2.3-15.2l-16.4,0c-12.6,0-23-10.7-23-23.3
          c0-10.7,7.2-19.8,17.6-22.3l6.4-1.5L49,65.6l0-0.1c0-0.4-0.1-0.9-0.1-1.3c0-16.3,13.3-29.6,29.6-29.6c9.2,0,17.7,4.2,23.4,11.5
          l4.8,6.1l0.2-0.3c2.7-4.8,7.9-7.7,13.3-7.7c8.5,0,15.4,6.9,15.4,15.4c0,1.6-0.7,5.2-0.7,5.2l-0.1,0.4l0.4-0.1
          c0.1,0,5.9-1.6,12.2-1.6c15.5,0,28.1,12.6,28.1,28.1c0,15.5-12.6,28.1-28.1,28.1l-9.2,0l-8.5,15.3c7.9,0,14.3,0,18.2,0h0h0
          c23.9-0.7,43.3-20.2,43.3-43.4C191.1,67.9,171.8,48.3,148,47.9z"></path>
      <polygon points="87.3,76 115.6,76 100.1,119.8 123.1,119.9 89.1,180.1 96,135.2 76.7,135.2"></polygon>
  </g>
</svg>`;
}

function generateInActiveHtml(item) {
  return `<template><div class="slds-card slds-p-around_medium slds-size_1-of-1">
                        There is no active instance of <br>
                        <b>CARD</b> ${item.Name}
                    </div></template>`;
}

//get all components files
function generateLWCFiles(lwcComponentName, item, type) {
  let files = [];
  let jsSource, defSource, htmlSource, cssSource, styleDefSource;
  let cardObjectFields = getCardObjectFields(item);
  let layoutDefinition = item[cardObjectFields.PropertySetConfig];
  actionElementsSlotObject = {};
  if (layoutDefinition && typeof layoutDefinition === "string") {
    layoutDefinition = JSON.parse(layoutDefinition);
  }
  let theme = layoutDefinition.theme || "slds";
  let customCssAttachmentId =
    item.Attachments && item.Attachments[0] && item.Attachments[0].Id;
  let cardRecordId = item.Id;
  if (type === "card") {
    htmlSource = generateCardHtml(layoutDefinition, theme, item);
    jsSource = generateCardJs(
      lwcComponentName,
      theme,
      item.Label,
      layoutDefinition,
      cardRecordId,
      customCssAttachmentId
    );
    cssSource =
      typeof item[cardObjectFields.StylingConfiguration] === "string"
        ? JSON.parse(item[cardObjectFields.StylingConfiguration]).customStyles
          ? JSON.parse(item[cardObjectFields.StylingConfiguration]).customStyles
          : "/*Custom Styles*/"
        : item[cardObjectFields.StylingConfiguration]
        ? item[cardObjectFields.StylingConfiguration].customStyles
          ? item[cardObjectFields.StylingConfiguration].customStyles
          : "/*Custom Styles*/"
        : "/*Custom Styles*/";
    defSource = generateDefinition(item);
    styleDefSource = generataStyleDefinition();
  }

  files.push({
    name: `${lwcComponentName}.js`,
    source: jsSource,
    filepath: `lwc/${lwcComponentName}/${lwcComponentName}.js`,
    format: "js"
  });
  if (defSource) {
    files.push({
      name: `definition.js`,
      source: defSource,
      filepath: `lwc/${lwcComponentName}/definition.js`,
      format: "js"
    });
  }
  if (styleDefSource) {
    files.push({
      name: `styleDefinition.js`,
      source: styleDefSource,
      filepath: `lwc/${lwcComponentName}/styleDefinition.js`,
      format: "js"
    });
  }
  files.push({
    name: `${lwcComponentName}.html`,
    source: htmlSource,
    filepath: `lwc/${lwcComponentName}/${lwcComponentName}.html`,
    format: "html"
  });
  files.push({
    name: `${lwcComponentName}.svg`,
    source: getComponentSvg(),
    filepath: `lwc/${lwcComponentName}/${lwcComponentName}.svg`,
    format: "svg"
  });
  files.push({
    name: `${lwcComponentName}.css`,
    source: cssSource,
    filepath: `lwc/${lwcComponentName}/${lwcComponentName}.css`,
    format: "css"
  });
  return files;
}

function getMetaData(lwcName, obj, type) {
  let cardObjectFields = getCardObjectFields(obj);
  let isActive = obj[cardObjectFields.IsActive];
  const isChildCard =
    obj[cardObjectFields.IsChildCard] ||
    (obj[cardObjectFields.Type] &&
      obj[cardObjectFields.Type].toLowerCase() === "child");
  let lwcCmp = {
    name: lwcName,
    files: generateLWCFiles(lwcName, obj, type)
  };
  let resources = [];
  lwcCmp.files.forEach(function(file) {
    resources.push({
      source: btoa(unescape(encodeURIComponent(file.source))),
      filePath: file.filepath
    });
  });
  let cardDefxml = cloneDeep(
    JSON.parse(obj[cardObjectFields.PropertySetConfig]).xmlObject
  );

  if (isActive && cardDefxml) {
    obj = {
      apiVersion: cardDefxml.apiVersion || defaultXmlConfig.api,
      isExposed: true,
      lwcResources: {
        lwcResource: resources
      },
      masterLabel: cardDefxml.masterLabel || (isActive ? obj.Name : lwcName),
      description: cardDefxml.description || ""
    };
    if (!isChildCard) {
      obj.targets = cardDefxml.targets || {
        target: defaultXmlConfig.targets
      };
      obj.targetConfigs =
        cardDefxml.targetConfigs || window.btoa(defaultXmlConfig.targetConfigs);
    }
  } else {
    obj = {
      apiVersion: defaultXmlConfig.api,
      isExposed: true,
      lwcResources: {
        lwcResource: resources
      },
      masterLabel: isActive ? obj.Name : lwcName
    };
    if (isActive && !isChildCard) {
      obj.targets = {
        target: defaultXmlConfig.targets
      };
      if (!isChildCard)
        obj.targetConfigs = window.btoa(defaultXmlConfig.targetConfigs);
    }
  }
  if (isInsidePackge) {
    obj.runtimeNamespace = nsPrefix;
  }

  return obj;
}

function getDevNamefromCardname(cardName) {
  return convertNameToValidLWCCase(lwcPrefix + "-" + cardName);
}

export {
  generateStateHtml,
  generateCardHtml,
  generateCardJs,
  generateInActiveHtml,
  generateDefinition,
  generateLWCFiles,
  getMetaData,
  defaultXmlConfig
};
