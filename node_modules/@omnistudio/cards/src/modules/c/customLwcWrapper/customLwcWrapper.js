/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { LightningElement, api, track } from "lwc";
import { BaseFlexElementMixin } from "c/baseFlexElementMixin";
import { interpolateKeyValue } from "c/flexCardUtility";
import { isEqual, isEmpty } from "c/lodash";

export default class customLwcWrapper extends BaseFlexElementMixin(
  LightningElement
) {
  @api elementName;
  @api recordId;
  @api records;
  @api get action() {
    return this._action;
  }
  set action(val) {
    if (val) {
      this._action = val;
      this.isElementRendered = true;
      this.triggerRender();
    }
  } //to support listener action data
  @api get record() {
    return this._record;
  }
  set record(val) {
    if (val && typeof val === "object") {
      this._record = Array.isArray(val) ? [...val] : { ...val };
    }
    if (this.isElementRendered) {
      this.isRecordUpdated = true;
      this.setAttributes(this.originalProperty, true);
    }
    if (val && this.property) {
      this.interpolate("record");
      this.isRecordUpdated = false;
    }
  }
  @api get property() {
    return this._property;
  }
  set property(val) {
    this._property = val
      ? typeof val === "string"
        ? this.validObj(val)
        : val
      : {};
    if (val && !isEmpty(val)) {
      this.originalProperty = { ...this._property };
      this.setAttributes(this._property);
    }
  }

  triggerRender() {
    if (this.isElementRendered) {
      this.isMergeFieldUpdated = true;
      this.setAttributes(this.originalProperty, true);
    }
    this.interpolate("mergeField");
    this.isMergeFieldUpdated = false;
  }

  @track _allMergeFields;
  @track fieldUpdated = false;

  propertyToInterpolate = [];
  interpolatedProperty = {};
  _regexPattern = /\{([a-zA-Z.0-9_[\]]*)\}/g;

  renderedCallback() {
    let ele = this.querySelector(this.elementName);

    if (this.fieldUpdated && ele) {
      this.setElementData(ele);
    }
  }

  setElementData(ele) {
    let obj = { ...this.interpolatedProperty };
    for (let key in obj) {
      if (obj[key]) {
        let value = obj[key];
        if (key === "disabled" || key === "required" || key === "checked") {
          let isBoolean =
            value === "true" ||
            value === true ||
            value === "false" ||
            value === false;
          value = isBoolean ? value === "true" || value === true : value;
        }
        if (typeof value === "string" && value.charAt(0) === "\\") {
          value = value.substring(1);
        }
        if (!isEqual(ele[key], value)) ele[key] = value;
        delete obj[key];
      }
    }
    this.interpolatedProperty = { ...obj };
    this.isElementRendered = true;
    this.fieldUpdated = false;
  }

  validObj(property) {
    if (typeof property === "string") {
      try {
        if (property.indexOf("\\") === 0) {
          property = property.substring(1);
        }
        return JSON.parse(property);
      } catch (e) {
        return property;
      }
    }
    return property;
  }

  setAttributes(property, skipRecordInterpolation) {
    property = this.interpolatedVal(property);
    let apiVars = ["{record}", "{records}", "{recordId}"];
    for (let key in property) {
      if (key) {
        let value = property[key];
        if (
          value &&
          typeof value === "string" &&
          value.match(this._regexPattern)
        ) {
          this.propertyToInterpolate.push(key);
        }
        if (apiVars.indexOf(value) === -1 && !this.isElementRendered) {
          this.interpolatedProperty[key] = value;
        }
      }
    }
    if (this.record && !skipRecordInterpolation) {
      this.interpolate("record");
    }
  }

  interpolatedVal(property) {
    let data = property ? property : this.originalProperty;
    let obj =
      this._allMergeFields && this.isRecordUpdated
        ? this._allMergeFields
        : this.record && this.isMergeFieldUpdated
        ? this.record
        : null;
    if (obj) {
      let interpolatedProperty = interpolateKeyValue(
        data,
        obj,
        this._regexPattern
      );
      return interpolatedProperty;
    }
    return data;
  }

  interpolate(type) {
    let obj = type === "record" ? this.record : this._allMergeFields;
    if (this.action) {
      obj.action = this.action;
    }
    let propertyObj =
      this.isRecordUpdated || this.isMergeFieldUpdated
        ? this.interpolatedVal()
        : this.property;

    let interpolatedProperty = this.interpolateAttributes(propertyObj, obj);
    this._property = { ...interpolatedProperty };
    if (this.propertyToInterpolate) {
      let apiVars = ["{record}", "{records}", "{recordId}"];
      let _propertyToInterpolate = [...this.propertyToInterpolate];
      this.propertyToInterpolate.forEach((prop, index) => {
        if (
          interpolatedProperty[prop] &&
          typeof interpolatedProperty[prop] === "string" &&
          apiVars.indexOf(interpolatedProperty[prop]) === -1 &&
          interpolatedProperty[prop] !== this.interpolatedProperty[prop]
        ) {
          let value =
            interpolatedProperty[prop].charAt(0) === "\\"
              ? interpolatedProperty[prop].substring(1)
              : interpolatedProperty[prop];
          this.interpolatedProperty[prop] = value;
          if (!interpolatedProperty[prop].match(this._regexPattern)) {
            _propertyToInterpolate.splice(index, 1);
          }
        } else if (
          interpolatedProperty[prop] &&
          typeof interpolatedProperty[prop] !== "string" &&
          !isEqual(interpolatedProperty[prop], this.interpolatedProperty[prop])
        ) {
          this.interpolatedProperty[prop] = interpolatedProperty[prop];
          _propertyToInterpolate.splice(index, 1);
        }
      });
      this.propertyToInterpolate = [..._propertyToInterpolate];

      let diffObj =
        (!this.oldInterpolatedProperty && this.interpolatedProperty) ||
        !isEqual(this.interpolatedProperty, this.oldInterpolatedProperty);
      if (diffObj) {
        this.oldInterpolatedProperty = { ...this.interpolatedProperty };
        this.fieldUpdated = true;
      }
    }
  }

  interpolateAttributes(propertyObj, obj) {
    if (propertyObj && propertyObj.prefill) {
      let attributes = this.validObj(propertyObj.prefill);
      attributes = interpolateKeyValue(attributes, obj);
      propertyObj.prefill = JSON.stringify(attributes);
      return propertyObj;
    }
    return interpolateKeyValue(propertyObj, obj, this._regexPattern);
  }
}
