/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { api, track } from "lwc";
import {
  getDataHandler,
  Logger,
  datasourceParser,
  params,
  interpolateWithRegex,
  groupFilter,
  getUserProfile,
  unsubscribeEMP,
  subscribeEMP,
  interpolateKeyValue,
  createCardsArrayForDebugJSONPanel,
  postMessage,
  getActionDebugEventObj,
  formatActionDebugEventObj,
  setValueOfRecords,
  extractCardMergeFields,
  getCardObjectFields,
  getCardDataById,
  executeDataAction,
  dataActionUpdateRecords,
  getErrorMessage,
  interpolateElement,
  trackUsage
} from "c/flexCardUtility";
import { get, isEqual, isEmpty, orderBy, set, cloneDeep, omit } from "c/lodash";
import { isCommunityPage, loadSDK, invokeSDKMethod } from "c/utility";
import {
  doEncryptedDatasourceFlex,
  checkPermission,
  ErrorToastTitle
} from "c/flexCardUtils";
import vtag from "c/oaVtag";
import pubsub from "c/pubsub";

export const FlexCardMixin = Base =>
  class extends Base {
    @api recordId;
    @api objectApiName;
    @api theme;
    @api orgNsPrefix;
    @api set sessionVars(val) {
      this._sessionVars = val;
      if (val) {
        val.forEach(field => {
          if (!this.session[field.name]) {
            this.session[field.name] = field.val;
          }
        });
      }
    }
    get sessionVars() {
      return this._sessionVars;
    }

    @api set searchParam(value) {
      this._searchParam = value;
    }

    get searchParam() {
      return this._searchParam;
    }

    @api
    set obj(value) {
      if (value) {
        this._obj = value;
      }
    }

    get obj() {
      return this._obj;
    }
    @api isRecursive;

    @api debug;
    @api isChildCardTrackingEnabled = false;
    @api trackingObj;
    @track _childCardTrackingObj;

    @api get testParams() {
      return this._testParams;
    }

    set testParams(val) {
      if (val) {
        this._testParams = cloneDeep(val);
      }
    }

    _testParams;

    @track rerenderLwc = false;
    @track userProfile;
    @track _obj;
    @api size = "4";
    @track _searchParam = null;
    @track _sessionVars;
    @track _records;
    @track session = {};
    @track data;
    @track error;
    @track Params = {};
    @track card;
    @track customLabels;
    @track action = {};
    @track _oaObj = {};
    @track _allMergeFields;
    @track trackBusinessEvent;
    @track trackBusinessCategory;
    @track cardStyles;

    _regexPattern = /\{([a-zA-Z.0-9_[\]]+)\}/g; //for {} fields by default
    _sObjects;
    _isRedraw = false;
    firstRender = true;
    actionsInfoMap;
    cardInterval;
    _objType = "";
    isCommunity = false;
    childCardCount = 0;
    actionListener = false;
    initialEvent = true;
    subscribedStreamingApiList = [];
    @track selectedCardsLabel = "";
    @track _isStateSelected = false;
    @track hasLayoutRecord = false;
    @track isRecordLoaded = false;
    @track _recordProcessed = false;
    @track _recordsUpdated = false;
    @track cardLoaded = false;
    @track _sessionApiVars = {}; //Support Session Api Vars
    @track debugJSONData = {
      User: null,
      Session: null,
      Params: null,
      TestParams: null,
      Label: null,
      dataSource: {
        config: null,
        records: null
      },
      title: null,
      theme: null,
      recordId: null,
      cards: []
    };

    _isInsideIframe;
    @track hasPermission = true;
    @track hasError = false;
    _requiredPermissionPromise;
    @api
    set records(value) {
      if (value && (this._dataNode || this._parentData)) {
        value = Array.isArray(value) ? [...value] : [{ ...value }]; //Perf fix when passing records to multi level
        if (this._dataNode) {
          let exp = this._dataNode.replace(/[{}]/g, "");
          let _records = [];
          _records = get({ records: value, record: this.parentRecord }, exp);
          this._records = Array.isArray(_records)
            ? _records
            : typeof _records === "object"
            ? [_records]
            : [];
        } else {
          this._records = value;
        }
        this.isRecordLoaded = true;
        this.hasLayoutRecord = true;
        this.updateKeys();
        this.setStateObj();
      }
    }

    get records() {
      return this._records;
    }
    @track _dataNode;
    @track _parentData;
    @api set cardNode(val) {
      if (val) {
        this._dataNode = val;
      }
    }
    get cardNode() {
      return this._dataNode;
    }

    @api set parentData(val) {
      if (val) {
        this._parentData = val;
      }
    }
    get parentData() {
      return this._parentData;
    }
    @api parentUniquekey;

    @api isInsideParent;
    insideParent = false;

    //Support Parent data interpolation
    _oldParentData;
    _differnceInParent = [];
    _unInterpolatedCardData;
    _usageTracked = false;
    @track _parentAttrbute;
    @track _parentRecord;
    @track _parent = {};
    @track uniqueKey;
    @track _parentMergeField = {};
    @api set parentRecord(val) {
      if (val) {
        this._parentRecord = Array.isArray(val) ? [...val] : { ...val };
        this.processParentRecord();
        if (this.hasLayoutRecord && this._dataNode) {
          let exp = this._dataNode.replace(/[{}]/g, "");
          let _records = [];
          _records = get(
            { records: this._records, record: this._parentRecord },
            exp
          );
          this._records = Array.isArray(_records)
            ? _records
            : typeof _records === "object"
            ? [_records]
            : [];
          this.updateKeys();
          this.setStateObj();
        }
      }
    }
    get parentRecord() {
      return this._parentRecord;
    }

    @api set parentAttribute(val) {
      if (val) {
        this._parentAttrbute =
          typeof val === "string"
            ? val.indexOf("\\") === 0
              ? JSON.parse(val.substring(1))
              : JSON.parse(val)
            : val;
        this.processParentRecord();
      }
    }
    get parentAttribute() {
      return this._parentAttrbute;
    }

    @api get parentMergefields() {
      return this._parentMergeField;
    }

    set parentMergefields(val) {
      if (val) {
        this._parentMergeField = extractCardMergeFields(val);
        this.processParentRecord();
      }
    }
    processParentRecord() {
      if (
        this._parentAttrbute &&
        (this._parentRecord || this._parentMergeField)
      ) {
        Object.keys(this._parentAttrbute).forEach(key => {
          if (this._parentAttrbute[key] === "{record}") {
            this._parent[key] = this._parentRecord;
          } else {
            this._parent[key] = this.interpolateValue(
              this._parentAttrbute[key],
              {
                ...this._parentRecord,
                ...this._parentMergeField
              }
            );
          }
        });
      } else if (this._parentAttrbute) {
        this._parent = this._parentAttrbute;
      }
      if (!this.data) {
        this._oldParentData = { ...this._parent };
      }
      if (this.data && this._parent) {
        this.getParentDataDiff();
      }
    }

    getParentDataDiff() {
      if (!this._oldParentData) {
        this.setDefinition(this._unInterpolatedCardData);
      } else {
        this._differnceInParent = Object.keys(this._parent).filter(k => {
          //not going to compare and update data if its an object
          if (
            typeof this._parent[k] === "object" &&
            typeof this._oldParentData[k] === "object"
          ) {
            return false;
          }
          return this._parent[k] !== this._oldParentData[k];
        });
        if (this._differnceInParent.length === 0) {
          return; //return and do not proceed if there are no difference in parent data
        }
        this._oldParentData = { ...this._parent };
        this.setDefinition(this._unInterpolatedCardData);
      }
    }

    connectedCallback() {
      if (!this._oaObj.StartTime) this._oaObj.StartTime = Date.now();
      this.template.addEventListener("reload", this.triggerReload);
      this.template.addEventListener("updatedatasource", this.updateDatasource);
      this.template.addEventListener("remove", this.remove);
      this.template.addEventListener(
        "updatestyle",
        this.handleUpdateStyleEvent
      );
      this.template.addEventListener("showtoast", this.toastHandler);
      this._updateFieldBinding = this.updateFieldBinding.bind(this);
      this.template.addEventListener(
        "updatefieldbinding",
        this._updateFieldBinding
      );
      this.pendingCommunityPromise = isCommunityPage().then(result => {
        this.isCommunity = result;
        this.pendingCommunityPromise = null;
      });
      this._isInsideIframe =
        window.location !== window.parent.location ? true : false;
    }

    disconnectedCallback() {
      clearInterval(this.cardInterval);
      if (this.subscribedStreamingApiList?.length) {
        this.subscribedStreamingApiList.forEach(channelName => {
          unsubscribeEMP(channelName);
        });
        this.subscribedStreamingApiList = [];
      }
      this.template.removeEventListener("reload", this.triggerReload);
      this.template.removeEventListener(
        "updatedatasource",
        this.updateDatasource
      );
      this.setOaObj("Card Unload");
      this.template.removeEventListener("remove", this.remove);
      this.template.removeEventListener(
        "updatestyle",
        this.handleUpdateStyleEvent
      );
      this.template.removeEventListener("showtoast", this.toastHandler);
      if (this.isPreview && this.actionListener) {
        this.template.removeEventListener(
          "actionclick",
          this.updateActionDebugger
        );
        this.actionListener = false;
      }
      this.template.removeEventListener(
        "updatefieldbinding",
        this._updateFieldBinding
      );
      if (this._dynamicPubsubRegister.size) {
        this._dynamicPubsubRegister.forEach((value, key) => {
          pubsub.unregister(key, value);
        });
      }
    }

    handleUpdateStyleEvent = event => {
      this.handleCardStyleUpdate(event);
      event.stopImmediatePropagation();
    };

    updateActionDebugger = (event, status, response) => {
      if (!this.isPreview) return;
      if (response) {
        response = cloneDeep(response);
      }
      let data = formatActionDebugEventObj(event, status, response, this.data);
      if (this._isInsideIframe)
        postMessage("actionDebuggerJson", "", data, "*");
      if (event && event.type === "actionclick") {
        event.stopImmediatePropagation();
      }
    };

    remove = event => {
      event.stopPropagation();
      let stateEle = event.target && event.target.closest(".cf-vlocity-state");
      let index = null;
      if (stateEle || this.elementIndex >= 0) {
        index = stateEle
          ? stateEle.dataset.rindex
          : this.elementIndex >= 0
          ? this.elementIndex
          : null;
      } else if (
        event.action &&
        (event.action.eventtype === "pubsub" ||
          event.action.eventtype === "event")
      ) {
        index = event.action.recordIndex || 0;
      }
      if (index !== null && index >= 0 && this._records[index]) {
        this._records.splice(index, 1);
        this.pickRecords(this._records);
        this.updateKeys();
        this.setStateObj();
      }
      let actionEvtObj = getActionDebugEventObj(
        "Remove",
        index,
        this._records,
        event.detail
      );
      this.updateActionDebugger(actionEvtObj);
    };
    updateDatasource = event => {
      event.stopPropagation();
      if (event && event.detail) {
        this.data.dataSource = JSON.parse(event.detail.message);
        //Support to use {records} on updateDS mergefields
        let matched = event.detail.message.match(this._regexPattern);
        if (matched && matched.length > 0) {
          this.data.dataSource = interpolateKeyValue(this.data.dataSource, {
            records: this._records
          });
        }
        this.firstRender = true;
        this._records = [];
        this.cardLoaded = false;
        this.setDefinition(this.data, {
          type: "updateDS",
          detail: event.detail
        });
      }
    };

    /**
     *
     * This is method is a custom event hander method of action element
     * @param {T} event Event from where it is triggered
     */
    actionEvtHandler(event) {
      if (event?.detail?.type === "Data Action") {
        this.fireDataAction(event);
        event.stopPropagation();
      }
    }
    /**
     *
     * This method is used to fire data type action
     * @param {T} event Event from where it is triggered
     */
    async fireDataAction(event) {
      if (event && event.detail) {
        let dataObject = JSON.parse(event.detail.message);
        //Support to use {records} on updateDS mergefields
        let matched = event.detail.message.match(this._regexPattern);
        if (matched && matched.length > 0) {
          dataObject = interpolateKeyValue(dataObject, {
            records: this._records
          });
        }
        dataObject = datasourceParser(dataObject);
        if (dataObject.contextVariables) {
          dataObject = this.interpolateTestParams(dataObject);
        }
        let data = {
          index: this.getStateIndex(event),
          node: event.detail.responseNode || "record",
          records: this._records,
          ignoreResponse: event.detail.ignoreResponse
        };
        if (dataObject?.value?.resultVar) {
          data.path = dataObject.value.resultVar;
        }
        // Callback method for streaming api
        const callback = response => {
          if (response && data.path) {
            response = get(response, data.path);
          }
          data.response = Array.isArray(response)
            ? [...response]
            : { ...response };
          this.recordUpdateOnDataAction(data, event);
        };
        try {
          let response;
          let timeout = dataObject?.value?.timeout;
          if (!dataObject.value || !dataObject.value.dsDelay) {
            response = await executeDataAction(
              dataObject,
              callback.bind(this),
              this.session.debugFlag,
              timeout
            );
          } else {
            // eslint-disable-next-line @lwc/lwc/no-async-operation
            await new Promise(resolve => {
              setTimeout(resolve, dataObject.value.dsDelay);
            });
            response = await executeDataAction(
              dataObject,
              callback.bind(this),
              this.session.debugFlag,
              timeout
            );
          }
          this.processDataActionResponse(
            "success",
            response,
            data,
            dataObject,
            event
          );
        } catch (e) {
          this.processDataActionResponse("error", e, data, dataObject, event);
        }
      }
    }

    /**
     *
     * This method is used to process the response of data action
     * @param {Object} dataObject
     */
    processDataActionResponse(type, response, data, dataObject, event) {
      if (type === "success") {
        if (response && dataObject.type === "IntegrationProcedures") {
          if (response?.error === "OK") {
            response = response.IPResult;
          }
        }
        if (response && data.path) {
          response = get(response, data.path);
        }
        data.response = Array.isArray(response)
          ? [...response]
          : { ...response };
        data.response = this.setDataActionOrderBy(response, dataObject);
        if (dataObject.type !== "StreamingAPI") {
          this.recordUpdateOnDataAction(data, event);
        } else {
          let channelName = dataObject?.value ? dataObject.value.channel : "";
          if (
            channelName &&
            this.subscribedStreamingApiList.indexOf(channelName) === -1
          ) {
            this.subscribedStreamingApiList.push(channelName);
          }
        }
      } else if (type === "error") {
        let config = {
          response: data.response,
          node: data.node,
          ignoreResponse: data.ignoreResponse,
          error: response
        };
        this.fireDataActionDebugEvent(config, event, "error");
      }
    }

    //Handeling orderBy on records
    setDataActionOrderBy(response, dataObject) {
      if (dataObject?.orderBy?.name) {
        let orderedBy = dataObject.orderBy;
        let isReverse =
          orderedBy.isReverse === "true" || orderedBy.isReverse === true
            ? "desc"
            : "asc";
        if (Array.isArray(response)) {
          this.log("Setting data action records order by ", orderedBy);
          response = orderBy(response, orderedBy.name, isReverse);
        }
      }
      return response;
    }

    /**
     *
     * This method is used to interpolate test parameters in a datasource object
     * @param {Object} dataObject
     */
    interpolateTestParams(dataObject) {
      let contextVar = {};
      let data = { ...dataObject };
      data.contextVariables.forEach(contextVariable => {
        set(contextVar, contextVariable.name, contextVariable.val);
      });
      data = interpolateWithRegex(data, contextVar, this._regexPattern);
      return data;
    }
    /**
     *
     * This method is used to update records using data ype action
     * @param {Object} data It contains the response of Data fetched from data type action
     * @param {T} event Event from where it is triggered
     */
    recordUpdateOnDataAction(data, event) {
      let config = {
        response: data.response,
        node: data.node,
        ignoreResponse: data.ignoreResponse
      };

      if (data.response && !data.ignoreResponse) {
        dataActionUpdateRecords(data)
          .then(result => {
            config.data = result;
            this._records = [...result];
            this.pickRecords(this._records);
            this.updateKeys();
            this.setStateObj();
            this.fireDataActionDebugEvent(config, event, "Success");
          })
          .catch(e => {
            config.error = e;
            this.fireDataActionDebugEvent(config, event, "error");
          });
      } else {
        this.fireDataActionDebugEvent(config, event, "Success");
      }
    }
    /**
     *
     * This method is sued to fire action debugger event for data type action
     * @param {Object} obj it contains either updated records from data type action or else the error message after fetching data
     * @param {T} event Event from where it is triggered
     * @param {String} status It represents the status of action performed. Success or Error.
     */
    fireDataActionDebugEvent(obj, event, status) {
      if (status === "Success") {
        let actionEvtObj = getActionDebugEventObj("Data Action", obj, event);
        this.updateActionDebugger(actionEvtObj);
      } else {
        let msg = getErrorMessage(obj.error);
        this.showToast(msg, ErrorToastTitle, "error");
        console.error(msg);
        let actionEvtObj = getActionDebugEventObj("Data Action", obj, event);
        this.updateActionDebugger(actionEvtObj, "Error", msg);
      }
    }

    triggerReload = event => {
      if (event) event.stopPropagation();
      this.cardLoaded = false;
      this.eventActionType = "reload";
      this.setDefinition(this.data, {
        type: "reload",
        detail: event.detail
      });
      setTimeout(() => {
        this.eventActionType = null;
      }, 0);
    };
    /**
     * This method is used to show error toast message in flex cards
     * @param {*} message
     * @param {*} title
     * @param {*} type
     */
    showToast(message, title, type) {
      let elem = this.template.querySelector(".flexcard-toast-element");
      if (elem) {
        elem.message = message;
        elem.styletype = type ? type : "success";
        elem.duration = elem.styletype === "success" ? "3000" : "";
        elem.title = this.data?.title ? `${title}: ${this.data.title}` : title;
        elem.classList.remove("slds-hide");
        elem.show();
      }
    }

    toastHandler = event => {
      if (event) {
        if (event.detail?.error) {
          this.showToast(event.detail.error, ErrorToastTitle, "error");
        }
        event.stopImmediatePropagation();
      }
    };

    handleDataSourceError(error) {
      let msg = getErrorMessage(error);
      this.errorCallback(msg);
      if (this.dsAction && this.dsAction.obj && this.dsAction.type) {
        this.updateActionDebugger(this.dsAction, "Error", msg);
      }
    }

    getCachedUserProfile() {
      return new Promise(resolve => {
        if (sessionStorage.getItem("userProfile")) {
          resolve(JSON.parse(sessionStorage.getItem("userProfile")));
        } else {
          getUserProfile().then(result => {
            if (result) {
              let uData = {};
              uData.userId = result.userid;
              uData.userAnLocale = result.anlocale;
              uData.userSfLocale = result.sflocale;
              uData.userCurrency = result.money;
              uData.userLanguage = result.language;
              uData.userTimeZone = result.timezone;
              uData.userName = result.name;
              uData.userType = result.type;
              uData.userRole = result.role;
              uData.userProfileName = result.profilename;
              uData.userProfileId = result.profileid;
              uData.userAccountId = result.accountid;
              uData.userContactId = result.contactid;
              sessionStorage.setItem("userProfile", JSON.stringify(uData));
              resolve(uData);
            }
          });
        }
      });
    }

    fetchUserProfile() {
      this.getCachedUserProfile()
        .then(result => {
          if (result) {
            this.userProfile = result;
            this.setDefinition(this.data);
          }
        })
        .catch(error => {
          this.log("User Profile fetch error : ", error);
          this.userProfile = {};
          this.setDefinition(this.data);
        });
    }

    //async call
    async trackUsageAsync() {
      if (this.data.Id && !this._usageTracked && !this.isPreview) {
        let cardobj = getCardObjectFields(this.data);
        let key = this.data[cardobj.OmniUiCardKey];
        if (key) {
          let keyArr = key.split("/");
          trackUsage({
            componentName: keyArr[0],
            componentId: this.data.Id
          });
          this._usageTracked = true;
        }
      }
    }
    /**
     * Added as part of https://vlocity.atlassian.net/browse/CARD-4654
     * getInterpolatedChannelName: This function checks for merge fields in pubsub channel names and interpolates and registers them.
     * @param {*} channelName
     * @returns String
     */
    getInterpolatedChannelName(channelName, regex) {
      let dynamicName;
      dynamicName = channelName.replace(regex, (match, exp) => {
        if (exp && exp === "recordId") {
          return this._contextVariables?.recordId
            ? this._contextVariables.recordId
            : match;
        }
        return match;
      });
      return dynamicName;
    }

    _dynamicPubsubRegister = new Map();
    _dynamicPubsubsRegistered = false;
    /**
     * Added as part of https://vlocity.atlassian.net/browse/CARD-4654
     * registerDynamicPubSubs: This function registers pubsub with channel name having merge fields. This is only during preview.
     * @param {*} def
     * @returns void
     */
    registerDynamicPubSubs(def) {
      const regex = /\{([a-zA-Z.0-9_[\]]*)\}/g;
      const events = def?.events && [...def.events];
      if (events?.length) {
        events.forEach((event, index) => {
          let channelName;
          let dynamicFunc;
          if (event.channelname.match(regex)) {
            channelName = this.getInterpolatedChannelName(
              event.channelname,
              regex
            );
            dynamicFunc = {
              [event.eventname]: this.handleEventAction.bind(
                this,
                def.events[index],
                index
              )
            };
            this._dynamicPubsubRegister.set(channelName, dynamicFunc);
          }
        });
        if (this._dynamicPubsubRegister.size) {
          this._dynamicPubsubRegister.forEach((value, key) => {
            pubsub.register(key, value);
          });
          this._dynamicPubsubsRegistered = true;
        }
      }
    }

    _contextVariables;
    dataStr;
    setDefinition(_data, actionObj) {
      this.dataStr = this.dataStr
        ? this.dataStr
        : JSON.stringify({
            dataSource: _data.dataSource,
            states: _data.states,
            events: _data.events
          });
      //resetting all values support reload
      this._recordProcessed = false;
      //End
      this.dsAction = getActionDebugEventObj("Datasource", _data, actionObj);
      if (!this._unInterpolatedCardData && _data) {
        this._unInterpolatedCardData = _data;
      }
      let card = _data;
      this.data = _data;
      let requiredPermission = _data ? _data.requiredPermission : "";
      this.uniqueKey = this.data.uniqueKey;
      this.checkPermission(requiredPermission).then(hasPermission => {
        if (hasPermission) {
          let param = params();
          param.id = param.id || this.recordId;
          this.Params = param;
          this.isPreview =
            param.isPreview === true || param.isPreview === "true";
          this.trackUsageAsync(); //track card user, trigger once per load
          //setting merge fields
          this.setMergeFields(card);
          if (_data && _data.dataSource && _data.dataSource.type === "Custom") {
            this.updateActionDebugger(this.dsAction);
          }
          this.updateDebugPanel("Params", { ...param });
          if (this.isPreview) {
            if (this.data.states && this.data.states.length) {
              this.insideParent = this.data.states.some(state => {
                this.childCardCount = 0;
                return (
                  this.getChildCardsCountInsideParent(
                    state.components["layer-0"]
                  ) > 0
                );
              });
            }
            this.getCachedUserProfile()
              .then(result => {
                if (result) {
                  let userProfile = { ...result };
                  this.updateDebugPanel("User", userProfile);
                }
              })
              .catch(error => {
                this.log("User Profile fetch error : ", error);
              });
          }

          if (
            (this.dataStr.indexOf("User.") > -1 ||
              this.dataStr.indexOf("{User") > -1) &&
            !this.userProfile
          ) {
            this.fetchUserProfile();
            return;
          }
          if (!this.isPreview) {
            if (
              (this.dataStr.indexOf("Parent.") > -1 ||
                this.dataStr.indexOf("{Parent") > -1) &&
              !this._parent &&
              this._parentAttrbute
            ) {
              return;
            }
          }

          if (_data && _data.dataSource) {
            let theme = _data.theme === "nds" ? "newport" : "lightning";
            this.updateDebugPanel("title", _data.title);
            this.updateDebugPanel("theme", theme);
            this.updateDebugPanel("recordId", _data.Id);
            this.updateDebugPanel("dataSource.config", _data.dataSource);
          }

          if (
            this.isPreview &&
            _data &&
            _data.dataSource &&
            _data.dataSource.contextVariables
          ) {
            this.updateDebugPanel("Label", card.Label || {});
            this.getContextTestVariables().then(contextVar => {
              this._contextVariables = contextVar;
              this.updateDebugPanel(
                "TestParams",
                this.testParams || contextVar
              );
              if (this._parent) {
                this._parent = {
                  ...(contextVar.Parent || {}),
                  ...this._parent
                };
                contextVar.Parent = this._parent;
              }
              if (this.userProfile) {
                contextVar.User = this.userProfile;
              }
              if (!this._dynamicPubsubsRegistered)
                this.registerDynamicPubSubs(this.data);
              this.data = interpolateWithRegex(
                this.data,
                this._testParams || contextVar,
                this._regexPattern
              );
              this.setCardData();
            });
          } else {
            this.log("Card definition : ", this.data);
            //intialising card definition
            /*
              While interpolating we dont need to interpolate states array which mostly consists of elements and styles
              Also we dont have to interpolate Parent attribute as it already having interpolated values as those are being passed from parent
              TODO: Tested this with CPQ product, we have to test it with other Flexcard usecases as well
            */
            this.data = interpolateWithRegex(
              omit(this.data, ["states", "Parent"]),
              {
                Params: param || {},
                User: this.userProfile || {},
                recordId: this.recordId || "",
                objectApiName: this.objectApiName,
                Parent: this._parent || {},
                Session: this.session || {}
              },
              this._regexPattern
            );
            this.data.states = card.states;
            this.data.Parent = this._parent;
            this.setCardData();
          }
        } else {
          this.cardLoaded = true;
          this.updateActionDebugger(
            this.dsAction,
            "Error",
            "Permission Denied"
          );
        }
      });
    }

    setMergeFields(card) {
      let sessionVars = this.data && this.data.sessionVars;
      const sessionAvailable = card.Session && Object.keys(card.Session).length;
      if (sessionVars && !sessionAvailable) {
        sessionVars.forEach(field => {
          this.session[field.name] =
            typeof this._sessionApiVars[field.name] !== "undefined"
              ? this._sessionApiVars[field.name]
              : field.val;
        });
      }
      this.log("Card session variable : ", this.session);
      //interpolation data to elements
      if (sessionAvailable) {
        this.session = { ...card.Session };
      } else {
        card.Session = this.session;
      }
      this.updateDebugPanel("Session", { ...this.session });
      card.Params = this.Params;
      card.User = this.userProfile;
      card.recordId = this.recordId;
      card.objectApiName = this.objectApiName;
      card.Label = this.customLabels;
      card.Parent = this._parent;
      card.Flex = {}; // private variable to be used to update card context without rerendering unlike updating record object.
      this.card = { ...card };
      this._allMergeFields = extractCardMergeFields(card);
    }

    setCardData() {
      this.selectableField = this.data.selectableField;
      this.selectableMode = this.data.selectableMode;
      this.selectedCardsLabel = this.data.selectedCardsLabel
        ? this.data.selectedCardsLabel
        : "selectedcards";

      //check if the change in parentData used in datasource
      if (
        this._parent &&
        this._differnceInParent &&
        this._differnceInParent.length > 0 &&
        this._unInterpolatedCardData.dataSource
      ) {
        let datasourceStr = JSON.stringify(
          this._unInterpolatedCardData.dataSource
        );
        let hasContext;
        this._differnceInParent.every(propName => {
          if (datasourceStr.indexOf(`{Parent.${propName}}`) !== -1) {
            hasContext = true;
            return false;
          }
          return true;
        });
        if (!hasContext) {
          //do not update records as we dont use any Parent updated value on datasource
          this._recordProcessed = true;
          this.setStateObj();
          return;
        }
      }

      if (this.omniSupportKey) {
        let records = this.omniGetSaveState(this.omniSupportKey);
        if (records && records.length > 0) {
          this._records = records;
          this.isRecordLoaded = true;
          this._recordProcessed = false;
          this.updateKeys();
          this.setStateObj();
          this.updateActionDebugger(this.dsAction, "Success", records);
        } else {
          this.fetchData();
        }
      } else {
        this.fetchData();
      }

      if (this.data && this.data.metatagVars) this.evaluateMetatags();
      this.setAttribute(
        "class",
        `${this.getAttribute("class") ? this.getAttribute("class") : ""} ${
          this.data.theme === "nds" ? "via-nds" : "via-slds"
        }`
      );
      if (this.hasLayoutRecord && this.data && this.data.theme === "nds") {
        Promise.resolve().then(() => {
          this.cardLoaded = true;
        });
      }
    }
    fetchSelectedCards() {
      if (this.selectableMode && this.selectableField && this.card) {
        let cardsList = this.selectedCardsLabel || "selectedcards";
        this.card.selectableField = this.selectableField;
        this.card.selectedCardsLabel = cardsList;
        if (this.hasRecords) {
          this[cardsList] = this[cardsList] ? this[cardsList] : [];
          let selectedCardsArr = [];
          this._records.forEach(record => {
            if (
              record &&
              record[this.selectableField] &&
              (record[this.selectableField] === "true" ||
                record[this.selectableField] === true)
            ) {
              selectedCardsArr.push(record);
            }
          });

          if (!isEqual(selectedCardsArr, this[cardsList])) {
            this[cardsList] = [...selectedCardsArr];
            this.card[cardsList] = [...selectedCardsArr];
          }
        } else {
          this[cardsList] = [];
          this.card[cardsList] = [];
        }
      }
    }

    fetchData() {
      //if datasource is there then no need to handle records coming along as attributes
      if (
        !this.hasLayoutRecord &&
        !this._dataNode &&
        !this._parentData &&
        this.data &&
        this.data.dataSource &&
        this.data.dataSource.type
      ) {
        this.data.dataSource = datasourceParser(this.data.dataSource);
        let interval =
          this.data.dataSource.value && this.data.dataSource.value.interval;
        if (interval) {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          this.cardInterval = setInterval(() => {
            this.getRecords()
              .then(records => {
                this.updateDebugPanel("dataSource.records", records);
                if (this.dsAction && this.dsAction.obj && this.dsAction.type) {
                  this.updateActionDebugger(this.dsAction, "Success", records);
                }
              })
              .catch(e => {
                this.handleDataSourceError(e);
              });
          }, interval);
        }
        if (
          !this.data.dataSource.value ||
          !this.data.dataSource.value.dsDelay
        ) {
          this.getRecords()
            .then(records => {
              this.updateDebugPanel("dataSource.records", records);
              if (this.dsAction && this.dsAction.obj && this.dsAction.type) {
                this.updateActionDebugger(this.dsAction, "Success", records);
              }
            })
            .catch(e => {
              this.handleDataSourceError(e);
            });
        } else {
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            this.getRecords()
              .then(records => {
                this.updateDebugPanel("dataSource.records", records);
                if (this.dsAction && this.dsAction.obj && this.dsAction.type) {
                  this.updateActionDebugger(this.dsAction, "Success", records);
                }
              })
              .catch(e => {
                this.handleDataSourceError(e);
              });
          }, this.data.dataSource.value.dsDelay);
        }
        this.log("Fetching card data from datasource : ", this.data.dataSource);
      } else if (!this._dataNode && !this._parentData) {
        if (this._obj) {
          this.log("Setting card object directly : ", this._obj);
          this._records = [this._obj];
          this.pickRecords(this._records);
        }
        this.isRecordLoaded = true;
        this._recordProcessed = false;
        if (!this.hasLayoutRecord && this.data) {
          this.setStateObj();
        }
        if (this.dsAction && this.dsAction.obj && this.dsAction.type) {
          let records = this.hasRecords ? this._records : null;
          this.updateActionDebugger(this.dsAction, "Success", records);
        }
      } else if (
        (this.isPreview ||
          (this._dataNode && this.eventActionType === "reload")) &&
        this.hasLayoutRecord
      ) {
        this.setStateObj();
      }
    }

    get hasRecords() {
      return this.records && !isEmpty(this.records);
    }

    evaluateMetatags() {
      let metatagVars = this.data.metatagVars;
      metatagVars.forEach(metatag => {
        try {
          this.log("metatag ", metatag);
          //To make sure metatag with unique name only gets added once to header.
          let existingElem = document.head.querySelector(
            "meta[name='" + metatag.name + "'][data-custom='true']"
          );
          if (existingElem) {
            existingElem.parentNode.removeChild(existingElem);
          }
          let tag = document.createElement("meta");
          tag.name = metatag.name;
          tag.content = get(this._records, metatag.val) || metatag.val;
          tag.dataset.custom = true;
          document.head.appendChild(tag);
        } catch (e) {
          this.log("could not set ", metatag, e);
        }
      });
      this.log("metatag variables", metatagVars);
    }

    convertRecordsToArray() {
      if (this._records) {
        this.processRecords();
      }
      this._records = Array.isArray(this._records)
        ? this._records
        : [this._records];
    }

    getRecords() {
      return new Promise((resolve, reject) => {
        if (this.data.dataSource.type === "StreamingAPI") {
          this.channelName = this.data.dataSource.value.channel;
          let debugFlag =
            this.session.debugFlag && this.session.debugFlag !== "false"
              ? true
              : false;
          let replayId =
            this.data.dataSource.value.replayAll === "true" ? -2 : -1;
          subscribeEMP(
            this.channelName,
            replayId,
            response => {
              let record = Object.assign({}, response);
              if (this.data.dataSource.value.isReplace === "true") {
                this.streamingData = [];
                this.streamingData[0] = record;
              } else {
                this.streamingData = this.streamingData
                  ? this.streamingData
                  : [];
                this.streamingData.push(record);
              }
              this._records = this.streamingData;
              this.isRecordLoaded = true;
              this._recordProcessed = false;
              this.convertRecordsToArray();
              this.updateKeys();
              this.setStateObj();
              resolve(this._records);
            },
            debugFlag
          );
          this.subscribedStreamingApiList.push(this.channelName);
          //support blank state
          this._records = [];
          this.setStateObj();
        } else if (this.data.dataSource.type === "SDK") {
          this.savedConfiguration =
            this.data.dataSource.value &&
            this.data.dataSource.value.selectedSDKConfig;
          loadSDK(this, this.savedConfiguration)
            .then(sdkInstance => {
              if (sdkInstance) {
                invokeSDKMethod(this.data.dataSource, sdkInstance)
                  .then(sdkResponse => {
                    let record = Object.assign({}, sdkResponse);
                    this._records = record;
                    this.isRecordLoaded = true;
                    this._recordProcessed = false;
                    this.convertRecordsToArray();
                    this.updateKeys();
                    this.setStateObj();
                    resolve(this._records);
                  })
                  .catch(error => {
                    reject(error);
                  });
              }
            })
            .catch(error => {
              reject(error);
            });
          this._records = [];
          this.setStateObj();
        } else if (this.data.dataSource.type === "Custom") {
          Promise.resolve().then(() => {
            this._records = JSON.parse(this.data.dataSource.value.body);
            this.isRecordLoaded = true;
            this._recordProcessed = false;
            this.convertRecordsToArray();
            this.updateKeys();
            this.setStateObj();
          });
        } else if (
          this.data.dataSource &&
          (this.data.dataSource.type === "Query" ||
            this.data.dataSource.type === "Search") &&
          this.data[getCardObjectFields(this.data).OmniUiCardKey]
        ) {
          let jsonMap = null;
          if (
            this.data.dataSource.value &&
            this.data.dataSource.value.jsonMap
          ) {
            jsonMap = this.data.dataSource.value.jsonMap;
          }
          doEncryptedDatasourceFlex(
            this.data[getCardObjectFields(this.data).OmniUiCardKey],
            jsonMap,
            this.data.dataSource
          )
            .then(src => {
              this._records = typeof src === "string" ? JSON.parse(src) : src;
              this.isRecordLoaded = true;
              this._recordProcessed = false;
              resolve(this._records);
              this.convertRecordsToArray();
              this.updateKeys();
              this.setStateObj();
            })
            .catch(error => {
              reject(error);
              this.cardLoaded = true;
              this.hasError = true;
            });
        } else {
          getDataHandler(JSON.stringify(this.data.dataSource))
            .then(_data => {
              this.log("fetched records from datasource : ", _data);
              this.isRecordLoaded = true;
              if (this._records && isEqual(this._records, _data)) {
                return;
              }
              this._records =
                typeof _data === "string" ? JSON.parse(_data) : _data;
              if (
                this.data.dataSource.type.toLowerCase() ===
                "integrationprocedures"
              ) {
                if (this._records.error && this._records.error === "OK") {
                  this._records = this._records.IPResult;
                }
              }
              if (this.data.dataSource.type.toLowerCase() === "dataraptor") {
                this._records =
                  Array.isArray(this._records) && this._records.length === 1
                    ? Array.isArray(this._records[0])
                      ? this._records[0]
                      : [this._records[0]]
                    : this._records;
              }
              resolve(this._records);
              this.log("Picked card records after filter : ", this._records);
              this._recordProcessed = false;
              this.convertRecordsToArray();
              this.updateKeys();
              this.setStateObj();
            })
            .catch(error => {
              reject(error);
              this.cardLoaded = true;
              this.hasError = true;
            });
        }
      });
    }

    //Handeling orderBy on records
    processRecords() {
      if (this.data && this.data.dataSource) {
        let paths =
          this.data.dataSource.value && this.data.dataSource.value.resultVar;
        if (paths) {
          this.handleResultPath(paths);
        }
        this.setOrderBy();
        this.updateKeys();
        this._recordProcessed = true;
      }
    }

    //Update uniquekey
    updateKeys() {
      if (this.records) {
        if (Array.isArray(this.records)) {
          let cardRecord = [];
          this._records.forEach((record, i) => {
            if (record) {
              let uniqueVal =
                get(record, this.uniqueKey) ||
                get(record, this.parentUniquekey) ||
                "REC" + i;
              let obj = { ...record };
              obj.uniqueKey = uniqueVal;
              obj._flex = obj._flex ? { ...obj._flex } : {};
              obj._flex.uniqueKey = uniqueVal;
              if (this.cardStyles) {
                //This is to set initial visibilty to each element associated with each record
                //It remain false here, but as flex card loads based on condtion or no condition it makes it true one by one.
                Object.keys(this.cardStyles).forEach(styleId => {
                  if (typeof obj._flex[styleId] === "undefined") {
                    obj._flex[styleId] = false;
                    obj._flex[styleId + "_child"] = false;
                  }
                });
              }
              if (!obj.Id) obj.Id = uniqueVal;
              cardRecord.push(obj);
            }
          });
          this._records = cardRecord;
        } else {
          this._records.Id = this._records.Id || "REC0";
          this.records.uniqueKey = "REC0";
        }
        this.flexiPageWidthAware();
      }
    }

    //Handle result path
    handleResultPath(path) {
      this._records = get(this._records, path);
    }

    errorCallback(error) {
      this.log("Card load failure : ", error);
      this.error = error ? error : "This card has error.";
      this.showToast(this.error, ErrorToastTitle, "error");
      throw error;
    }

    pickRecords(records) {
      if (Array.isArray(records)) {
        let filteredCards = [];
        this._records.forEach((record, i) => {
          if (record) {
            let cardRecord = Object.assign(
              {
                Id: record.Id || "REC" + i
              },
              record
            );
            filteredCards.push(cardRecord);
          }
        });
        this._records = this.data ? filteredCards : this._records;
      }
    }
    renderedCallback() {
      if (this.isPreview && this.firstRender && !this.actionListener) {
        this.actionListener = true;
        this.template.addEventListener(
          "actionclick",
          this.updateActionDebugger
        );
      }
      if (this._records && this._records.length && this.firstRender) {
        this.firstRender = false;
        this.pickRecords(this._records);
        this.setStateObj();
      }
      let elements = this.template.querySelectorAll("*");
      if (
        this.data &&
        !this._isStateSelected &&
        elements.length > 0 &&
        this.isRecordLoaded
      ) {
        if (!this.isKeysUpdated) {
          this.isKeysUpdated = true;
          this.updateKeys();
        }
        this.setStateObj();
      }
      if (this._recordsUpdated) {
        this._recordsUpdated = false;
        this.setStateObj();
      }
    }

    // eslint-disable-next-line lwc/no-rest-parameter
    log(...args) {
      if (this.debug === "true" || this.debug === true) {
        Logger.log(...args);
      }
    }

    setStyleDefinition(styleDef) {
      this.cardStyles = styleDef;
    }

    handleCardStyleUpdate = event => {
      //If this method is triggered from flexCardState onslotchange event then it will be having a state element which we need to update
      //using that state only instead of looping through all states
      //When block onslotchange is executed we have to make sure we are not duplicating effort with state to apply runtime style or condition
      //TODO - figure a better way to check for block element
      if (event?.target?.tagName.toLowerCase().includes("-block")) {
        return;
      }
      if (event?.target?.classList.contains("cf-vlocity-state")) {
        let stateElement = event.target;
        this.handleStateElementStyle(stateElement);
      } else {
        //If this gets called from setStateObjectHandler then we need to update all the state hence iterating
        let stateElements = this.template.querySelectorAll(".cf-vlocity-state");
        if (stateElements && stateElements.length > 0) {
          stateElements = Array.from(stateElements);
          stateElements.forEach(stateElement => {
            this.handleStateElementStyle(stateElement);
          });
        }
      }
    };

    handleStateElementStyle(stateElement) {
      let record =
        (this.records && this.records[stateElement.dataset?.rindex || "0"]) ||
        {};
      let mergeFields = this._allMergeFields || {};
      mergeFields.Flex = mergeFields.Flex || {};
      mergeFields.Flex.index = stateElement.dataset?.rindex || "0";
      let mergeFieldAndRecord = { ...mergeFields, ...record };
      //If this card is having style definition then only we have to update dynamic style
      if (this.cardStyles && Object.keys(this.cardStyles).length > 0) {
        this.handleStateElementStyleAndConditions(
          stateElement,
          mergeFieldAndRecord
        );
      } else {
        //For 230 or prior flex cards where dynamic styling is not there we just have to check conditions
        let conditionalElements = stateElement.querySelectorAll(
          ".condition-element"
        );
        if (conditionalElements && conditionalElements.length > 0) {
          conditionalElements = Array.from(conditionalElements);
          conditionalElements.forEach(element => {
            this.handleConditionalElements(element, mergeFieldAndRecord);
          });
        }
      }
    }

    handleStateElementStyleAndConditions(stateElement, mergeFieldAndRecord) {
      Object.keys(this.cardStyles).forEach(key => {
        if (stateElement.querySelector('[data-style-id="' + key + '"]')) {
          let element = stateElement.querySelector(
            '[data-style-id="' + key + '"]'
          );
          let elementChild = stateElement.querySelector(
            '[data-style-id="' + key + '_child"]'
          );
          let stylesApplied = false;
          let defaultStyle = this.cardStyles[key][0];
          this.cardStyles[key].forEach(style => {
            let satisfyCondition;
            if (style.conditions !== "default") {
              if (style.conditions.group) {
                satisfyCondition = groupFilter(
                  style.conditions.group,
                  mergeFieldAndRecord,
                  this
                );
              }
              if (satisfyCondition && !stylesApplied) {
                stylesApplied = true;
                defaultStyle = style;
              } else {
                //Removing stateElement specific style if condition doesnt meet
                if (style.styleObject.styleProperties) {
                  Object.keys(style.styleObject.styleProperties).forEach(
                    property => {
                      if (elementChild) {
                        elementChild[property] = "";
                      }
                    }
                  );
                }
              }
            }
          });
          if (defaultStyle) {
            //setting styles to stateElements
            element.classList.value = defaultStyle.styleObject.class;
            element.style = defaultStyle.styleObject.style;
            //stateElement specific style properties
            if (defaultStyle.styleObject.styleProperties) {
              Object.keys(defaultStyle.styleObject.styleProperties).forEach(
                property => {
                  if (elementChild) {
                    elementChild[property] =
                      defaultStyle.styleObject.styleProperties[property];
                  }
                }
              );
            }
          }

          // checking element conditions to show / hide accordingly
          this.handleConditionalElements(element, mergeFieldAndRecord);
        }
      });
    }

    handleConditionalElements(element, mergeFieldAndRecord) {
      let theme = (this.card && this.card.theme) || "slds";
      // checking element conditions to show / hide accordingly
      if (element.classList.contains("condition-element")) {
        let conditions = element.dataset && element.dataset.conditions;
        let flexElement = element.querySelectorAll("*[data-conditions]")[0];
        conditions =
          (flexElement &&
            flexElement.dataset &&
            flexElement.dataset.conditions) ||
          conditions;
        if (conditions) {
          conditions =
            typeof conditions === "string"
              ? conditions.indexOf("\\") === 0
                ? JSON.parse(conditions.substring(1))
                : JSON.parse(conditions)
              : conditions;
          let renderConditionalElement = true;
          if (conditions && conditions.group && conditions.group.length > 0) {
            renderConditionalElement = groupFilter(
              conditions.group,
              mergeFieldAndRecord,
              element
            );
          }

          //Making sure if element condition is handled using if:true relevant attribute inside _flex should also be udpated.
          if (this._records && this._records.length > 0) {
            this._records[element.dataset.rindex || "0"]._flex[
              element.dataset.styleId
            ] =
              this._records[element.dataset.rindex || "0"]._flex[
                element.dataset.styleId
              ] || renderConditionalElement;
            this._records[element.dataset.rindex || "0"]._flex[
              element.dataset.styleId + "_child"
            ] =
              this._records[element.dataset.rindex || "0"]._flex[
                element.dataset.styleId + "_child"
              ] || renderConditionalElement;
          }

          if (!renderConditionalElement) {
            if (element.classList) {
              if (!element.classList.contains(`${this.theme}-hide`)) {
                element.classList.add(`${theme}-hide`);
              }
            } else {
              element.setAttribute("class", `${theme}-hide`);
            }
          } else {
            if (element.classList) {
              element.classList.remove(`${theme}-hide`);
            }
          }
        }
      } else {
        //If there are no condition to element then relevant attribute inside _flex should be true (as needs to be initially loaded)
        if (this._records && this._records.length > 0) {
          this._records[element.dataset.rindex || "0"]._flex[
            element.dataset.styleId
          ] = true;
          this._records[element.dataset.rindex || "0"]._flex[
            element.dataset.styleId + "_child"
          ] = true;
        }
      }
    }

    setStateObj() {
      if (this.data) {
        this.checkPermission(this.data.requiredPermission).then(
          hasPermission => {
            if (hasPermission) {
              this.setStateObjectHandler();
            } else {
              this.cardLoaded = true;
            }
          }
        );
      } else {
        this.setStateObjectHandler();
      }
    }
    //setting card records.
    setStateObjectHandler() {
      if (!this._recordProcessed && this.hasRecords) {
        this.processRecords();
        this._records = Array.isArray(this._records)
          ? this._records
          : [this._records];
        if (!this.hasLayoutRecord) {
          //applicable only for card DS as filter should happen after we processRecord as parsing of resultVar happens there
          this.pickRecords(this._records);
        }
      }
      this.fetchSelectedCards();
      if (this.data && this.data.states) {
        let elements = this.template.querySelectorAll(`.cf-vlocity-state`);
        if (elements && elements.length > 0) {
          elements = Array.from(elements);
          let hasActiveState = false;
          this.data.states.forEach(item => {
            if (
              item.conditions &&
              item.conditions.group &&
              item.conditions.group.length > 0
            ) {
              if (this.hasRecords) {
                this.records.forEach(record => {
                  if (groupFilter(item.conditions.group, record, this)) {
                    if (!item.blankCardState) {
                      hasActiveState = true;
                    }
                  }
                });
              }
            } else {
              if (!item.blankCardState && this.hasRecords) {
                hasActiveState = true;
              }
            }
          });

          let selectedState = false;
          let stopExecution = false;
          elements.forEach(element => {
            if (stopExecution) {
              return;
            }
            let stateIndex = parseInt(element.dataset.index, 10);
            this._allMergeFields.Flex.index = element.dataset?.rindex || 0;
            let state = this.data.states[stateIndex];
            let obj = element.record ? element.record : {};
            let isFirstState = stateIndex === 0;
            if (isFirstState) {
              selectedState = false;
            }
            if (!selectedState) {
              if (this.data.title) {
                state.title = this.data.title;
              }
              let satisfyCondition = false;

              if (
                state.conditions &&
                state.conditions.group &&
                state.conditions.group.length > 0
              ) {
                satisfyCondition = groupFilter(
                  state.conditions.group,
                  { ...this._allMergeFields, ...obj },
                  this
                );
              } else {
                satisfyCondition = true;
              }

              if (satisfyCondition) {
                if (state.blankCardState && hasActiveState) {
                  //when we have Active state blankstate should be always false
                  selectedState = false;
                } else if (state.blankCardState && !hasActiveState) {
                  //when no active state show only one blank card
                  selectedState = true;
                  stopExecution = true;
                } else {
                  selectedState = true;
                }
                if (!state.blankCardState) {
                  //when no records active state will be false
                  if (!this.hasRecords && this.data.dataSource.type) {
                    selectedState = false;
                  }
                  if (this.data.dataSource && !this.data.dataSource.type) {
                    selectedState = true;
                  }
                }
              } else {
                selectedState = false; //if condition is not satisfied do not show any state
              }

              element.selectedState = selectedState;
              this._isStateSelected = true;
              let sessionInter = interpolateWithRegex(
                this.session,
                {
                  Params: this.Params,
                  obj: obj
                },
                this._regexPattern
              );
              element.session = sessionInter;
              if (this.orgNsPrefix) element.orgNsPrefix = this.orgNsPrefix;
              element.card = this.data;
              element.cardObj = this.card;
              element.userProfile = this.userProfile;
              element.debug = this.debug;
              element.state = state;
            } else {
              element.selectedState = false;
            }
            element.classList.toggle(
              `${this.data.theme}-hide`,
              !element.selectedState
            );
          });
          this.createCardsArray(elements);
          Promise.resolve().then(() => {
            if (!this._oaObj.ReadyTime) this.setOaObj("Card Load", elements);
          });
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            this.cardLoaded = true;
          }, 0);
          this.handleCardStyleUpdate();
        } else {
          this.createCardsArray(null);
          // eslint-disable-next-line @lwc/lwc/no-async-operation
          setTimeout(() => {
            this.cardLoaded = true;
          }, 0);
          this.handleCardStyleUpdate();
        }
      }
    }

    setOaObj(eventName) {
      this.isChildCardTrackingEnabled =
        this.isChildCardTrackingEnabled === true ||
        this.isChildCardTrackingEnabled === "true";

      if (this.isPreview) return;
      if (!this.card) {
        return;
      }
      let cardobj = getCardObjectFields(this.card);
      if (
        !this.card ||
        !this.card.Id ||
        ((("IsChildCard" in cardobj && this.card[cardobj.IsChildCard]) ||
          (this.card[cardobj.Type] &&
            this.card[cardobj.Type].toLowerCase() === "child")) &&
          !(
            this.trackingObj &&
            this.trackingObj.parentCardId &&
            this.trackingObj.parentCardGlobalKey &&
            this.trackingObj.parentCardInstanceIdentifier &&
            this.trackingObj.containerId &&
            this.trackingObj.containerGlobalKey &&
            this.trackingObj.containerInstanceIdentifier
          ))
      )
        return;

      if (this._oaObj.StartTime && !this._oaObj.ComponentId) {
        this._oaObj.ActionContainerComponent = "Card";
        this._oaObj.ActionElementType = "FlexCards";
        this._oaObj.TrackingCategory = "UI";
        this._oaObj.RequestUrl = window.location.href;

        let instanceIdentifier = `${
          this.card[cardobj.OmniUiCardKey]
        }/${Date.now()}${Math.floor(Math.random() * 1000)}`;

        if (
          (this.card[cardobj.Type] &&
            this.card[cardobj.Type].toLowerCase() === "child") ||
          this.card[cardobj.IsChildCard]
        ) {
          this._oaObj.ComponentId = this.trackingObj.containerId;
          this._oaObj.ActionContainerGlobalKey = this.trackingObj.containerGlobalKey;
          this._oaObj.InstanceIdentifier = this.trackingObj.containerInstanceIdentifier;

          // -- Custom/Data__c Fields
          this._oaObj.CardId = this.card.Id;
          this._oaObj.CardGlobalKey = this.card[cardobj.OmniUiCardKey];
          this._oaObj.CardInstanceIdentifier = instanceIdentifier;
          this._oaObj.ParentCardId = this.trackingObj.parentCardId;
          this._oaObj.ParentCardGlobalKey = this.trackingObj.parentCardGlobalKey;
          this._oaObj.ParentCardInstanceIdentifier = this.trackingObj.parentCardInstanceIdentifier;
        } else {
          this._oaObj.ComponentId = this.card.Id;
          this._oaObj.ActionContainerGlobalKey = this.card[
            cardobj.OmniUiCardKey
          ];
          this._oaObj.InstanceIdentifier = instanceIdentifier;
          this._oaObj.ActionContainerTitle = this.card.title;
        }

        this._oaObj.ActionContainerId = this._oaObj.ComponentId;
        if (this._oaObj.ActionContainerGlobalKey) {
          let cardIdParts = this._oaObj.ActionContainerGlobalKey.split("/");
          this._oaObj.ActionContainerName = cardIdParts[0];
          this._oaObj.ActionContainerAuthor = cardIdParts[1];
          this._oaObj.ActionContainerVersion = cardIdParts[2];
        }

        if (this.card.tracking) {
          if (this.card.tracking.businessEvent) {
            this.trackBusinessEvent = this.card.tracking.businessEvent;
            let businessEvent = this.interpolateValue(
              this.card.tracking.businessEvent
            );
            if (businessEvent) this._oaObj.BusinessEvent = businessEvent;
          }
          if (this.card.tracking.businessCategory) {
            this.trackBusinessCategory = this.card.tracking.businessCategory;
            let businessCategory = this.interpolateValue(
              this.card.tracking.businessCategory
            );
            if (businessCategory)
              this._oaObj.BusinessCategory = businessCategory;
          }
          if (this.card.tracking.customFields) {
            let customFields = this.card.tracking.customFields;
            customFields.forEach(customField => {
              let fieldValue = this.interpolateValue(customField.val);
              if (fieldValue) this._oaObj[customField.name] = fieldValue;
            });
          }
        }
      }

      let isChild =
        (this.card[cardobj.Type] &&
          this.card[cardobj.Type].toLowerCase() === "child") ||
        this.card[cardobj.IsChildCard];
      let isTrackingEnabled =
        !isChild ||
        (isChild &&
          this.isChildCardTrackingEnabled &&
          this.trackingObj.isParentCardTrackingEnabled);

      this.setChildCardTrackingObj(isTrackingEnabled);

      if (eventName === "Card Load" && !this._oaObj.ReadyTime) {
        this._oaObj.Name = eventName;
        this._oaObj.ReadyTime = Date.now();
        this._oaObj.LoadDuration =
          this._oaObj.ReadyTime - this._oaObj.StartTime;
        if (isTrackingEnabled) vtag.track(eventName, this._oaObj);
      } else if (eventName === "Card Unload" && !this._oaObj.UnloadTime) {
        this._oaObj.Name = eventName;
        this._oaObj.UnloadTime = Date.now();
        this._oaObj.ElapsedTime =
          this._oaObj.UnloadTime - this._oaObj.ReadyTime;
        delete this._oaObj.StartTime;
        delete this._oaObj.ReadyTime;
        delete this._oaObj.LoadDuration;
        if (isTrackingEnabled) vtag.track(eventName, this._oaObj);
      }
    }

    setChildCardTrackingObj(isTrackingEnabled) {
      let cardobj = getCardObjectFields(this.card);
      this._childCardTrackingObj = {
        isParentCardTrackingEnabled: isTrackingEnabled,
        parentCardId: this.card.Id,
        parentCardGlobalKey: this.card[cardobj.OmniUiCardKey],
        parentCardInstanceIdentifier:
          (this.card[cardobj.Type] &&
            this.card[cardobj.Type].toLowerCase() === "child") ||
          this.card[cardobj.IsChildCard]
            ? this._oaObj.CardInstanceIdentifier
            : this._oaObj.InstanceIdentifier,
        containerId:
          this.trackingObj && this.trackingObj.containerId
            ? this.trackingObj.containerId
            : this.card.Id,
        containerGlobalKey:
          this.trackingObj && this.trackingObj.containerGlobalKey
            ? this.trackingObj.containerGlobalKey
            : this.card[cardobj.OmniUiCardKey],
        containerInstanceIdentifier:
          this.trackingObj && this.trackingObj.containerInstanceIdentifier
            ? this.trackingObj.containerInstanceIdentifier
            : this._oaObj.InstanceIdentifier
      };
    }
    //if record is undefined, it works as it was working before.
    interpolateValue(val, record) {
      if (typeof val === "string" && val.indexOf("{") !== -1) {
        let stringToInterpolate = val;
        stringToInterpolate = stringToInterpolate.replace(
          /\{(.*?)\}/g,
          (match, expr) => {
            let fieldValue = this.getInterpolatedValueForExpression(
              record,
              expr
            );
            //If its an object it will make it [Object object] otherwise
            return typeof fieldValue !== "undefined"
              ? typeof fieldValue === "object" && fieldValue !== null
                ? match
                : fieldValue
              : "";
          }
        );
        //if while interpolation we found out that field value is an object and we dont want to replace it with [Object object]
        // we match it and try again and return object value this time
        if (stringToInterpolate.match(/\{(.*?)\}/)) {
          let fieldValue = this.getInterpolatedValueForExpression(
            record,
            stringToInterpolate.match(/\{(.*?)\}/)[1]
          );
          return fieldValue;
        }
        //otherwise return string that we generated first
        return stringToInterpolate;
      }
      return val;
    }

    getInterpolatedValueForExpression(record, expr) {
      let fieldValue = get(record, expr);
      if (
        this._allMergeFields &&
        (typeof fieldValue === "undefined" ||
          fieldValue === null ||
          (fieldValue &&
            typeof fieldValue === "string" &&
            fieldValue.indexOf("{") !== -1))
      ) {
        fieldValue = get(this._allMergeFields, expr);
      }
      return fieldValue;
    }

    //Handeling orderBy on records
    setOrderBy() {
      if (this.data?.dataSource?.orderBy?.name) {
        let orderedBy = this.data.dataSource && this.data.dataSource.orderBy;
        let isReverse =
          orderedBy.isReverse === "true" || orderedBy.isReverse === true
            ? "desc"
            : "asc";
        if (Array.isArray(this._records)) {
          this.log("Setting card records order by ", orderedBy);
          this._records = orderBy(this._records, orderedBy.name, isReverse);
        }
      }
    }

    getContextTestVariables() {
      return new Promise(resolve => {
        getCardDataById(this.data.Id).then(result => {
          const datasourceData = result[
            getCardObjectFields(this.data).DataSourceConfig
          ]
            ? JSON.parse(
                result[getCardObjectFields(this.data).DataSourceConfig]
              )
            : result[getCardObjectFields(this.data).DataSourceConfig];
          let contextVar = {};
          datasourceData.contextVariables.forEach(contextVariable => {
            set(contextVar, contextVariable.name, contextVariable.val);
          });
          if (this.card && this.card.dataSource) {
            this.card.dataSource.contextVariables = datasourceData.contextVariables
              ? datasourceData.contextVariables
              : [];
          }
          resolve(contextVar);
        });
      });
    }
    checkPermission(requiredPermission) {
      if (this._requiredPermissionPromise) {
        return this._requiredPermissionPromise;
      }
      this._requiredPermissionPromise = new Promise(resolve => {
        if (requiredPermission) {
          checkPermission({
            permissions: requiredPermission
          })
            .then(hasPermission => {
              this.hasPermission = hasPermission;
              resolve(hasPermission);
            })
            .catch(error => {
              this.hasPermission = false;
              resolve(error);
            });
        } else {
          resolve(true);
        }
      });
      return this._requiredPermissionPromise;
    }

    validObj = (str, type) => {
      try {
        if (str.charAt(0) === "\\") {
          str = str.substring(1);
        }
        return JSON.parse(str);
      } catch (e) {
        return type === "array" ? [] : {};
      }
    };

    getStateIndex(data) {
      let elementClass = data?.currentTarget?.classList;
      let isElementAction =
        this.elementIndex >= 0 &&
        elementClass &&
        (elementClass.contains("execute-action") ||
          elementClass.contains("action-trigger"));
      let stateElement =
        !isElementAction &&
        this.hasRecords &&
        data.currentTarget?.closest(".cf-vlocity-state")
          ? data.currentTarget.closest(".cf-vlocity-state")
          : null;
      let index =
        stateElement &&
        stateElement.dataset &&
        typeof stateElement.dataset.rindex !== "undefined"
          ? stateElement.dataset.rindex
          : this.elementIndex >= 0
          ? this.elementIndex
          : null;
      return index;
    }

    //Update value of the field bound to input element
    updateFieldBinding(data) {
      if (data?.detail?.element && data.detail.fieldValues) {
        const elm = data.detail.element.currentTarget || data.detail.element;
        data.detail.fieldValues = interpolateElement(
          data.detail.fieldValues,
          elm
        );
        let index = this.getStateIndex(data.detail.element);
        if (index === null) {
          const stateElm =
            data.target && data.target.closest(".cf-vlocity-state");
          index = stateElm?.dataset?.rindex;
        }
        this.rerenderState(data.detail.fieldValues, index, false, data);
        data.stopPropagation();
      }
    }

    updateAction(data) {
      let index = this.getStateIndex(data);
      this.rerenderState(data.detail.fieldValues, index, false, data);
    }

    rerenderState(fields, index, selectSingleCard, data) {
      let setValueObj;
      let obj = {
        fields: fields,
        single: selectSingleCard,
        card: { ...this.card },
        selectableField: this.selectableField,
        data: { ...this.data }
      };
      if (this.hasLayoutRecord && this._dataNode === "{records}") {
        setValueObj = setValueOfRecords(this._records, index, obj, "childcard");
        if (setValueObj.parentData) {
          this.updatedChildCardRecords = { ...setValueObj.parentData };
          let event = new CustomEvent("updateparent", {
            bubbles: false,
            composed: false,
            detail: setValueObj.parentData
          });
          this.dispatchEvent(event);
        }
      } else {
        setValueObj = {
          ...setValueOfRecords(this._records, index, obj)
        };
      }
      if (setValueObj) {
        if (setValueObj.records) {
          this._records = setValueObj.records;
          this.pickRecords(this._records);
          this.updateKeys();
        }
        if (setValueObj.card) {
          this.card = setValueObj.card;
          this._allMergeFields = extractCardMergeFields(this.card);
        }
        if (setValueObj.data) {
          this.data = setValueObj.data;
        }
        this.setStateObj();
      }
      if (data) {
        let actionEvtObj = getActionDebugEventObj(
          "Set Value",
          fields,
          this._records,
          data
        );
        this.updateActionDebugger(actionEvtObj);
        this.updateJSONDebugger(data);
      }
    }

    updateJSONDebugger(eventData) {
      if (!this.isPreview) return;
      if (
        eventData.detail &&
        eventData.detail.fieldValues &&
        eventData.detail.fieldValues.length
      ) {
        let mergeFields = ["Params.", "User.", "Session."];
        eventData.detail.fieldValues.forEach(field => {
          let updateMergeFields = mergeFields.some(str => {
            return field.fieldName.includes(str);
          });
          if (updateMergeFields) {
            set(this.debugJSONData, field.fieldName, field.fieldValue);
          }
        });
        this.updateDebugPanel("FullJSON", this.debugJSONData);
      }
    }

    updateSelectedCards(event) {
      let index = this.getStateIndex(event);
      let isSelected = event.detail.value;
      let _fieldName = this.selectableField
        ? this.selectableField
        : "_flex.isSelected";
      if (isSelected === null && this._records && this._records[index]) {
        let fieldVal = get(this._records[index], _fieldName);
        isSelected = !(fieldVal === "true" || fieldVal === true);
      }
      let selectedCardInfo = {
        index: index,
        value: isSelected,
        fieldName: _fieldName
      };
      this.setSelectedCards(selectedCardInfo);
      let cardsList = this.selectedCardsLabel;
      let actionEvtObj = getActionDebugEventObj(
        "Select Cards",
        cardsList,
        this[cardsList],
        event.detail
      );
      this.updateActionDebugger(actionEvtObj);
    }

    setSelectedCards(card) {
      let selectSingleCard = this.selectableMode === "Single";
      let cardsList = this.selectedCardsLabel;
      this[cardsList] = this[cardsList] ? this[cardsList] : [];

      let fieldObj = [
        {
          fieldName: card.fieldName,
          fieldValue: card.value
        }
      ];
      if (card.fieldName === "_flex.isSelected") {
        let obj = {
          fieldName: "Flex.isSelected",
          fieldValue: card.value
        };
        fieldObj.push(obj);
      }
      this.rerenderState(fieldObj, card.index, selectSingleCard);
      let record;
      if (
        this.hasLayoutRecord &&
        this._dataNode === "{records}" &&
        this.updatedChildCardRecords
      ) {
        let data = { ...this.updatedChildCardRecords };
        if (data.records) {
          let cardRecords = data.records;
          record = { ...cardRecords[card.index] };
        } else if (data.record) {
          record = { ...data.record };
        }
      } else {
        record = { ...this._records[card.index] };
      }
      if (record) {
        if (selectSingleCard && card.value === true) {
          this[cardsList] = [];
        }
        let cardIndex = this[cardsList].findIndex(
          rec => rec._flex && rec._flex.uniqueKey === record._flex.uniqueKey
        );
        if (card.value === true && cardIndex === -1) {
          this[cardsList].push(record);
        } else if (cardIndex >= 0) {
          this[cardsList].splice(cardIndex, 1);
        }
        let cardObj = { ...this.card };
        cardObj[cardsList] = [...this[cardsList]];
        cardObj.selectedCardsLabel = cardsList;
        this.card = { ...cardObj };
      }
    }

    setValueOnToggle(event) {
      let index = this.getStateIndex(event);
      let key =
        event.currentTarget.type === "checkbox" ||
        event.currentTarget.type === "button"
          ? "value"
          : "checked";
      let fieldObj = [
        {
          fieldName: event.currentTarget.dataset.fieldname,
          fieldValue: event.currentTarget[key]
        }
      ];
      this.rerenderState(fieldObj, index);
    }

    updateParentData(event) {
      event.stopPropagation();
      let eventDetail = event.detail;
      if ((eventDetail.record && eventDetail.index) || eventDetail.records) {
        if (eventDetail.records) {
          this._records = cloneDeep(eventDetail.records);
        } else {
          this._records[eventDetail.index] = eventDetail.record;
        }
        this.pickRecords(this._records);
        this.updateKeys();
        this.setStateObj();
      }
    }

    updateOmniscript(event) {
      let data = {
        Params: this.Params,
        User: this.userProfile,
        recordId: this.recordId,
        objectApiName: this.objectApiName,
        records: this._records,
        Session: this.session
      };
      if (this.selectedCardsLabel && this[this.selectedCardsLabel]) {
        data[this.selectedCardsLabel] = this[this.selectedCardsLabel];
      }
      event.stopPropagation();
      let eventDetail = event.detail;
      const eventName = "omniaggregate";
      eventDetail.data = interpolateKeyValue(eventDetail.data, data);
      const osUpdateEvent = new CustomEvent(eventName, {
        bubbles: true,
        cancelable: true,
        composed: true,
        detail: eventDetail
      });
      this.dispatchEvent(osUpdateEvent);
    }

    getCommunityPrefix() {
      return new Promise((resolve, reject) => {
        if (this.pendingCommunityPromise) {
          this.pendingCommunityPromise
            .then(() => {
              resolve(this.fetchPrefix());
            })
            .catch(e => {
              console.error("Error in fetching page type :" + e);
              reject(e);
            });
        } else {
          resolve(this.fetchPrefix());
        }
      });
    }
    fetchPrefix() {
      if (/livepreview/.test(window.location.host)) {
        return "/sfsites/c";
      }
      if (this.isCommunity) {
        return window.location.pathname.split("/s/")[0];
      }
      return "";
    }

    createCardsArray(elements) {
      if (!this.isPreview) return;
      let cardsArray = createCardsArrayForDebugJSONPanel(
        elements,
        this._allMergeFields
      );
      this.updateDebugPanel("cards", cardsArray);
    }

    updateDebugPanel(key, data, origin = "*") {
      if (!this.isPreview) return;
      if (this.isPreview && !this.isInsideParent && !this.isRecursive) {
        if (
          key !== "FullJSON" &&
          JSON.stringify(get(this.debugJSONData, key)) !== JSON.stringify(data)
        ) {
          set(this.debugJSONData, key, data);
          if (this._isInsideIframe)
            postMessage("cardatajson", key, data, origin);
        } else if (key === "FullJSON") {
          if (this._isInsideIframe)
            postMessage("cardatajson", key, data, origin);
        }
      }
    }

    getChildCardsCountInsideParent(obj) {
      let children = obj && obj.children;
      if (children && children.length) {
        children.forEach(child => {
          if (child.children) this.getChildCardsCountInsideParent(child);
          else {
            if (child.element === "childCardPreview") this.childCardCount++;
          }
        });
      }
      return this.childCardCount;
    }

    flexiPageWidthAware() {
      let ele = this.template.querySelector(".containersize");
      if (ele) {
        ele.classList.remove(
          "flexcards-container_small",
          "flexcards-container_medium",
          "flexcards-container_large"
        );
        if (ele.offsetWidth <= 480) {
          ele.classList.add("flexcards-container_small");
        } else if (ele.offsetWidth <= 768) {
          ele.classList.add("flexcards-container_medium");
        } else {
          ele.classList.add("flexcards-container_large");
        }
      }
    }

    fireMultipleActionRecursively(
      eventObj,
      actionIndex,
      previousResponse,
      eventIndex,
      event,
      stateIndex,
      data
    ) {
      if (this.initialEvent) {
        this.initialEvent = false;
        this.fireEvtListenerActions(
          eventObj,
          actionIndex,
          previousResponse,
          eventIndex,
          event,
          stateIndex,
          data
        );
      } else {
        setTimeout(() => {
          this.fireEvtListenerActions(
            eventObj,
            actionIndex,
            previousResponse,
            eventIndex,
            event,
            stateIndex,
            data
          );
        }, 0);
      }
    }

    fireEvtListenerActions(
      eventObj,
      actionIndex,
      previousResponse,
      eventIndex,
      event,
      stateIndex,
      data
    ) {
      if (actionIndex < eventObj.actionList.length) {
        eventObj.actionData = eventObj.actionList[actionIndex];
        const actionEventParams =
          eventObj.eventtype === "event" ? event.detail : event;
        const actionCallerObj = this.createActionCallerObject(
          eventObj,
          event,
          actionEventParams,
          stateIndex,
          data
        );
        // This boolean [fireAction] will be used to determine if the action should be executed or not.
        const fireAction = this.evaluateActionConditions(actionCallerObj);
        if (fireAction) {
          this.setActionInstance(
            eventObj,
            actionEventParams,
            eventIndex,
            actionIndex
          );
          const actionElement = this.template.querySelector(".action-trigger");
          if (actionElement) {
            actionElement
              .executeAction(actionCallerObj, this.card)
              .then(result => {
                this.fireEvtListenerActions(
                  eventObj,
                  actionIndex + 1,
                  result,
                  eventIndex,
                  event,
                  stateIndex,
                  data
                );
              })
              .catch(error => {
                console.error("Action Errored", error?.toString());
                console.error("Stack Trace", error?.stack);
                const errorEvent = {
                  detail: {
                    title: "Action Errored",
                    stackTrace: error?.stack
                  }
                };
                this.updateActionDebugger(
                  errorEvent,
                  "Error",
                  error?.toString()
                );
              });
          }
        } else {
          //If previous action condition is not satisfied, then fire next available action
          this.fireEvtListenerActions(
            eventObj,
            actionIndex + 1,
            null,
            eventIndex,
            event,
            stateIndex,
            data
          );
        }
      }
    }

    createActionCallerObject(
      eventObj,
      event,
      actionEventParams,
      stateIndex,
      data
    ) {
      eventObj = interpolateWithRegex(
        eventObj,
        { action: actionEventParams },
        this._regexPattern
      );
      if (eventObj.actionData) {
        let actionDetails = eventObj.actionData.stateAction;
        let isUpdateDSAction =
          actionDetails &&
          actionDetails.type === "cardAction" &&
          actionDetails.eventName === "updatedatasource" &&
          actionDetails.message;
        if (isUpdateDSAction) {
          eventObj.actionData.stateAction.message = JSON.parse(
            actionDetails.message
          );
        }
        eventObj.actionData = interpolateKeyValue(eventObj.actionData, {
          action: actionEventParams,
          records: this.records
        });
        if (isUpdateDSAction) {
          eventObj.actionData.stateAction.message = JSON.stringify(
            eventObj.actionData.stateAction.message
          );
        }
      }
      const actionCallerObj = {
        currentTarget: {
          action: eventObj
        }
      };
      this.elementIndex = 0;
      if (typeof eventObj.recordIndex !== "undefined") {
        this.elementIndex = parseInt(eventObj.recordIndex, 10);
      }
      if (eventObj.eventtype === "event") {
        this.elementIndex = stateIndex;
        actionCallerObj.currentTarget.action.recordIndex = this.elementIndex;
        event.stopPropagation();
      }
      const actionData = { action: event };
      const sessionVar = {};
      if (data && data.sessionVars) {
        data.sessionVars.forEach(field => {
          sessionVar[field.name] = field.val;
        });
      }
      const sessionVars = { Session: sessionVar };
      if (this.records && this.records.length > 0) {
        actionCallerObj.currentTarget.record = this.records[this.elementIndex];
        this.record = {
          ...this.records[this.elementIndex],
          ...actionData,
          ...sessionVars,
          ...{ Parent: data.Parent },
          ...{ User: data.User }
        };
      } else {
        this.record = {
          ...actionData,
          ...sessionVars,
          ...{ Parent: data.Parent },
          ...{ User: data.User }
        };
      }
      return actionCallerObj;
    }

    evaluateActionConditions(actionCallerObj) {
      let fireAction = true;
      const recordObj = actionCallerObj?.currentTarget?.record;
      const mergeFields = { ...this._allMergeFields, ...recordObj };
      let conditionsGroup =
        actionCallerObj?.currentTarget?.action?.actionData?.stateAction
          ?.actionConditions?.group;
      if (conditionsGroup && conditionsGroup.length > 0) {
        conditionsGroup = interpolateWithRegex(
          conditionsGroup,
          mergeFields,
          this._regexPattern
        );
        fireAction = groupFilter(conditionsGroup, mergeFields);
      }
      return fireAction;
    }

    setActionInstance(eventObj, actionEventParams, eventIndex, actionIndex) {
      if (eventObj?.actionData?.stateAction?.type === "Flyout") {
        this.action = {};
      }
      if (actionEventParams) {
        this.action = { ...this.action, ...actionEventParams };
      }
      this.action["listener" + eventIndex + "action" + actionIndex] =
        actionEventParams || true;
    }
  };
