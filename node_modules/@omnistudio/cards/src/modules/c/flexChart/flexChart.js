/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import Chart from "c/chart";
import { BaseFlexElementMixin } from "c/baseFlexElementMixin";
import { api, track } from "lwc";
import { cloneDeep, get } from "c/lodash";
import { getCardObjectFields } from "c/flexCardUtility";
import flexChartTemplate from "./flexChart.html";

const regex = /\\/g;
export default class FlexChart extends BaseFlexElementMixin(Chart) {
  @track _records;
  @track _columnNames = [];
  @track _recordsArray = [];

  _fieldNode;
  _valueNode;
  _colorPalette = [];
  _titlePosition;
  _titleFontSize;
  _titleFontFamily;
  _titleFontColor;
  _titleFontStyle;

  @track _hasAccessibilitySupport = false;
  @api get hasAccessibilitySupport() {
    return this._hasAccessibilitySupport;
  }
  set hasAccessibilitySupport(val) {
    this._hasAccessibilitySupport =
      val === "true" || val === true ? true : false;
    this.hideHeader = this._hasAccessibilitySupport ? false : this.hideHeader;
  }

  @api get records() {
    return this._records;
  }
  set records(val) {
    if (val) {
      this._records = cloneDeep(val);
      this.setValues();
    }
  }

  @api get record() {
    return this._record;
  }
  set record(val) {
    if (val) this._record = val;
  }

  @api get labelNode() {
    return this._labelNode;
  }
  set labelNode(val) {
    if (val) {
      this._labelNode = val;
      this.setValues();
    }
  }

  @api get valueNode() {
    return this._valueNode;
  }
  set valueNode(val) {
    if (val) {
      this._valueNode = val;
      this.setValues();
    }
  }

  @api get colorPalette() {
    return this._colorPalette;
  }
  set colorPalette(val) {
    if (val) {
      // this is an array. make sure its not strigified and no back slash present
      this._colorPalette =
        typeof val === "string"
          ? JSON.parse(val.replace(regex, ""))
          : cloneDeep(val);
      this.backgroundColor = this.getBGcolor(
        this._colorPalette,
        this.values.length
      );
    }
  }

  @api get title() {
    return this._title;
  }
  set title(val) {
    if (val) this._title = val;
  }

  @api get styles() {
    return this._styles;
  }
  set styles(val) {
    if (val) {
      this._styles = typeof val === "string" ? JSON.parse(val) : val;
      this.setStyleToConfig(this._styles);
    }
  }

  setValues() {
    if (this._labelNode && this._valueNode && this._card && this._records) {
      let cardDs =
        this._card.dataSource ||
        this._card[getCardObjectFields(this._card).DataSourceConfig];
      cardDs = typeof cardDs === "string" ? JSON.parse(cardDs) : cardDs;
      let records = this._records;
      if (
        cardDs &&
        cardDs.value &&
        cardDs.value.resultVar &&
        !Array.isArray(records)
      ) {
        records = get(this._records, cardDs.value.resultVar) || [];
      }
      // values cannot be non number
      let values = [];
      let labels = [];
      if (records && Array.isArray(records) && records.length) {
        this._columnNames = Array.from([
          { fieldName: this._labelNode, label: this._labelNode },
          { fieldName: this._valueNode, label: this._valueNode }
        ]);
        this._recordsArray = records;

        labels = records.map(item => item[this._labelNode]);

        records.forEach(item => {
          const val = Number(item[this._valueNode]);
          if (val !== null && !isNaN(val)) values.push(val);
        });
        if (labels.length === values.length) {
          this.values = values;
          this.labels = labels;
          this.setTable();
          this.backgroundColor = this.getBGcolor(
            this._colorPalette,
            values.length
          );
        } else
          this.showToast(
            "Values need to be number and have same count as labels",
            "Error",
            "error",
            "3000"
          );
      }
    }
  }

  @track tableHeader = [
    { name: "Label", id: "0" },
    { name: "Value", id: "1" }
  ];
  @track tableRows = [{}];
  @track isTableCollapsed = true;
  @track isTableExpanded = false;
  @track iconName = "utility:chevronright";

  setTable() {
    this.tableRows = this.labels.map((name, index) => {
      let tableRow = [];
      tableRow.push({ name, id: "l" + index + 1 });
      tableRow.push({ name: this.values[index], id: "v" + index + 1 });
      return { row: tableRow, id: index + 1 };
    });
  }

  toggleSection(event) {
    this.isTableCollapsed = !this.isTableCollapsed;
    this.isTableExpanded = !this.isTableExpanded;
    this.iconName = this.isTableCollapsed
      ? "utility:chevronright"
      : "utility:chevrondown";
    this.template
      .querySelector(".tableSection")
      .classList.toggle(`slds-is-open`, this.isTableExpanded);

    event.stopPropagation();
  }

  getBGcolor(arr, length) {
    const len = arr.length;
    let BGarr = [];
    for (let i = 0, j = 0; i <= length; i++, j++) {
      BGarr[i] = arr[j];
      if (j === len - 1) j = -1;
    }
    return BGarr;
  }

  triggerRender() {
    this.getInterpolatedLabel(this._title);
    this.init();
  }

  /**
   * Added as part of - https://vlocity.atlassian.net/browse/CARD-4656
   * This function returns intepolated values for labels/titles
   * @param {String} - The field to be interpolated
   * @returns {String}
   */
  getInterpolatedLabel(field) {
    if (!field) return "";
    let label = field;
    if (
      label &&
      label.indexOf("{") !== -1 &&
      (this._record || this._allMergeFields)
    ) {
      return label.replace(/\{(.*?)\}/g, (match, expr) => {
        let value = get(this._record, expr);
        if (this._allMergeFields && !value) {
          value = get(this._allMergeFields, expr);
        }
        return typeof value !== "undefined" ? value : match;
      });
    }
    return label;
  }

  constructor() {
    super();
    this.values = [10, 5, 20, 15, 35, 25];
    this.labels = ["Label1", "Label2", "Label3", "Label4", "Label5", "Label6"];
    this.backgroundColor = [
      "#52B7D8",
      "#E16032",
      "#FFB03B",
      "#54A77B",
      "#4FD2D2",
      "#E287B2"
    ];
    this.background = "transparent";
    this.minSizeResizeable = 1;
  }

  timer;
  /**
   * This function overrides the existing function in chart component
   * The difference is this has the title key as part of the config object.
   */
  init() {
    if (this.timer) return;
    // eslint-disable-next-line @lwc/lwc/no-async-operation
    this.timer = setTimeout(() => {
      this.timer = null;
      if (
        this._type &&
        this._labels.length !== 0 &&
        this._values.length !== 0 &&
        this._backgroundColor.length !== 0
      ) {
        this.config = {
          type: this.type,
          data: {
            labels: [...this.labels],
            datasets: [
              {
                label: "" + this.type + " Dataset",
                backgroundColor:
                  this._type &&
                  (this._type === "radar" || this._type === "line") &&
                  Array.isArray(this._backgroundColor)
                    ? this._backgroundColor[0]
                    : [...this._backgroundColor],
                data: [...this.values]
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: this.maintainAspectRatio,
            aspectRatio: this.aspectRatio,
            cutoutPercentage: this.cutoutPercentage,
            title: {
              display: !this.hideHeader,
              position: this._titlePosition || "top",
              text: this.getInterpolatedLabel(this._title) || "",
              fontSize: this._titleFontSize || 12,
              fontFamily: this._titleFontFamily || "Helvetica Neue",
              fontColor: this._titleFontColor || "#666",
              fontStyle: this._titleFontStyle || "bold"
            },
            legend: {
              position: "right",
              display: this.displayLegend
            },
            animation: {
              animateScale: !this.disableAnimateScale,
              animateRotate: !this.disableAnimateRotate
            },
            onClick: (event, legendItem) => {
              event.preventDefault();
              this.handleClick(legendItem);
            },
            tooltips: {
              enabled: true,
              callbacks: {
                label: function(tooltip, dataObject) {
                  return dataObject.datasets[tooltip.datasetIndex].data[
                    tooltip.index
                  ];
                }
              }
            }
          }
        };
        this.renderChart(this.config, this.template);
      }
    }, 500);
  }

  /**
   * This function will set the styleObjectConfigurations to the appropriate chart config variables
   */
  setStyleToConfig(styleObj) {
    if (styleObj && styleObj.chartTitle) {
      this.setStyleForTitle({ ...styleObj.chartTitle });
    }
  }

  setStyleForTitle(titleObj) {
    if (titleObj) {
      if (titleObj.fontFamily) {
        this._titleFontFamily = titleObj.fontFamily;
      }
      if (titleObj.position) {
        this._titlePosition = titleObj.position;
      }
      if (titleObj.fontSize) {
        this._titleFontSize = parseInt(titleObj.fontSize, 10);
      }
      if (titleObj.fontColor) {
        this._titleFontColor = titleObj.fontColor;
      }
      if (titleObj.fontStyle) {
        this._titleFontStyle = titleObj.fontStyle;
      }
    }
  }

  render() {
    return flexChartTemplate;
  }
}
