/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { cloneDeep, omit } from "c/lodash";

/** This Method creates the cards array for debugJSON panel
 *
 * The format is like so
 * [
 *  {
 *      StateName: [somestate],
 *      // the entire records obj goes here
 *  }
 * ]
 */
function createCardsArrayForDebugJSONPanel(elements, mergeFields) {
  let cardsArrayForDebugPanel = [];
  if (elements && elements.length) {
    elements.forEach(element => {
      if (element.selectedState) {
        let record = element.record ? cloneDeep(element.record) : {};
        let components =
          element.state && element.state.components["layer-0"]
            ? element.state.components["layer-0"]
            : {};
        let card = {
          StateName: element.state && element.state.name,
          ChildCards: getNestedElements("childCardPreview", components, []),
          ...omit(record, ["_flex"])
        };
        //Adding Flex.<> mergeFields inside cards records JSON for debugger panel
        card.Flex = { index: element.dataset.rindex };
        Object.keys(mergeFields.Flex).forEach(key => {
          if (
            typeof mergeFields.Flex[key]?.[record.uniqueKey] !== "undefined"
          ) {
            card.Flex[key] = mergeFields.Flex[key]?.[record.uniqueKey];
          }
        });
        cardsArrayForDebugPanel.push(card);
      }
    });
  }
  return cardsArrayForDebugPanel;
}

function postMessage(name, key, data, targetOrigin) {
  const message = {
    name: name,
    key: key,
    detail: cloneDeep(data)
  };
  window.parent.postMessage(message, targetOrigin);
}

function getNestedElements(type, stateObj, elementsArray) {
  let children = stateObj.children;
  if (children && children.length) {
    children.forEach(child => {
      getNestedElements(type, child, elementsArray);
    });
  } else {
    if (stateObj.element && stateObj.element === type) {
      let cardName = stateObj.property && stateObj.property.cardName;
      elementsArray.push(cardName);
    }
  }
  return elementsArray;
}

export { createCardsArrayForDebugJSONPanel, postMessage };
