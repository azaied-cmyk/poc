/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import OmniscriptBaseElement from 'c/omniscriptBaseElement';
import { HasValidation } from 'c/omniscriptValidation';
import { showHideValidityHook } from 'c/omniscriptValidation';
import { currencySymbol, isRepeatNotation } from 'c/omniscriptInternalUtils';

/**
 * Atomic Base Element Component for Leaf element, this extends OmniscriptBaseElement
 * empty html template
 * Mixin HasValidation
 * Mask Helper
 */
export default class OmniscriptAtomicElement extends HasValidation(OmniscriptBaseElement) {
    _maskProperties = {};
    _isMasked = false;
    _patternVal;
    _handleHelpText;
    _styleClasses = {};
    _savedJsonPath;

    // Masking helper function
    prepareIMaskProperties(mask) {
        mask = mask == null ? '' : mask;
        this._maskProperties.radix = '.';

        if (typeof mask === 'number' || mask.lastIndexOf('.') !== -1) {
            this._isMasked = true;
            this._maskProperties.scale = typeof mask === 'number' ? mask : mask.substring(mask.lastIndexOf('.') + 1).length;
            this._maskProperties.padFractionalZeros = mask === 0 ? false : true;
        } else if (!mask) {
            this._maskProperties.scale = 1000;
            this._maskProperties.padFractionalZeros = false;
        } else {
            this._isMasked = true;
            this._maskProperties.radix = ',';
        }
        this._maskProperties.thousandsSeparator = this.findThousandsSeparator(mask);
    }

    // Masking helper function
    findThousandsSeparator(mask) {
        var i, chr;
        for (i = 1; i < mask.length; i++) {
            chr = mask.charAt(i);
            if (mask.indexOf(chr) === i && mask.indexOf(chr, i + 1) === -1 && chr !== '.') {
                return chr;
            }
        }
        return typeof mask === 'number' ? ',' : '';
    }

    initCompVariables() {
        super.initCompVariables();
        // assigns style classes
        this._styleClasses.container = `${this._theme}-grid`;
        this._styleClasses.input = `${this._theme}-container_fluid `;
        this.applyRepeatableStyles();
        this._savedJsonPath = this.jsonDef.JSONPath;

        if (this.jsonDef && this._propSetMap && this._propSetMap.pattern) {
            this._patternVal = this._propSetMap.pattern;
        }

        if (this.jsonDef && this._propSetMap && this._propSetMap.help) {
            this._handleHelpText = this._propSetMap.helpText;
        }

        if (this.jsonDef && this._propSetMap && this._propSetMap.autocomplete) {
            this._autocomplete = this._propSetMap.autocomplete;
        }
    }

    /**
     * @scope private
     * @description Applies class styles to support repeat / repeat clone features for all atomic inputs.
     * @return {Void}
     */
    applyRepeatableStyles() {
        const prefix = this._theme;

        if (this.jsonDef && this._propSetMap && this._propSetMap.repeat) {
            this._styleClasses.repeatAdd = `${prefix}-button_reset ${prefix}-m-right_x-small `;
            this._styleClasses.repeatIcons = `${prefix}-button__icon ${prefix}-button__icon_small `;
            this._styleClasses.repeatRemove = `${this._styleClasses.repeatAdd} `;
            this._styleClasses.repeatContainer = 'omni-repeat-button-group ';

            if (this.layout === 'newport') {
                this._styleClasses.input += 'nds-input-has-icon_right';
                this._styleClasses.repeatContainer += 'nds-button-group nds-m-right_x-small nds-tooltip__container';
                this._styleClasses.repeatAdd += 'vlocity-btn nds-button nds-button_icon nds-m-right_x-small';
                this._styleClasses.repeatRemove += 'vlocity-btn nds-button nds-button_icon';
            } else {
                this._styleClasses.repeatContainer += 'slds-button-group omni-repeat-button-group';
                this._styleClasses.repeatIcons += 'slds-grid';
                this._styleClasses.input = ' omni-repeat-input ';
            }
        }
    }

    validityHook(newShow) {
        showHideValidityHook(newShow, this);
    }

    // use this to validate the api data
    // derived components can overwrite it
    validateData(data) {
        // default - String
        return {
            valid: typeof data === 'string' || data === null,
            dataToApply: data,
        };
    }

    setElementFormattedValue() {
        super.setElementFormattedValue();
        if (this.childInput && this._isMasked) {
            this._elementFormattedValue = this.childInput.maskedValue;
        }
        if (this._elementFormattedValue != null) {
            this.dispatchOmniEventUtil(this, { node: this.jsonDef.JSONPath, value: this._elementFormattedValue }, 'omniformatteddata');
        }
    }

    // Masking helper function
    getImaskCurrencyAttributes() {
        let imaskAttributes = null;
        if (!this.childInput) {
            const propMask = this._propSetMap.mask;
            let mask = propMask === '' || propMask == null ? this.getCurrencySymbol(true) : propMask;

            this.prepareIMaskProperties(mask);

            imaskAttributes = {
                mask: this.getCurrencySymbol() + 'num',
                numberMask: true,
                currency : true,
                blocks: {
                    num: {
                        // TODO: move convert imask options to single attributes.
                        // eslint-disable-next-line no-new-wrappers
                        mask: new Number(),
                        scale: this._maskProperties.scale,
                        thousandsSeparator: this._propSetMap.hideGroupSep ? '' : this._maskProperties.thousandsSeparator,
                        radix: this._maskProperties.radix,
                        signed: this._propSetMap.allowNegative,
                        padFractionalZeros: this._maskProperties.padFractionalZeros,
                    },
                },
            };
        }
        return imaskAttributes;
    }

    // Masking helper function
    getImaskNumberAttributes() {
        let imaskAttributes = null;
        if (!this.childInput) {
            this.prepareIMaskProperties(this._propSetMap.mask);
            imaskAttributes = {
                // TODO: move convert imask options to single attributes.
                // eslint-disable-next-line no-new-wrappers
                mask: new Number(),
                numberMask: true,
                scale: this._maskProperties.scale,
                thousandsSeparator: this._maskProperties.thousandsSeparator,
                radix: this._maskProperties.radix,
                signed: true,
                padFractionalZeros: this._maskProperties.padFractionalZeros,
            };
        }
        return imaskAttributes;
    }

    /**
     * Get the sfdc supported currency symbol from currencySymbol
     * currencyCode = Script Level Currency Code - First Preference
     * userCurrencyCode = User Default Currency - Second Preference
     */
    getCurrencySymbol(format) {
        let curSymbol =
            currencySymbol[this.jsonData.OmniScriptCurrencyCode] ||
            currencySymbol[this.scriptHeaderDef.propSetMap.currencyCode] ||
            currencySymbol[this.jsonData.userCurrencyCode];
        let currencyCode = this.jsonData.OmniScriptCurrencyCode || this.scriptHeaderDef.propSetMap.currencyCode || this.jsonData.userCurrencyCode;

        // default to USD?
        if (!curSymbol) {
            curSymbol = currencySymbol.USD;
        }

        return format ? curSymbol.format : this._propSetMap.displayCurrencyCode ? currencyCode + ' ' : curSymbol.text;
    }

    get defaultValue() {
        if (
            this._propSetMap.defaultValue != null &&
            typeof this._propSetMap.defaultValue === 'string' &&
            this._propSetMap.defaultValue.indexOf('%') >= 0
        ) {
            return this.handleMergeFieldUtil(
                this._propSetMap.defaultValue,
                this.jsonData,
                this.scriptHeaderDef.labelMap,
                isRepeatNotation(this._propSetMap.defaultValue) ? this.jsonDef.JSONPath : null,
            );
        }

        return this._propSetMap.defaultValue;
    }

    stateRefresh() {
        if (this._savedJsonPath !== this.jsonDef.JSONPath && this._elementFormattedValue != null) {
            this.setElementFormattedValue();
            this._savedJsonPath = this.jsonDef.JSONPath;
        }
    }

    omniRORequired(ckValidity) {
        // Angular - if the property readOnly is set to true in the designer, we don't run conditional readonly watch
        // LWC - OWC-1239, the conditional readonly watch will run no matter whether readOnly is true or false
        // Angular - if the property required is set to false in the designer, we don't run conditional required watch
        // LWC - OWC-1239, the conditional required watch will run no matter whether required is true or false
        if (this._propSetMap.conditionType === 'Readonly if False') {
            let ro = this.evalConditionUtil(this.jsonDef, 'show', this);
            this._propSetMap = Object.assign({}, this._propSetMap, { readOnly: !ro });
            this.setReadOnly(!ro);
        } else if (this._propSetMap.conditionType === 'Optional if False') {
            let req = this.evalConditionUtil(this.jsonDef, 'show', this);
            if (req !== this._propSetMap.required) {
                this._propSetMap = Object.assign({}, this._propSetMap, { required: req });
                Promise.resolve().then(() => {
                    if (req === true || ckValidity) {
                        this.checkValidity();
                    } else {
                        this.reportValidity();
                    }
                });
            }
        }
    }
}
