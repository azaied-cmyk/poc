/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { LWCPrep, UserLanguageCode, isOffPlatform } from 'c/omniscriptRestApi';
import OmniscriptGroupElement from 'c/omniscriptGroupElement';
import {
    scriptDataJsonInit,
    internalUrlKeyList,
    setSpinnerActionMessage,
    OMNISCRIPTFORMATTEDDATAJSON,
    RUN_MODES,
    getUrlParams,
    getStepLabel,
    showToast,
} from 'c/omniscriptInternalUtils';
import { api, track } from 'lwc';
import {
    registerNs,
    nsObject,
    evalSpinnerCond,
    registerIsInsidePckg,
    handleErrorReplace,
    generateUUID,
    beforeUnloadHandler,
    isInBuilder,
    logOmniscriptUsageEvent,
} from 'c/omniscriptInternalUtils';
import { loadHeaderStyles, saveForLater as saveForLaterUtil, isRTL, handleTimeTracking } from 'c/omniscriptUtils';
import pubsub from 'c/pubsub';
import { StateChangeEvent } from 'c/navigateAction';
import OmniscriptCancelAction from 'c/omniscriptCancelAction';
import { sldsContainerClassTmpl, ndsContainerClassTmpl, DEFAULT_CANCEL, LAUNCHER_ACTION } from './omniscriptHeaderConstants';
import { handleOotbLabel, allCustomLabels } from 'c/omniscriptCustomLabels';
import { delay } from 'c/asyncUtils';
import { normalizeParams, parseParams, stringifyParams } from 'c/navigationUtils';

/**
 * @module ns/omniscriptHeader
 * @extends OmniscriptGroupElement
 * @typicalname omniscriptHeader
 */
export default class OmniscriptHeader extends OmniscriptGroupElement {
    //#region privateVariables
    _initialHeaderRender = false;
    _lastStepIndex = 0;
    _lastExecutedStepIndex = 0;
    _bValidOs = true;
    _bPreview = false;
    _bSflPrefill = null;
    _bSflFilesMap = null;
    _bSflInProgress = false;
    _bSflQueued = false;
    _bSflQueuedAuto = false;
    _systemInfo;
    _errorMsg;
    _sideContentClasses = '';
    _isActiveOs = true;
    _pendingUpdates = 0;
    _resetPositionComp;
    _handleActionTimeTrackingDataObj = {};
    _cancelMessagingEnabled;
    _startTime; // Time when OmniScript is first loaded into the DOM
    scriptHeaderMessagingEnabled;
    _lastUiDisplayTime;
    _savedAsIndex; // (OWC-1959) = this.jsonDef.asIndex when resuming
    //#endregion

    /**
     * Flag indicating whether SEO mode is enabled.
     * Set in connectedCallback.
     * @type {boolean}
     * @scope private
     */
    _isSeoEnabled = false;
    /**
     * The index currently being navigated to.
     * set in handleStateChange, and renderedCallback.
     * @type {number}
     * @scope private
     */
    _targetIndex = 0;
    _stepNameIndexMap = new Map();

    /**
     * Cached reference to component used when user clicks 'cancel'.
     * If a navigate action with the name 'CANCEL' has been defined, that will be used, otherwise a default navigate
     * action will be returned. Queried in `initialRenderCallback`.
     * @type {(OmniscriptCancelAction|NavigateAction)}
     * @scope track (private)
     */
    @track cancelAction;

    /**
     * Text rendered in the OmniScript cancel button. This text is derived from either the
     * Configured navigate-action, or the custom label.
     * @type {string}
     * @scope track (private)
     */
    @track cancelLabel;

    /**
     * Cached reference to the navigate action used when an inline OmniScript completes.
     * @type {NavigateAction}
     * @scope private
     */
    _doneAction;

    /**
     * If true, the omniscript will initially render in a collapsed state, and return to this state when complete.
     * @type {boolean}
     * @scope api (public)
     */
    @api inline = false;

    /**
     * Label rendered on inline launcher button. Set via app/page/community builder.
     * @type {string}
     * @scope api (public)
     */
    @api inlineLabel = 'Launch OmniScript';

    /**
     * Style of button that the inline launcher button will be rendered as. Set via app/page/community builder.
     * @type {string}
     * @scope api (public)
     */
    @api inlineVariant = 'brand';

    /**
     * Flag to show or hide the launcher navigate-action.
     * @type {boolean}
     * @scope track (private)
     */
    @track isLauncherVisible = false;

    /**
     * Bound event handler.
     * @type {Function}
     * @scope private
     */
    beforeUnloadHandler;

    /**
     * Boolean value toggled when showComp is called.
     * @type {boolean}
     * @scope private
     */
    _isOsVisible = false;

    /**
     * Configuration for the launcher navigate-action.
     * Used when this.inline is true pre 109
     * @type {Object}
     * @scope private
     * @deprecated
     */
    _launcherAction = LAUNCHER_ACTION;

    /**
     * Configuration for the default cancel navigate-action.
     * Used when inline is true, and not 'CANCEL' omniscript-navigate action was configured.
     * @type {Object}
     * @scope private
     */
    _defaultCancel = DEFAULT_CANCEL;

    @api prefill;
    @api instanceId;

    @track firstRender = false;

    /**
     * The schema which describe the OmniScript header.
     * @type {OmniHeaderDefinition}
     */
    @track jsonDef = {};
    /**
     * A cached reference to the initialized jsonDef, used to reset OmniScripts in inline mode.
     * @type {string}
     */
    initialJsonDef;
    @track jsonData;
    // OWC-1044, at the header level, we make jsonDataStr a private property
    jsonDataStr;
    @track scriptHeaderDef = {};
    /**
     * A cached reference to the initialized scriptHeaderDef, used to reset OmniScripts in inline mode.
     * @type {string}
     */
    initialScriptHeaderDef;
    @track hasPrev = false; // Flag to determine if the previous step is accessible
    @track hasNext = false; // Flag to determine if the next step is accessible
    @track hasErrors = false;
    @track allowSfl = false; // Flag to determine if save for later is enabled in step
    @track compLoaded = false;
    @track modalEvents = [];
    @track bSflValid = true;
    @track bSflAuto = false;
    @track bSflResult = {};
    @track stepChartProps = {
        layout: '',
        position: '',
    };
    @track navButton = {
        previous: {
            label: '',
            classes: '',
            targetParams: '',
        },
        next: {
            label: '',
            classes: '',
            targetParams: '',
        },
        save: {
            label: '',
            classes: '',
        },
    };
    @track bSflComplete = false; // Save for later is complete
    nextStepAriaLabel = '';
    prevStepAriaLabel = '';

    /**
     * Classes applide to the <article /> container of the OmniScript.
     * Defaults are defined in `./omniscriptHeaderConstants`.
     * @type {string}
     * @scope track (private)
     */
    @track containerClasses;

    @track contentSldsClass =
        'omniscript-body slds-card__body slds-card__body_inner slds-m-top_medium slds-p-right_medium slds-col slds-grid slds-grid_vertical slds-size_1-of-1';
    @track spinnerMessage = '';

    /**
     * @type {String} - Knowledge label for KB.
     * @scope private
     */
    knowledgeLabel;
    _stepChartPlacement;
    /**
     * @type {Boolean} - whether KB will display outside OmniScript OR not.
     * @scope private
     */
    _dispOutsideOmni;

    /**
     * @type {Boolean} - whether KB is enabled OmniScript side OR not.
     * @scope private
     */
    _isKbEnabledOnScript;

    // when Language = Multi-Language, get the LanguageCode from the url param
    _languageCode;
    _rtpReq;
    _sflErrorMsgs = { OmniScriptNotFound3: '' };
    // custom label Util function (to support Multi-Language)
    allCustomLabelsUtil = allCustomLabels;
    _staticLabelCt = Object.getOwnPropertyNames(this.allCustomLabelsUtil).length;

    // Used for initial navigation
    _urlParams = {};

    /**
     * Contains the direction of the language which is affected by the css.
     * LTR = Left-to-Right
     * RTL = Right-to-Left
     * @type {String} - direction of the language
     * @scope private
     */
    _isRTL = isRTL(UserLanguageCode);
    _dir = isRTL(UserLanguageCode) ? 'rtl' : 'ltr'; // user's language from lwc API

    /**
     * Exposing dir (direction) property in order to allow users to manually specify the direction
     * of the text
     */
    @api
    get dir() {
        return this._dir;
    }
    set dir(direction) {
        // if direction not set by user, default to user's language code + direction
        if (direction) {
            this._isRTL = direction === 'rtl';
            this._dir = this._isRTL ? 'rtl' : 'ltr';
        }
    }

    /**
     * @scope private
     * @description Overwrites inherited connectedCallback.
     * @returns {Void}
     */
    connectedCallback() {
        // Stores the time when the OmniScript is first loaded into DOM
        this._startTime = Date.now();
        this._lastUiDisplayTime = this._startTime;

        let promiseList = [];
        this._bPreview = !this.runServerCheck();
        this.scriptHeaderDef = {};
        this._isSeoEnabled =
            this.jsonDef.propSetMap.isSeoEnabled === true && (this.runMode === RUN_MODES.PLAYER || this.runMode === RUN_MODES.OFFLINE);

        if (this.jsonDef.hasRestartAction) {
            this.handleRestart = this.restartScript.bind(this);
            this.addEventListener('restartscript', this.handleRestart);
        }

        if (this._isSeoEnabled) window.addEventListener('popstate', this.handlePopState.bind(this));

        if (
            isInBuilder() === false &&
            this.jsonDef.propSetMap.disableUnloadWarn === false &&
            (this.runMode === RUN_MODES.PLAYER || this.runMode === RUN_MODES.OFFLINE)
        ) {
            this.beforeUnloadHandler = beforeUnloadHandler.bind(this);
            window.addEventListener('beforeunload', this.beforeUnloadHandler);
        }

        // < 107 backwards compatibility
        if (Object.keys(this._urlParams).length === 0) {
            this._urlParams = normalizeParams(parseParams(window.location.search));
        }

        // INS 108 - Multi-Lang support - label handling for LWC Enabled OmniScript
        // (1) SFL case - the saved fullJson.labelKeyMap should contain all Custom Labels
        // - Static labels defined in omniscriptCustomLabels + dynamic labels defined for a particular OmniScript
        // + more labels defined in the script header --- All are fetched along with fetching saved OmniScript
        // (2) Active new Non Multi-Language OmniScript - extra server translation call to fetch
        // more labels defined in the script header
        // (3) Active new Multi-Language OmniScript - extra server translation call to fetch
        // Static labels defined in omniscriptCustomLabels + dynamic labels defined for a particular OmniScript
        // + more labels defined in the script header
        // (4) Inactive new Multi-Language OmniScript - extra server call to fetch
        // Static labels defined in omniscriptCustomLabels
        // (5) Inactive new non Multi-Language OmniScript - no extra server translation call
        // There is only one case this._multiLang = undefined (SFL for inactive preview)
        let multiLangParams = getUrlParams(this.prefill, ['LanguageCode', 'mls']);
        this._multiLang = this.jsonDef.bpLang ? this.jsonDef.bpLang === 'Multi-Language' : multiLangParams.mls === 'true';
        if (this._multiLang) {
            this._languageCode = multiLangParams.LanguageCode || this.langCode;
            if (this._urlParams.hasOwnProperty('LanguageCode') && !this._languageCode) {
                this._languageCode = this._urlParams.LanguageCode;
            }
        }
        if (this._languageCode) {
            this._isRTL = isRTL(this._languageCode);
        }
        this._dir = this._isRTL ? 'rtl' : 'ltr';

        // LWC Prep - we want to combine the server calls, each call is at least 250 ms
        // (1) GetUserInfo (2) IsActiveOmniscript (3) BuildJSONV3 (4) Fetch Picklist Values At Script Load
        let lwcPrepObj = {};

        if (!this.resume) {
            if (!this._multiLang) {
                if (
                    this.jsonDef.propSetMap.moreCustomLabels &&
                    Array.isArray(this.jsonDef.propSetMap.moreCustomLabels) &&
                    this.jsonDef.propSetMap.moreCustomLabels.length > 0
                ) {
                    // do nothing
                } else {
                    // back fix an issue, for a non Multi-Language script, labelKeyMap always had one entry 'New'
                    this.jsonDef.labelKeyMap = {};
                }
            }
            if (!this._bPreview) {
                lwcPrepObj.IsActiveOmniscript = { scriptId: this.jsonDef.sOmniScriptId };
                let allLabels;
                // (1) moreCustomLabels defined in the script header (INS 108 new) - supported
                // for both Multi-Language and non Multi-Language
                // (2) labelKeyMap for Multi-Language
                // (3) Static Labels imported in omniscriptCustomLabels util lwc
                if (
                    this.jsonDef &&
                    this.jsonDef.propSetMap &&
                    this.jsonDef.propSetMap.moreCustomLabels &&
                    Array.isArray(this.jsonDef.propSetMap.moreCustomLabels) &&
                    this.jsonDef.propSetMap.moreCustomLabels.length > 0
                ) {
                    // allLabels = this.jsonDef.propSetMap.moreCustomLabels;
                    allLabels = this.jsonDef.propSetMap.moreCustomLabels.reduce((a, b) => {
                        a[b] = '';
                        return a;
                    }, {});
                }
                if (this._multiLang) {
                    // Multi-Language
                    allLabels = Object.assign({}, allLabels, this.jsonDef.labelKeyMap);
                    if (this._languageCode) {
                        allLabels = Object.assign({}, allLabels, this.allCustomLabelsUtil);
                    }
                }
                if (allLabels) {
                    lwcPrepObj.labelKeyMap = { input: JSON.stringify(allLabels), language: this._languageCode };
                }
            }
            if (this._multiLang || this.jsonDef.propSetMap.rtpSeed) {
                this._rtpReq = this.getRtpReq(this.jsonDef);
                if (this._rtpReq && !this.resume) {
                    lwcPrepObj.OmniScriptPicklistSeed = this._rtpReq;
                }
            }
        }
        if (this._bPreview && this._multiLang && this._languageCode) {
            lwcPrepObj.labelKeyMap = { input: JSON.stringify(this.allCustomLabelsUtil), language: this._languageCode };
        }

        if (this.resume) {
            lwcPrepObj.BuildJSONV3 = {
                sId: this.instanceId,
                scriptState: 'saveAndResume',
                bPreview: this._bPreview,
                multiLangCode: this._languageCode,
            };
            if (this._multiLang && this._languageCode) {
                lwcPrepObj.labelKeyMap = { input: JSON.stringify(this._sflErrorMsgs), language: this._languageCode };
            }
        }

        // (1) non Multi-Lang inactive script with no moreCustomLabels AND SFL
        // (2) non Multi-Lang inactive script with moreCustomLabels AND SFL
        // (3) non Multi-Lang active script with no moreCustomLabels AND SFL
        // (4) non Multi-Lang active script with moreCustomLabels AND SFL
        // (5) repeat (1) - (4) for Multi-Lang (LanguageCode = null)
        // (6) repeat (1) - (4) for Multi-Lang (LanguageCode = zh_CN)
        // known issue - for inactive preview SFL, if SFL comes back with error
        // OmniScriptNotFound3 may not be properly translated
        promiseList.push(
            LWCPrep(
                {
                    config: JSON.stringify(lwcPrepObj),
                },
                this.runMode,
                this.resume,
            ).then(response => {
                const initInfo = JSON.parse(response);
                if (initInfo.labelKeyMap) {
                    this.allCustomLabelsUtil = Object.assign({}, this.allCustomLabelsUtil, JSON.parse(initInfo.labelKeyMap));
                }

                if (this._bPreview && !this.resume) {
                    this.allCustomLabelsUtil = Object.assign({}, this.allCustomLabelsUtil, this.jsonDef.labelKeyMap);
                }

                // Set the labels for the sflAcknowledge
                this.bSflResult.allCustomLabels = this.allCustomLabelsUtil;

                if (!this.resume) {
                    // simply for saveforlater
                    this.jsonDef.labelKeyMap = Object.keys(this._multiLang ? this.allCustomLabelsUtil : this.jsonDef.labelKeyMap).reduce(
                        (accumulator, current) => {
                            accumulator[current] = '';
                            return accumulator;
                        },
                        {},
                    );
                }

                // Save for later - Skip active validation
                if (initInfo.BuildJSONV3) {
                    this.handleResumeBpDef(initInfo.BuildJSONV3);
                } else {
                    // Active OS check only if we are not in preview mode
                    if (initInfo.hasOwnProperty('IsActiveOmniscript')) {
                        this.hasErrors = !initInfo.IsActiveOmniscript;
                        this._errorMsg = this.allCustomLabelsUtil.OmniScriptNotFound3;
                        this._isActiveOs = initInfo.IsActiveOmniscript;
                    }
                }
                const offlineInfo = {
                    namespace: initInfo.namespace + '__',
                    userCurrencyCode: this.jsonDef.userCurrencyCode,
                };
                this.handleUserInfo(initInfo.GetUserInfo || offlineInfo);

                if (initInfo.OmniScriptPicklistSeed && initInfo.OmniScriptPicklistSeed.VlocPicklistSeeding) {
                    this.scriptHeaderDef.rtpSeed = JSON.parse(initInfo.OmniScriptPicklistSeed.VlocPicklistSeeding);
                }

                // Store Custom Setting flag for OmniAnalytics into scriptHeaderDef if enabled
                if (initInfo.OmniAnalyticsEnabled === true) {
                    this.scriptHeaderDef.omniAnalyticsEnabled = initInfo.OmniAnalyticsEnabled;
                }

                // Is the user a guest user? (communities only)
                this.scriptHeaderDef.isGuestUser = initInfo.IsGuestUser === true;
            }),
        );

        // Loads header styles including NDS and global stylesheets. Global stylesheets will not be loaded in design
        // mode
        promiseList.push(loadHeaderStyles(this, this.layout, this._isRTL));

        Promise.all(promiseList)
            .then(() => {
                if (this._bValidOs && ((this.jsonDef.children && this.jsonDef.children.length > 0) || this.resume)) {
                    this._stepChartPlacement = this.jsonDef.propSetMap.stepChartPlacement;

                    // make the UI render only after the resource files load
                    this.initScriptHeaderDef();

                    super.connectedCallback();

                    // Adds event listeners
                    this.template.addEventListener('omnistepchart', this.handleStepChartEvent.bind(this));
                    this.template.addEventListener('omnimodal', this.handleModalEvent.bind(this));
                    this.template.addEventListener('omniactionbtn', this.handleActionBtnEvent.bind(this));
                    this.template.addEventListener('omniautoadvance', this.handleAutoAdv.bind(this));
                    this.template.addEventListener('omnicustomsavestate', this.handleCustomSaveState.bind(this));
                    this.template.addEventListener('omnisavedforlater', this.handleSaveForLaterComplete.bind(this));
                    this.template.addEventListener('omnisaveforlater', this.handleSaveForLater.bind(this));
                    this.template.addEventListener('omnifileuploaded', this.handleFileUploaded.bind(this));
                    this.template.addEventListener('omniformatteddata', this.handleFormattedData.bind(this));
                    this.template.addEventListener('omnipendingupdates', this.handlePendingUpdates.bind(this));
                    this.template.addEventListener(StateChangeEvent.type, this.handleStateChange.bind(this));

                    // Register pubsub event for handling time tracking data for actions. Event is fired from
                    // omniscriptActionCommonUtil
                    this._handleActionTimeTrackingDataObj = {
                        timeTrackingData: this.handleActionTimeTrackingEventData.bind(this),
                    };
                    pubsub.register(`${this.scriptHeaderDef.uuid}omnitimetrackingdata`, this._handleActionTimeTrackingDataObj);

                    this._handleCustomSaveStateObj = {
                        data: this.handleCustomSaveState.bind(this),
                    };
                    pubsub.register(this.scriptHeaderDef.uuid + 'omnicustomsavestate', this._handleCustomSaveStateObj);

                    this._handleActionBtnEventObj = {
                        data: this.handleActionBtnEvent.bind(this),
                    };
                    pubsub.register(this.scriptHeaderDef.uuid + 'omniactionbtn', this._handleActionBtnEventObj);

                    if (this.bSflValid) {
                        this.resetFirstStepAccordionActive();
                        this.initStepIndexes();
                        this.initJsonDefResponse();
                    }

                    this.scriptHeaderDef.propSetMap = this._propSetMap;

                    if (this.inline || this.jsonDef.hasRestartAction) {
                        this.initialJsonDef = JSON.stringify(this.jsonDef);
                        this.initialScriptHeaderDef = JSON.stringify(this.scriptHeaderDef);
                    }

                    // make the UI render only after the resource files load
                    this.firstRender = true;
                    this._initialHeaderRender = true;

                    // If we are resuming save for later, add the instanceId to the data json as might be used in merge fields
                    if (this.resume && this.jsonDef.sInstanceId) {
                        this.applyCallResp({ sInstanceId: this.jsonDef.sInstanceId }, false);
                    }
                } else {
                    this.compLoaded = true;
                }
            })
            .catch(error => {
                this.handleError(error);
            });
    }

    getRtpReq(json) {
        if (
            json &&
            (Object.getOwnPropertyNames(json.sobjPL).length > 0 ||
                Object.getOwnPropertyNames(json.cusPL).length > 0 ||
                Object.getOwnPropertyNames(json.depSOPL).length > 0 ||
                Object.getOwnPropertyNames(json.depCusPL).length > 0)
        ) {
            return {
                sobjPL: Object.keys(json.sobjPL).join(),
                cusPL: Object.keys(json.cusPL).join(),
                depSOPL: Object.keys(json.depSOPL).join(),
                depCusPL: Object.keys(json.depCusPL).join(),
                LanguageCode: this._languageCode,
            };
        }
        return null;
    }

    /**
     * @scope private
     * @description Overwrites inherited initCompVariables.
     * @returns {Void}
     */
    initCompVariables() {
        super.initCompVariables();
        let kbObject;

        if (this.jsonDef && this.jsonDef.propSetMap && this.jsonDef.propSetMap.persistentComponent) {
            kbObject = this.jsonDef.propSetMap.persistentComponent.find(({ id }) => id === 'vlcKnowledge');
        }

        this.knowledgeLabel = this.jsonDef && this.jsonDef.propSetMap && kbObject ? kbObject.label : '';
        this.nextStepAriaLabel = this.allCustomLabelsUtil.OmniStepsNextStepAriaLabel;
        this.prevStepAriaLabel = this.allCustomLabelsUtil.OmniStepsPrevStepAriaLabel;
    }

    /**
     * @scope private
     * @description Handles user information.
     * @param {Object} userInfo
     * @returns {Void}
     */
    handleUserInfo(userInfo) {
        // loads user info, namespace and namespace prefix globally
        // GetUserInfo is the first promise
        if (!nsObject.namespacePrefix) {
            registerNs(userInfo.namespacePrefix);
        }

        registerIsInsidePckg(userInfo.isInsidePckg || false);
        this._systemInfo = userInfo;

        // namespacePrefix is deleted to prevent it from showing in the jsonDef.response
        delete this._systemInfo.namespacePrefix;
        delete this._systemInfo.isInsidePckg;
    }

    /**
     * @scope private
     * @description Handles JSON definition when resume.
     * @param {Object} bpDef
     * @returns {Void}
     */
    handleResumeBpDef(bpDef) {
        if (bpDef === '{}') {
            this._bValidOs = false;
            this.handleError(this.allCustomLabelsUtil.OmniScriptNotFound3);
        } else {
            let validSaveForLater = true;
            const newJson = JSON.parse(bpDef);

            if (newJson.error === 'OK') {
                // VDS-530 - Adding isStep on old saved omniscripts
                newJson.children
                    .filter(step => step.type === 'Step' && !step.isStep)
                    .forEach(step => {
                        step.isStep = true;
                    });

                // VlocPicklistSeeding
                if (newJson.VlocPicklistSeeding) {
                    this.scriptHeaderDef.rtpSeed = JSON.parse(newJson.VlocPicklistSeeding);
                    delete newJson.VlocPicklistSeeding;

                    this._rtpReq = this.getRtpReq(newJson);
                }

                this.allCustomLabelsUtil = Object.assign({}, this.allCustomLabelsUtil, newJson.labelKeyMap);

                // The check is only needed in inactive preview case
                if (!this._bPreview) {
                    validSaveForLater = this.jsonDef.sOmniScriptId === newJson.sOmniScriptId && this.jsonDef.lwcId === newJson.lwcId;
                }

                if (validSaveForLater) {
                    // Update the json definition
                    this._savedAsIndex = newJson.asIndex;
                    this._bSflFilesMap = newJson.filesMap;
                    this.jsonDef = newJson;
                    delete this.jsonDef.userName1;
                    delete this.jsonDef.userId1;
                    delete this.jsonDef.userProfile1;

                    if (!this.jsonDef.hasOwnProperty('sflTimeZone')) {
                        this.jsonDef.sflTimeZone = this.jsonDef.userTimeZone;
                    }

                    // Reset all steps to be bDirty = false
                    if (this.jsonDef.expired === true) {
                        this.jsonDef.children.forEach(child => {
                            if (child.bDirty === true) {
                                child.bDirty = false;
                            }
                        });
                    }
                } else {
                    this.bSflValid = false;
                    this.compLoaded = true;
                    this._bSflPrefill = newJson.response || {};
                    this._bSflFilesMap = newJson.filesMap || {};

                    internalUrlKeyList.forEach(key => {
                        if (this._bSflPrefill.hasOwnProperty(key)) {
                            this._bSflPrefill[key] = undefined;
                        }
                    });
                }
            } else {
                this._bValidOs = false;
                this.handleError(newJson.error);
            }
        }
    }

    /**
     * @scope private
     * @description Resets the first step accordion active in JSON definition.
     * @returns {Void}
     */
    resetFirstStepAccordionActive() {
        if (!this.hasErrors) {
            // need to reset the first step's bAccordionActive to false
            if (!this.resume && this.jsonDef.children && this.jsonDef.children.length > 0 && this.jsonDef.children[0].type === 'Step') {
                this.jsonDef.children[0].bAccordionActive = false;
            }
        }
    }

    /**
     * @scope private
     * @description Initializes scriptHeaderDef.
     * @returns {Void}
     */
    initScriptHeaderDef() {
        // scriptHeaderDef provides data that is visible to all child components
        // - hasInvalidElements => validation flag
        this._elementId = this.jsonDef.sOmniScriptId;
        let apiUiElements = {},
            kbIndex;
        let aggElements = {};
        const bResume = this.resume;

        if (this.jsonDef.children) {
            this.jsonDef.children.forEach(function(child) {
                if (child.type === 'Step') {
                    apiUiElements = { ...apiUiElements, ...child.propSetMap.uiElements };
                    aggElements = { ...aggElements, ...child.propSetMap.aggElements };
                }
                if (!bResume) {
                    // (1) At the reusable script level, conditionType can only be 'Hide if False'
                    // (2) Non 'Step' Root Element, conditionType can only be 'Hide if False'
                    // (3) Step Element, conditionType can be 'Hide if False' or 'Optional if False' or 'Readonly if False'
                    // When there is condition set at the reusable script level
                    // if Step conditionType = 'Optional if False' or 'Readonly if False'
                    // they will be overwritten by reusable script condition and conditionType will be set
                    // to 'Hide if False'
                    const inheritedShowProp = child.inheritShowProp;
                    let eleShowProp = child.propSetMap.show;

                    if (inheritedShowProp !== undefined && inheritedShowProp !== null) {
                        if (inheritedShowProp && inheritedShowProp.group && inheritedShowProp.group.rules.length === 0) {
                            // do nothing;
                        } else {
                            if (eleShowProp != null) {
                                if (eleShowProp && eleShowProp.group && eleShowProp.group.rules.length === 0) {
                                    child.propSetMap.show = inheritedShowProp;
                                } else {
                                    // merge
                                    const childConditionType = !child.propSetMap.conditionType ? 'Hide if False' : child.propSetMap.conditionType;
                                    if (childConditionType === 'Hide if False') {
                                        child.propSetMap.show = { group: { operator: 'AND', rules: [eleShowProp, inheritedShowProp] } };
                                    } else {
                                        child.propSetMap.show = inheritedShowProp;
                                        child.propSetMap.conditionType = 'Hide if False';
                                    }
                                }
                            } else {
                                child.propSetMap.show = inheritedShowProp;
                            }
                        }
                    }
                }
            });
        }

        if (this.jsonDef && this.jsonDef.propSetMap.persistentComponent) {
            const persistentComponent = this.jsonDef.propSetMap.persistentComponent;

            for (let i = 0; i <= persistentComponent.length; i++) {
                if (
                    persistentComponent[i] &&
                    persistentComponent[i].id &&
                    persistentComponent[i].id === 'vlcKnowledge' &&
                    persistentComponent[i].render
                ) {
                    kbIndex = i;
                    this._dispOutsideOmni = this.jsonDef.propSetMap.persistentComponent[i].dispOutsideOmni;
                }
            }
        }

        this._isKbEnabledOnScript = !this._isDesignMode && kbIndex >= 0 && !this._dispOutsideOmni ? true : false;
        this.scriptHeaderDef = {
            ...this.scriptHeaderDef,
            labelMap: this.jsonDef.labelMap,
            propSetMap: this.jsonDef.propSetMap,
            hasInvalidElements: false,
            omniscriptKey: this.jsonDef.bpType + '_' + this.jsonDef.bpSubType + '_' + this.jsonDef.bpLang,
            multiLang: this.jsonDef.bpLang === 'Multi-Language',
            filesMap: this._bSflFilesMap || {},
            sOmniScriptId: this.jsonDef.sOmniScriptId,
            uuid: generateUUID(),
            apiUiElements: apiUiElements,
            aggElements: aggElements,
            kbIndex: kbIndex,
            rMap: this.jsonDef.rMap,
            networkUrlPathPrefix: (this._systemInfo && this._systemInfo.networkUrlPathPrefix) || '',
            isCommunity: (this._systemInfo && this._systemInfo.isCommunity === 'true') || false,
            communityBaseUrl: (this._systemInfo ? this._systemInfo.communityBaseUrl : '') || '',
            bpLang: this.jsonDef.bpLang,
            bpType: this.jsonDef.bpType,
            bpSubType: this.jsonDef.bpSubType,
            bpVersion: this.jsonDef.bpVersion,
        };

        if (this.resume) {
            this.allCustomLabelsUtil = Object.assign({}, this.allCustomLabelsUtil, this.jsonDef.labelKeyMap);
            if (this.jsonDef.labelKeyMap) {
                // simply for saveforlater
                this.jsonDef.labelKeyMap = Object.keys(this.jsonDef.labelKeyMap).reduce((accumulator, current) => {
                    accumulator[current] = '';
                    return accumulator;
                }, {});
            }
        }
        this.scriptHeaderDef.allCustomLabels = this.allCustomLabelsUtil;
        if (Object.getOwnPropertyNames(this.allCustomLabelsUtil).length > this._staticLabelCt) {
            this.scriptHeaderDef.extraL = true;
        }

        // Delete the network path to prevent being displayed on the data json
        if (this._systemInfo) {
            if (this._systemInfo.networkUrlPathPrefix !== undefined) {
                delete this._systemInfo.networkUrlPathPrefix;
            }
            if (this._systemInfo.isCommunity !== undefined) {
                delete this._systemInfo.isCommunity;
            }
            if (this._systemInfo.communityBaseUrl !== undefined) {
                delete this._systemInfo.communityBaseUrl;
            }
        }

        const customLabelErr = this.allCustomLabelsUtil.messages;
        if (customLabelErr && Array.isArray(customLabelErr)) {
            // invalid custom label
            if (this.runMode === RUN_MODES.PLAYER && !isOffPlatform()) {
                // show toast in lightning experience/aura wrapper
                showToast(
                    {
                        title: this.allCustomLabelsUtil.OmniCustomLabelError,
                        message: customLabelErr[0].message,
                        variant: 'error',
                        mode: 'sticky',
                    },
                    this,
                );
            } else if (!this._isDesignMode) {
                // show error modal in preview
                this.displayModal({
                    modalHeader: this.allCustomLabelsUtil.OmniCustomLabelError,
                    modalMessage: customLabelErr[0].message,
                });
            }
        }
    }

    /**
     * @scope private
     * @description Initializes step indexes.
     * @returns {Void}
     */
    initStepIndexes() {
        const stepArr = this.jsonDef.children.filter(child => child.type === 'Step');

        if (stepArr.length > 0) {
            this._lastStepIndex = stepArr[stepArr.length - 1].indexInParent;
            this.scriptHeaderDef.firstStepIndex = stepArr[0].indexInParent;
            stepArr.forEach(step => {
                this._stepNameIndexMap.set(step.name, step.indexInParent);
            });
        }

        this._initialHeaderRender = true;
    }

    /**
     * @scope private
     * @description Initializes JSON definition responses.
     * @returns {Void}
     */
    initJsonDefResponse() {
        // in SFL case, need to reset the asIndex step
        if (
            this.resume &&
            this.jsonDef.asIndex != null &&
            this.jsonDef.children &&
            this.jsonDef.children.length > this.jsonDef.asIndex &&
            this.jsonDef.children[this.jsonDef.asIndex].type === 'Step'
        ) {
            this.jsonDef.children[this.jsonDef.asIndex].bAccordionActive = false;
        }

        // initialization of script Data JSON for new script
        // prefill + designer seedDataJSON
        // prefill json for the main omniscript component overwrite designer seedDataJSON
        // example: <c-omniscript-example prefill='\{"contextId":"abc"}'></c-omniscript-example>
        // <c-omniscript-example layout='newport' prefill={testprefill}></c-omniscript-example>
        // new script
        if (this.jsonDef.response == null) {
            this.jsonDef.response = {};

            scriptDataJsonInit(this.prefill, this.jsonDef, this._systemInfo, this.recordId, this._urlParams);
            // merge in system fields (re-visit for SFL)
            this.lodashUtil.mergeWith(this.jsonDef.response, this._systemInfo, this.mergeJSONLogicUtil);

            // merge in paths defined in Custom Lightning Web Component
            this.jsonDef.response = this.lodashUtil.mergeWith(this.jsonDef.lwcVarMap, this.jsonDef.response, this.mergeJSONLogicUtil);
            this.jsonDataStr = JSON.stringify(this.jsonDef.response);
            this._elementValueObj = JSON.parse(this.jsonDataStr);
        } else if (this.resume) {
            this.lodashUtil.mergeWith(this._elementValueObj, this._systemInfo, this.mergeJSONLogicUtil);
            this.jsonDataStr = JSON.stringify(this._elementValueObj);
            this.jsonDef.response = this._elementValueObj;
            this.lodashUtil.mergeWith(this.jsonDef, this._systemInfo, this.mergeJSONLogicUtil);
        }

        this.dispatchOmniEventUtil(this, this.createAggregateNode(), 'omniaggregate');

        // establish link to jsonData
        this._jsonData = this.jsonDef.response;
    }

    /**
     * @scope private
     * @description Handles step chart responsive layouts. Only applicable when theme ≠ nds
     * @param {Event} [evt]
     * @returns {Void}
     */
    handleStepChartLayout(evt) {
        if (evt && evt.matches) {
            this.stepChartProps.layout = 'vertical';
            this.stepChartProps.position = this.jsonDef.propSetMap.stepChartPlacement;
        } else if (window.matchMedia('(max-width: 47.99em)').matches) {
            this.stepChartProps.layout = 'horizontal';
            this.stepChartProps.position = 'top';
        } else {
            switch (this.jsonDef.propSetMap.stepChartPlacement) {
                case 'right': {
                    this.stepChartProps.layout = 'vertical';
                    this.stepChartProps.position = this.jsonDef.propSetMap.stepChartPlacement;
                    break;
                }
                case 'left': {
                    this.stepChartProps.layout = 'vertical';
                    this.stepChartProps.position = this.jsonDef.propSetMap.stepChartPlacement;
                    break;
                }
                default: {
                    // do nothing
                }
            }
        }

        this.stepChartProps = Object.assign({}, this.stepChartProps); // refresh
    }

    /**
     * @scope private
     * @description Adds event listeners for step chart responsiveness. Only applicable when theme ≠ nds.
     * @returns {Void}
     */
    setStepChartResponsiveHandlers() {
        if (this._theme !== 'nds') {
            if (this.jsonDef.propSetMap.stepChartPlacement === 'top') {
                // responsive event listeners are not required as horizontal layout is responsive by design
                this.stepChartProps = {
                    layout: 'horizontal',
                    position: 'top',
                };
            } else {
                // stores a single instance of the global matchMedia listener, if not already defined
                this.matchMedia = this.matchMedia || window.matchMedia('(min-width: 47.99em)');
                this.stepChartModeHandler = this.handleStepChartLayout.bind(this);
                this.matchMedia.addListener(this.stepChartModeHandler);

                // initial invoke of listener
                this.handleStepChartLayout();
            }
        }
    }

    /**
     * @description Handles time tracking for Actions. This method will create Tracking Entries. Events are received
     *              from omniscriptActionCommonUtil.
     * @param {Object} trackingEventData
     */
    handleActionTimeTrackingEventData(trackingEventData) {
        handleTimeTracking(this, trackingEventData.component, trackingEventData.element, trackingEventData.data, false);
    }

    /**
     * @scope private
     * @description Overwrites native disconnectedCallback.
     * @returns {Void}
     */
    disconnectedCallback() {
        if (this.jsonDef.hasRestartAction) {
            this.removeEventListener('restartscript', this.handleRestart);
        }
        // Removes matchMedia listeners
        if (this.matchMedia && this.stepChartModeHandler) {
            this.matchMedia.removeListener(this.stepChartModeHandler);
        }

        if (this._handleCustomSaveStateObj) {
            pubsub.unregister(this.scriptHeaderDef.uuid + 'omnicustomsavestate', this._handleCustomSaveStateObj);
        }

        if (this._handleActionBtnEventObj) {
            pubsub.unregister(this.scriptHeaderDef.uuid + 'omniactionbtn', this._handleActionBtnEventObj);
        }

        if (this._handleActionTimeTrackingDataObj) {
            pubsub.unregister(`${this.scriptHeaderDef.uuid}omnitimetrackingdata`, this._handleActionTimeTrackingDataObj);
        }

        if (this.beforeUnloadHandler) {
            window.removeEventListener('beforeunload', this.beforeUnloadHandler);
        }
    }

    /**
     * @scope private
     * @description Overwrites inherited renderedCallback.
     * @returns {Void}
     */
    renderedCallback() {
        if (this._initialHeaderRender) {
            // Process navigation when children is populated
            if (this.jsonDef.children && this.jsonDef.children.length > 0) {
                // Show comp immediately if seo mode is disabled.
                this.showComp(!this._isSeoEnabled);
                this.cancelAction = this.template.querySelector('[data-omni-key="CANCEL"]');
                // Set a default cancel behavior for inline OmniScripts.
                if (this.inline && !this.cancelAction) {
                    this.cancelAction = this.template.querySelector('[data-omni-key="DEFAULT-CANCEL"]');
                }

                if (this.cancelAction) {
                    const labelSource = this.cancelAction.jsonDef
                        ? this.cancelAction.jsonDef.propSetMap.label
                        : this.allCustomLabelsUtil.OmnicancelLabel;

                    this.cancelLabel = this._multiLang ? handleOotbLabel(labelSource, 'cancelLabel', this.allCustomLabelsUtil) : labelSource;
                }

                // Set a default done behavior for inline OmniScripts.
                if (this.inline) this._doneAction = this.template.querySelector('[data-omni-key="DEFAULT-CANCEL"]');

                // because this happens on every renderedcallback this can end up in an infinite loop
                // of schedule refreshes. Therefore let's only re-assign if any of the class lists changed
                let scheduleNavButtonRefresh = false;
                const newPreviousClassList = `omniscript-btn-previous ${this._theme}-size_12-of-12 ${this._theme}-m-bottom_x-small`;
                if (newPreviousClassList !== this.navButton.previous.classes) {
                    this.navButton.previous.classes = newPreviousClassList;
                    scheduleNavButtonRefresh = true;
                }
                const newNextClassList = `omniscript-btn-next ${this._theme}-size_12-of-12 ${this._theme}-m-bottom_x-small`;
                if (newNextClassList !== this.navButton.next.classes) {
                    this.navButton.next.classes = newNextClassList;
                    scheduleNavButtonRefresh = true;
                }
                const newSaveClassList = `omniscript-btn-save-for-later`;
                if (newSaveClassList !== this.navButton.save.classes) {
                    this.navButton.save.classes = newSaveClassList;
                    scheduleNavButtonRefresh = true;
                }
                if (scheduleNavButtonRefresh) {
                    this.navButton = Object.assign({}, this.navButton); // refresh
                }

                switch (true) {
                    case this.resume && this.jsonDef.expired !== true:
                        this._targetIndex = this.jsonDef.asIndex || 0;
                        break;
                    case this.resume && this.jsonDef.expired:
                        this._targetIndex = 0;
                        break;
                    case this._isSeoEnabled && this._urlParams.hasOwnProperty('step'):
                        this._targetIndex = this._stepNameIndexMap.get(this._urlParams.step);
                        break;
                    case this._isSeoEnabled && !this._urlParams.hasOwnProperty('step'):
                        this._targetIndex = 0;
                        this._urlParams.step = this._stepNameIndexMap.keys().next().value;
                        history.replaceState({ ...history.state }, null, `${location.pathname}${stringifyParams(this._urlParams)}`);
                        break;
                    case this._isDesignMode:
                        // if we're in design mode we already set the asIndex value.
                        this._targetIndex = this.jsonDef.asIndex || 0;
                        break;
                    default:
                        this._targetIndex = 0;
                }

                switch (true) {
                    case this._isSeoEnabled:
                        this.triggerStepChange(this._targetIndex);
                        break;
                    case this.inline:
                        this.setScriptVisibility(false);
                        break;
                    default:
                        this.navigateTo(this._targetIndex || 0, -1);
                }

                this.setStepChartResponsiveHandlers();
                this.applyContentWidth();
            }

            this.compLoaded = true;
            this._initialHeaderRender = false;

            // Queries and stores the <article> component which will be utilized to reset the positioning of the OmniScript
            if (!this._resetPositionComp) {
                this._resetPositionComp = this.template.querySelector('article');

                // Set the tabindex to the <article> component for accessibility so that it can be focused but not
                // focusable via keyboard
                if (this._resetPositionComp && this._resetPositionComp.setAttribute) {
                    this._resetPositionComp.setAttribute('tabindex', '-1');
                }
            }

            // Cache the value of the messagingEnabled for the scriptHeaderDef
            if (!this._isDesignMode && this.scriptHeaderMessagingEnabled == null) {
                this.scriptHeaderMessagingEnabled = this.evaluateMessagingUtil(
                    this.scriptHeaderDef.propSetMap,
                    this.scriptHeaderDef.omniAnalyticsEnabled,
                );
            }

            if (this.scriptHeaderMessagingEnabled === true) {
                // Stores the time when OmniScript it fully loaded
                const readyTime = Date.now();

                // Fire messaging for OS Invoke or OS Resume
                this.handleMessagingUtil(
                    this,
                    'omniscript_loaded',
                    {
                        ReadyTime: readyTime,
                        StartTime: this._startTime,
                        LoadDuration: readyTime - this._startTime,
                        Resume: this.resume,
                    },
                    null,
                    this.resume === false ? 'OS Invoke' : 'OS Resume',
                );
            }

            // Log OmniStudio Usage events during runtime for new OmniScripts only
            if (!this._isDesignMode && !this.resume && this.scriptHeaderDef) {
                logOmniscriptUsageEvent(this.scriptHeaderDef.omniscriptKey, this.scriptHeaderDef.sOmniScriptId);
            }
        }
    }

    /**
     * @scope private
     * @description Applies content widths for the omniscript step container. Support slds step chart placement.
     * @returns {Void}
     */
    applyContentWidth() {
        if (!this._isDesignMode && this._theme !== 'nds') {
            if (!this.jsonDef.propSetMap.hideStepChart || this.isKnowledgeEnabled()) {
                this._sideContentClasses = 'omniscript-side-content slds-col slds-m-top_x-small slds-size_1-of-1';

                switch (this.jsonDef.propSetMap.stepChartPlacement) {
                    case 'left': {
                        this._sideContentClasses += ` ${this._theme}-medium-size_1-of-4`;
                        this.contentSldsClass += ` ${this._theme}-medium-size_3-of-4`;
                        break;
                    }
                    case 'right': {
                        this._sideContentClasses += ` ${this._theme}-medium-size_1-of-4`;
                        this.contentSldsClass += ` ${this._theme}-medium-size_3-of-4`;
                        break;
                    }
                    default: {
                        // do nothing
                    }
                }
            } else if (this.scriptHeaderDef.kbIndex >= 0) {
                // If KB is enabled on script header but not on step then setting classes back to initial.
                this._sideContentClasses = 'omniscript-side-content slds-col slds-m-top_x-small slds-size_1-of-1';
                this.contentSldsClass =
                    'omniscript-body slds-card__body slds-card__body_inner slds-m-top_medium slds-p-right_medium slds-col slds-grid slds-grid_vertical slds-size_1-of-1';
            }
        }
    }

    /**
     * @scope private
     * @description Updates the prev and next button labels and classes based on current step, can only be called after rendering
     * @param {Integer} newIndex
     * @param {Integer} currentIndex
     * @returns {Void}
     */
    updateButtons(newIndex, currentIndex = 0) {
        const currStepJsonDef = this.jsonDef.children[newIndex];
        const oldStepJsonDef = this.jsonDef.children[currentIndex] ? this.jsonDef.children[currentIndex] : null;

        if (currStepJsonDef) {
            ['previous', 'next', 'save'].forEach(btnType => {
                let label = currStepJsonDef.propSetMap[`${btnType}Label`];
                if (this._multiLang) {
                    label = handleOotbLabel(label, `${btnType}Label`, this.allCustomLabelsUtil);
                }
                this.navButton[btnType].label = label;
                this.navButton = Object.assign({}, this.navButton); // refresh

                const newWidth = currStepJsonDef.propSetMap[`${btnType}Width`];
                if (newWidth) {
                    // in design mode when we change the width we force a refresh this means that comparing the old
                    // width doesn't work because the propSetMap already includes the new value, so we'll just remove any old size classes.
                    if (this._isDesignMode) {
                        const existingClasses = this.navButton[btnType].classes.split(' ');
                        this.navButton[btnType].classes = existingClasses
                            .filter(clz => {
                                return !/-medium-size_/.test(clz);
                            })
                            .concat([`${this._theme}-medium-size_${newWidth}-of-12`])
                            .join(' ');
                        this.navButton = Object.assign({}, this.navButton); // refresh
                    } else {
                        // remove next class
                        const oldWidth = oldStepJsonDef ? oldStepJsonDef.propSetMap[`${btnType}Width`] : null;

                        // updates navigation button classes if the control widths are different or on initial render
                        if (oldWidth !== newWidth || this._initialHeaderRender || currentIndex === 0) {
                            this.navButton[btnType].classes = this.navButton[btnType].classes.replace(
                                `${this._theme}-medium-size_${oldWidth}-of-12`,
                                '',
                            );
                            this.navButton[btnType].classes += ` ${this._theme}-medium-size_${newWidth}-of-12`;
                            this.navButton = Object.assign({}, this.navButton); // refresh
                        }
                    }
                }
            });
        }
    }

    /**
     * @scope private
     * @description Method that gets the immediate step's index in the given direction.
     * @param {number} currentIndex
     * @param {'prev'|'next'} direction
     * @return {number}
     */
    getAdjacentIndex(currentIndex, direction = 'prev') {
        const incrementor = direction === 'prev' ? -1 : 1;
        currentIndex = currentIndex + incrementor;

        while (
            this.jsonDef.children[currentIndex].type !== 'Step' ||
            (this.jsonDef.children[currentIndex].bShow !== undefined && this.jsonDef.children[currentIndex].bShow !== true)
        ) {
            currentIndex = currentIndex + incrementor;
        }

        return currentIndex;
    }

    /**
     * @scope private
     * @description Method that gets the immediate previous step's index.
     * @param {number} currentIndex
     * @return {number}
     */
    getPrevStepIndex(currentIndex) {
        return this.getAdjacentIndex(currentIndex, 'prev');
    }

    /**
     * @scope private
     * @description Method that gets the immediate next step's index.
     */
    getNextStepIndex(currentIndex) {
        return this.getAdjacentIndex(currentIndex, 'next');
    }

    /**
     * @scope private
     * @description Calculates if a previous step is available.
     * @param {Integer} index
     * @return {Boolean}
     */
    hasPrevStep(index) {
        if (index > this.scriptHeaderDef.firstStepIndex) {
            for (let i = index - 1; i >= 0; i--) {
                if (
                    this.jsonDef.children[i].type === 'Step' &&
                    (this.jsonDef.children[i].bShow === undefined || this.jsonDef.children[i].bShow === true)
                ) {
                    return true;
                }
            }

            return false;
        }

        return false;
    }

    /**
     * @scope private
     * @description Calculates if a next step is available.
     * @param {Integer} index
     * @return {Boolean}
     */
    hasNextStep(index) {
        if (index < this.jsonDef.children.length - 1) {
            for (let i = index + 1; i < this.jsonDef.children.length; i++) {
                if (this.jsonDef.children[i].bShow === undefined || this.jsonDef.children[i].bShow === true) {
                    return true;
                }
            }

            return false;
        }

        return false;
    }

    /**
     * @scope private
     * @description Click handler for the previous step navigation.
     * @param {Event} evt
     * @returns {Void}
     */
    prevStep(evt) {
        if (evt && Number.isInteger(evt.target.value)) {
            this.handleErrorModal(evt.target.value);
        }

        this.navigateToPrev();
    }

    /**
     * @scope private
     * @description Click handler for the next step navigation.
     * @param {Event} evt
     * @returns {Void}
     */
    nextStep(evt) {
        if (evt && Number.isInteger(evt.target.value)) {
            this.handleErrorModal(evt.target.value);
        }

        window.console.log('client validation next ' + Object.keys(this.invalidElements).length);

        if (this.hasNextStep(this.jsonDef.asIndex)) {
            const canNavigate = this.navigateTo(this.jsonDef.asIndex + 1, this.jsonDef.asIndex);

            // Save for later on next step
            const propSet = this.scriptHeaderDef.propSetMap;
            if (canNavigate === true && propSet.allowSaveForLater === true && propSet.autoSaveOnStepNext === true) {
                // this.performSaveForLater(true);
            }
        } else if (this.jsonDef.asIndex !== this._lastExecutedStepIndex) {
            // syncs the root index to the last executed step index if the next step is not navigatable
            this.jsonDef.asIndex = this.scriptHeaderDef.asIndex = this._lastExecutedStepIndex;
            this.scriptHeaderDef.asName = this.jsonDef.children[this._lastExecutedStepIndex].name;

            // removes the next and previous buttons
            this.hasNext = false;
            this.hasPrev = false;

            if (this._isDesignMode) {
                this.dispatchEvent(
                    new CustomEvent('omnistepchange', {
                        bubbles: true,
                        composed: true,
                        detail: this.jsonDef.asIndex,
                    }),
                );
            }
        }
    }

    /**
     * @scope private
     * @description Handles previous step navigation
     * @returns {Void}
     */
    navigateToPrev() {
        if (this._isSeoEnabled) this._targetIndex = null; // If the script is running in SEO enabled mode, make sure to remove the _targetIndex.
        if (this.hasPrevStep(this.jsonDef.asIndex)) {
            this.navigateTo(this.getPrevStepIndex(this.jsonDef.asIndex), this.jsonDef.asIndex);
        }
    }

    /**
     * @scope private
     * @description Handles the functionality behind error modals.
     * @param {Integer} index
     * @returns {Void}
     */
    handleErrorModal(index) {
        const modalComp = this.template.querySelectorAll('[data-omni-key=omnimodal]');

        // closes current modal
        modalComp[index].closeModal();

        if (modalComp[index + 1]) {
            // opens modal
            modalComp[index + 1].openModal();
        } else {
            // clears modal
            this.modalEvents = [];
        }
    }

    /**
     * @scope private
     * @description Event handler that marks inputs as valid.
     * @param {Event} evt
     * @returns {Void}
     */
    markInputAsValid(evt) {
        super.markInputAsValid(evt);

        // updates validation flag that is visible to all elements
        this.scriptHeaderDef.hasInvalidElements = Object.keys(this.invalidElements).length > 0;
    }

    /**
     * @scope private
     * @description Event handler that marks inputs as invalid.
     * @param {Event} evt
     * @returns {Void}
     */
    markInputAsInvalid(evt) {
        super.markInputAsInvalid(evt);

        // updates validation flag that is visible to all elements
        this.scriptHeaderDef.hasInvalidElements = Object.keys(this.invalidElements).length > 0;
    }

    /**
     * @scope private
     * @description Main logic that controls navigation regardless of whether the next index is an action or step. If
     *              handling navigation directly to the immediate next or previous step, consider the nextStep or
     *              prevStep methods, respectively.
     * @param {Integer} nextIndex
     * @param {Integer} currentIndex
     * @returns {Boolean}
     */
    navigateTo(nextIndex, currentIndex = 0) {
        const canNavigate = this.checkNav(nextIndex, currentIndex === -1 ? 0 : currentIndex);

        // When navigation is allowed, reset validation and OmniScript position
        if (canNavigate) {
            Object.values(this.invalidElements).forEach(step => {
                if (step && typeof step.clearInvalid === 'function') {
                    step.clearInvalid();
                }
            });
            this.invalidElements = {};
            this.scriptHeaderDef.hasInvalidElements = false;
            this.resetOmniScriptPosition(nextIndex, currentIndex);

            // In Design Mode, set the lastExecutedStepIndex to the current index coming in so that the Designer can
            // deactivate the last selected Step, if applicable
            if (this._isDesignMode) {
                this._lastExecutedStepIndex = currentIndex;
            }
        }

        //* Navigation logic - navigate forward when next element is Cancel Action
        if (canNavigate && this.jsonDef.children[nextIndex] && this.jsonDef.children[nextIndex].type === 'Cancel Action') {
            this.navigateTo(nextIndex + 1, nextIndex);
        }
        //* Navigation logic - when next element is not last and no error messages are present
        else if (canNavigate && this.jsonDef.children[nextIndex]) {
            const bShow = this.jsonDef.children[nextIndex].bShow;

            // updates global index
            this.jsonDef.asIndex = this.scriptHeaderDef.asIndex = nextIndex;
            this.scriptHeaderDef.asName = this.jsonDef.children[nextIndex].name;

            if (bShow === undefined || bShow === true) {
                // condition - when next element is a step
                if (this.jsonDef.children[nextIndex].type === 'Step') {
                    this.updateButtons(nextIndex, this._lastExecutedStepIndex);
                    this.updateStep(nextIndex, this._lastExecutedStepIndex);

                    if (this._isSeoEnabled === false) {
                        this.isPageLoading = false;
                    } else {
                        if (this._targetIndex > this.jsonDef.asIndex) {
                            delay(100).then(() => this.navigateTo(this.jsonDef.asIndex + 1, this.jsonDef.asIndex));
                        } else {
                            document.title = getStepLabel(this.jsonDef.children[this.jsonDef.asIndex], this._multiLang, this.allCustomLabelsUtil);

                            this.updateSeoNav();
                            this.showComp(true);
                            this.isPageLoading = false;
                            this._targetIndex = null;
                            if (this.autoSflRequired) {
                                // this.performSaveForLater(true);
                                this.autoSflRequired = false;
                            }
                        }
                    }
                }
                // condition - when next element is an action
                else {
                    const actionKey = this.jsonDef.children[nextIndex].name;
                    const actionComp = this.queryOmniCompUtil(this, actionKey);

                    if (actionComp) {
                        // Removes content from previous Step from the DOM and turns off previous Step
                        if (this._lastExecutedStepIndex === currentIndex) {
                            this.setStepVisibility(this._lastExecutedStepIndex, false);
                        }

                        // Handles the Action's execution flow
                        this.handleActionExecution(actionComp, nextIndex);
                    }
                }
            }
            //* Navigation logic - navigate to the next index if step/action is hidden
            else {
                this.navigateTo(nextIndex + 1, nextIndex);
            }
        }
        //* Navigation logic - when last element is an action
        else if (canNavigate && !this.jsonDef.children[nextIndex]) {
            this.isPageLoading = false;
            this.updateStep(nextIndex, currentIndex, 'last-action');

            // When a default done is in-order, perform it!
            if (this.inline && nextIndex > -1) {
                this.done();
            } else {
                this.showComp(false);
            }
        }
        //* Navigation logic - navigation is not allowed due to an error
        else if (canNavigate === false) {
            if (this._isSeoEnabled) {
                this.isPageLoading = false;
                this.showComp(true);
            }
            this.handleInvalid();
        }

        if (this._isDesignMode) {
            this.dispatchEvent(
                new CustomEvent('omnistepchange', {
                    bubbles: true,
                    composed: true,
                    detail: this.jsonDef.asIndex,
                }),
            );
        }

        return canNavigate;
    }

    /**
     * @description Resets the OmniScript's positioning when the user navigates. Scroll behavior is defaulted to "auto"
     *              if scrollBehavior is not defined.
     * @param {Integer} nextIndex
     * @param {Integer} currentIndex
     * @returns {void}
     */
    resetOmniScriptPosition(nextIndex, currentIndex) {
        if (
            !this._isDesignMode &&
            this._resetPositionComp &&
            typeof this._resetPositionComp.focus === 'function' &&
            this.jsonDef.propSetMap.scrollBehavior !== 'none'
        ) {
            // On initial load, the OmniScript should not be repositioned. Repositioning should be allowed when the user
            // navigates to a previous Step or navigates to a future Step that is not the first Step.
            if (nextIndex < currentIndex || nextIndex > this.scriptHeaderDef.firstStepIndex) {
                // Put focus the <article> component for accessibility
                this._resetPositionComp.focus({ preventScroll: true });
                // Removes focus immediately after focusing
                this._resetPositionComp.blur();

                // Default scrolling behavior set to "auto" if not configured to "none" and does not accept values
                // that are not "auto" or "smooth"
                window.scrollTo({
                    top: this._resetPositionComp.offsetTop,
                    behavior: this.jsonDef.propSetMap.scrollBehavior === 'smooth' ? 'smooth' : 'auto',
                });
            }
        }
    }

    /**
     * @scope private
     * @description Handles the logic for action execution.
     * @param {*} comp - component
     * @param {Integer} index
     * @returns {Void}
     */
    handleActionExecution(comp, index) {
        const element = this.jsonDef.children[index];
        const invokeMode = element.propSetMap.invokeMode;
        const asyncNavPermitted =
            (element.type === 'Remote Action' || element.type === 'Integration Procedure Action' || element.type === 'Action Block') &&
            (invokeMode === 'fireAndForget' || invokeMode === 'noBlock');

        // evaluate turning on spinner
        this.isPageLoading = this.isPageLoading ? this.isPageLoading : evalSpinnerCond(element);

        // sets spinner action message
        this.spinnerMessage = setSpinnerActionMessage(element);

        //* executes action - both success and failure callback responses will flow through here
        comp.execute().then(response => {
            const bSystemFailure = response && response.systemFailure ? response.systemFailure : false;
            this.handleActionResp(bSystemFailure, response, index);
        });

        // navigates to the next step asynchronously
        if (asyncNavPermitted) {
            this.navigateTo(index + 1, index);
        }
    }

    /**
     * @scope private
     * @description Handles logic after action execution.
     * @param {Boolean} bSystemFailure
     * @param {Object} resp
     * @param {Integer} index
     * @returns {Void}
     */
    handleActionResp(bSystemFailure, resp, index) {
        //* early termination for system failures while invoking action
        if (bSystemFailure) {
            this.isPageLoading = false;
            return;
        }

        switch (this.jsonDef.children[index].propSetMap.invokeMode) {
            case 'fireAndForget':
                // do nothing
                break;
            case 'noBlock':
                // applies response once response is available
                if (resp.error === false) {
                    this.applyCallResp(resp.result, true);
                }
                break;
            default:
                if (resp.error === false) {
                    let apiResponse = resp.result;
                    const apiError = resp.result && resp.result.vlcValidationErrors;
                    if (apiResponse) {
                        delete apiResponse.vlcValidationErrors;
                    }

                    let nextInd = index + 1;
                    let apiPromises = [];

                    // Adds applying api responses to promises to resolve
                    apiPromises.push(Promise.resolve(this.applyCallResp(apiResponse, true)));

                    if (apiError) {
                        const errInd = this.findErrorStep(apiError, index);
                        if (errInd != null) {
                            nextInd = errInd;
                        }

                        // Adds applying api errors to promises to resolve
                        apiPromises.push(Promise.resolve(this.applyCallResp(apiError, true, true)));
                    }

                    //* Navigation logic - Applies response and navigates to next root child
                    Promise.all(apiPromises).then(() => {
                        this.navigateTo(nextInd, index);
                    });
                } else {
                    // turns off spinner if there is an error
                    this.isPageLoading = false;
                }
        }
    }

    findErrorStep(apiError, currIndex) {
        if (apiError) {
            let stepIndexSet = new Set();
            for (let err in apiError) {
                if (err) {
                    let stepName = this.scriptHeaderDef.labelMap[err];
                    stepName = stepName ? stepName.split(':')[0] : stepName;
                    const stepIndex = this._stepNameIndexMap.get(stepName);
                    if (stepIndex != null) {
                        stepIndexSet.add(stepIndex);
                    }
                }
            }
            const stepIndexSortedArray = Array.from(stepIndexSet).sort();
            for (let i = 0; i < stepIndexSortedArray.length; i++) {
                if (stepIndexSortedArray[i] <= currIndex && this.checkNav(stepIndexSortedArray[i], currIndex, false)) {
                    const errStep = this.jsonDef.children[stepIndexSortedArray[i]];
                    const bShow = errStep && (errStep.bShow === undefined || errStep.bShow);
                    if (bShow) {
                        return stepIndexSortedArray[i];
                    }
                }
                if (currIndex < stepIndexSortedArray[i]) {
                    return null;
                }
            }
        }
        return null;
    }

    /**
     * @scope private
     * @description Event handler for Save for Later that is triggered by custom components.
     * @param {Event} The custom omnisavedforlater event
     * @returns {Void}
     */
    handleSavedForLater(evt) {
        evt.stopPropagation();

        // Update jsonDef with new values
        this.jsonDef.sInstanceId = evt.detail.instanceId;
        this.jsonDef.response.sInstanceId = evt.detail.instanceId;
        this.jsonDef.sflTimestamp = evt.detail.sflTimestamp;
    }

    /**
     * @scope private
     * @description Updates the step content for both the previous and next steps, as needed. The current step should
     *              always be hidden first before the next step is made visible.
     * @param {Integer} nextIndex
     * @param {Integer} currentIndex
     * @returns {Void}
     */
    updateStep(nextIndex, currentIndex, from) {
        // When from == null, nextIndex is always a visible step
        const allowSfl = this.jsonDef.propSetMap.allowSaveForLater;
        const performAutoSfl = allowSfl && this.jsonDef.propSetMap.autoSaveOnStepNext;

        // We need to make sure we come from visible step into visible step
        const comesFromStep = this.jsonDef.children[currentIndex] && this.jsonDef.children[currentIndex].type === 'Step';

        // When from == 'last-action', then currentIndex == this.jsonDef.children.length - 1; so, nextIndex is out of boundaries

        // Hides currentIndex Step. In Design Mode, the previously visited Step should always be deactivated for the
        // current Step element card
        if (
            (currentIndex >= 0 && currentIndex <= this._lastStepIndex && this.jsonDef.children[currentIndex].bAccordionActive === true) ||
            this._isDesignMode
        ) {
            this.hasNext = nextIndex >= this._lastStepIndex ? false : true;
            this.setStepVisibility(currentIndex, false);
        }

        // makes nextIndex step visible
        if (nextIndex <= this._lastStepIndex && this.jsonDef.children[nextIndex]) {
            const stepProp = this.jsonDef.children[nextIndex].propSetMap;
            // hasPrev and hasNext only control the button visiblity, should be named showPrevBtn, showNextBtn
            this.hasPrev = this.hasPrevStep(nextIndex) && stepProp.previousWidth !== 0;
            this.hasNext = this.hasNextStep(nextIndex) && stepProp.nextWidth !== 0;
            this.setStepVisibility(nextIndex, true);
            this._lastExecutedStepIndex = nextIndex;
            this.allowSfl =
                this.inline === false && allowSfl && this.jsonDef.children[nextIndex].type === 'Step' && stepProp.allowSaveForLater === true;

            if (this.scriptHeaderDef.kbIndex >= 0) {
                this.applyContentWidth(); // Updates content width for incoming step
            }
        } else {
            this.hasNext = false;
            this.hasPrev = false;
        }

        const outOfBoundaries = nextIndex > this.jsonDef.children.length - 1;
        if (outOfBoundaries) {
            this.allowSfl = false;
        }
        if (performAutoSfl && nextIndex > currentIndex) {
            let runSfl = false;
            if (comesFromStep || from === 'last-action') {
                runSfl = true;
            }
            if (from === 'last-action' && this.resume && this._savedAsIndex === currentIndex) {
                runSfl = false;
            }
            if (runSfl === true) {
                window.console.info('Perform save for later');
                this.performSaveForLater(true);
            }
        }
    }

    /**
     * @scope private
     * @description Sets the step visibility. Updates json definition step visibility flag.
     * @param {Integer} index
     * @param {Boolean} isVisible
     * @returns {Void}
     */
    setStepVisibility(index, isVisible) {
        if (index !== -1) {
            if (this.jsonDef.children[index].type === 'Step') {
                // Sets the bAccordionActive value in accordance with the step visibility.
                // - True => current step visible
                // - False => current step not visible
                this.jsonDef.children[index].bAccordionActive = isVisible;

                // Calculates if step messaging is enabled
                const stepMessagingEnabled = this.evaluateMessagingUtil(
                    this.jsonDef.children[index].propSetMap,
                    this.scriptHeaderDef.omniAnalyticsEnabled,
                );
                const trackingEventsEnabled = stepMessagingEnabled || this.scriptHeaderDef.propSetMap.timeTracking;

                if (isVisible === true) {
                    if (!this._isDesignMode && trackingEventsEnabled) {
                        // st node is used for storing the start time of the Step element
                        this.jsonDef.children[index].st = Date.now();

                        // Store the last time UI displayed a Step or when the OmniScript was invoked
                        this.jsonDef.children[index].swt = this._lastUiDisplayTime;

                        // Reset the last UI Display timestamp
                        this._lastUiDisplayTime = null;
                    }

                    this.scriptHeaderDef.acUiElements = this.jsonDef.children[index].propSetMap.uiElements;
                    this.jsonDef.children[index].bDirty = true;
                    this.jsonDef = Object.assign({}, this.jsonDef); // refresh
                } else {
                    // Clears active UI elements so that all element data on previous Steps will be cached
                    this.scriptHeaderDef.acUiElements = {};

                    if (!this._isDesignMode && trackingEventsEnabled && this.jsonDef.children[index].st >= 0) {
                        const stepUnloadTime = Date.now();
                        const stepElapsedTime = stepUnloadTime - this.jsonDef.children[index].st;
                        this._lastUiDisplayTime = stepUnloadTime;

                        // Creates time tracking entry for Step time tracking
                        handleTimeTracking(this, this.jsonDef.children[index], 'StepActionTime', {
                            elapsedTime: stepElapsedTime,
                        });

                        // Fire messaging for Step Unload
                        this.handleMessagingUtil(
                            this,
                            'omniscript_step_unload',
                            {
                                StartTime: stepUnloadTime,
                                ElapsedTime: stepElapsedTime,
                                Resume: this.resume,
                            },
                            this.jsonDef.children[index],
                            'OS Step Unload',
                        );

                        // Reset step time tracking StartTime and StepWaitTime
                        this.jsonDef.children[index].st = null;
                        this.jsonDef.children[index].swt = null;
                    }
                }
            }
        }
    }

    /**
     * @scope private
     * @description Stepchart event handler.
     * @param {Event} evt
     * @returns {Void}
     */
    handleStepChartEvent(evt) {
        if (evt.detail) {
            this.navigateTo(evt.detail.currIndex, evt.detail.prevIndex);
        }
    }

    // TODO: This needs to be updated to allow for calling it directly in the omniscript header without having to go
    // through a dispatched event
    /**
     * @scope private
     * @description Handles all modal events. Generates each modal event as a separate array element to be passed into the markup.
     * @param {Event} evt
     * @returns {Void}
     */
    handleModalEvent(evt) {
        if (evt.detail) {
            const defaultButtons = [
                {
                    label: evt.detail.previousLabel,
                    key: '0-' + evt.detail.previousLabel,
                    handleClick: modalEvt => {
                        this.prevStep(modalEvt);
                    },
                },
                {
                    label: evt.detail.dismissLabel,
                    key: '1-' + evt.detail.dismissLabel,
                    handleClick: modalEvt => {
                        this.handleErrorModal(modalEvt.target.value);
                    },
                },
                {
                    label: evt.detail.nextLabel,
                    key: '2-' + evt.detail.nextLabel,
                    handleClick: modalEvt => {
                        this.nextStep(modalEvt);
                    },
                },
            ];

            let buttons = evt.detail.buttons;

            if (evt.detail.closeAfterClick) {
                buttons = this.modifyModalButton(buttons);
            }

            const modalEvent = {
                type: evt.detail.type || 'error',
                modalHeader: evt.detail.header || '',
                modalMessage: evt.detail.message || '',
                buttons: buttons || defaultButtons,
                hideHeader: evt.detail.hideHeader || false,
                hideFooter: evt.detail.hideFooter || false,
                triggeredOnStep: evt.detail.triggeredOnStep,
            };

            const addModalEvent = Promise.resolve(this.modalEvents.push(modalEvent));

            // resolves modal event promise and opens first modal
            Promise.all([addModalEvent]).then(() => {
                // don't show error modals in design mode.
                if (this._isDesignMode) {
                    this.nextStep({
                        target: {
                            value: 0,
                        },
                    });
                } else {
                    this.template.querySelectorAll('[data-omni-key=omnimodal]')[0].openModal();
                }
            });
        }
    }

    /**
     * @scope private
     * @description Modifies the handleClick for each button to close the modal after click.
     * @param {Object[]} oldButtons
     * @returns {Object[]}
     */
    modifyModalButton(oldButtons) {
        let buttons = [];

        for (let i = 0; i < oldButtons.length; i++) {
            let btn = Object.assign({}, oldButtons[i]);
            btn.handleClick = () => {
                if (typeof oldButtons[i].handleClick === 'function') {
                    oldButtons[i].handleClick();
                }

                this.modalEvents = [];
            };
            buttons.push(btn);
        }

        return buttons;
    }

    /**
     * @scope private
     * @description Event Handler for action events.
     * @param {Event} evt
     * @returns {Void}
     */
    handleActionBtnEvent(evt) {
        if (evt.detail) {
            // when step validation is enabled and does not pass, action execution is invalid, trigger validation
            if (evt.detail.triggerValidation) {
                this.reportValidity();
            }
            // valid action execution, apply response
            else {
                let apiResponse = evt.detail.apiResponse;
                const apiError = evt.detail.apiResponse && evt.detail.apiResponse.vlcValidationErrors;
                if (apiResponse) {
                    delete apiResponse.vlcValidationErrors;
                }

                if (evt.detail.overwrite) {
                    this.jsonDef.propSetMap.seedDataJSON = {};
                }

                this.applyCallResp(apiResponse, true);

                if (apiError) {
                    const currIndex = this.jsonDef.asIndex;
                    const destIndex = this.findErrorStep(apiError, currIndex);
                    // this.applyCallResp(apiError, true, true);
                    if (destIndex != null) {
                        if (destIndex === this.jsonDef.asIndex) {
                            this.applyCallResp(apiError, true, true);
                        } else if (destIndex < this.jsonDef.asIndex) {
                            Promise.resolve(this.navigateTo(destIndex, this.jsonDef.asIndex)).then(() => {
                                this.applyCallResp(apiError, true, true);
                            });
                        }
                    }
                }
            }
        }
    }

    /**
     * @scope private
     * @description Event handler for auto advance.
     * @param {Event} evt
     * @returns {Void}
     */
    handleAutoAdv(evt) {
        Promise.resolve().then(() => {
            if (evt.detail != null) {
                evt.stopPropagation();

                if (evt.detail.moveToStep === 'next') {
                    this.nextStep();
                } else if (evt.detail.moveToStep === 'previous') {
                    this.prevStep();
                } else {
                    const index = this.handleIndexByValue(evt.detail.moveToStep);

                    if (index >= 0) {
                        this.navigateTo(index, this.jsonDef.asIndex);
                    }
                }
            }
        });
    }

    /**
     * @scope private
     * @description Returns index for a specific step name.
     * @param {*} value
     * @returns {Integer}
     */
    handleIndexByValue(value) {
        // if value is a number return immediately
        if (!isNaN(Number(value))) {
            return Number(value);
        }

        for (let i = 0; i < this.jsonDef.children.length; i++) {
            let child = this.jsonDef.children[i];

            if (child.name === value) {
                // if we find the child with the same name then return it's index.
                return i;
            }
        }

        // if we don't find a match then return -1.
        return -1;
    }

    /**
     * @scope private
     * @description Event handler that updates bShow for root elements
     * @param {Event} evt
     * @returns {Void}
     */
    handleOmniSetShow(evt) {
        this.updateJsonDefUtil(
            this.jsonDef,
            [
                {
                    value: evt.detail.value,
                    path: evt.detail.path,
                },
            ],
            'bShow',
        );
        if (this.jsonDef.children[this.jsonDef.asIndex]) {
            const stepProp = this.jsonDef.children[this.jsonDef.asIndex].propSetMap;
            // hasPrev and hasNext only control the button visiblity, should be named showPrevBtn, showNextBtn
            this.hasPrev = this.hasPrevStep(this.jsonDef.asIndex) && stepProp.previousWidth !== 0;
            this.hasNext = this.hasNextStep(this.jsonDef.asIndex) && stepProp.nextWidth !== 0;
        }

        this.jsonDef = Object.assign({}, this.jsonDef); // refresh
    }

    /**
     * @scope private
     * @description Event handler that handles custom LWC save state.
     * @param {Event} data
     * @returns {Void}
     */
    handleCustomSaveState(data) {
        const detail = data && data.detail ? data.detail : data;

        if (detail) {
            if (this.jsonDef) {
                if (!this.jsonDef.customSaveState) {
                    this.jsonDef.customSaveState = {};
                }

                if (detail.operation === 'clearState' && detail.keyList && Array.isArray(detail.keyList)) {
                    for (let i = 0; i < detail.keyList.length; i++) {
                        // delete this.jsonDef.customSaveState[detail.keyList[i]];
                        if (this.jsonDef.customSaveState[detail.keyList[i]]) {
                            this.jsonDef.customSaveState[detail.keyList[i] + '-$Vlocity.cleared'] = true;
                        }
                    }
                } else if (detail.elementId) {
                    this.jsonDef.customSaveState[detail.elementId] = detail.data;
                    delete this.jsonDef.customSaveState[detail.elementId + '-$Vlocity.cleared'];
                }
            }
        }
    }

    /**
     * @scope private
     * @description Event handler for formatting data.
     * @param {Event} evt
     * @returns {Void}
     */
    handleFormattedData(evt) {
        if (evt && evt.detail && this.jsonDef.response) {
            this._elementValueObj[OMNISCRIPTFORMATTEDDATAJSON] = this._elementValueObj[OMNISCRIPTFORMATTEDDATAJSON] || {};
            this._elementValueObj[OMNISCRIPTFORMATTEDDATAJSON][evt.detail.node] = evt.detail.value;
            this.jsonDef.response = Object.assign({}, this._elementValueObj);
        }
    }

    /**
     * @scope private
     * @description Provides a check between current step index and incoming index (index) to ensure that navigation is permitted.
     * @param {Integer} nextIndex
     * @param {Integer} currIndex
     * @returns {Boolean}
     */
    checkNav(nextIndex, currIndex, showModal = true) {
        if (this._isDesignMode) {
            // make sure the nextIndex we're moving too is still valid
            // it can become invalid if we deleted the last step.
            return nextIndex <= this.jsonDef.children.length - 1;
        }
        let errorMsg = this.allCustomLabelsUtil.OmniNavigationError1;

        // there are updates (editblock in edit mode, etc)
        if (this._pendingUpdates > 0) {
            errorMsg = this.allCustomLabelsUtil.OmniPendingUpdatesError;
        }
        // previous navigation is permitted
        else if (nextIndex <= currIndex) {
            return true;
        }
        // resume is permitted
        else if (this._initialHeaderRender && this.resume) {
            return true;
        }
        // navigation is allowed, run validation
        else if (nextIndex === currIndex + 1) {
            return this.reportValidity();
        }

        if (showModal) {
            // when navigation is not allowed, throw modal
            const addModalEvent = Promise.resolve(
                this.modalEvents.push({
                    type: 'error',
                    modalHeader: 'Error',
                    modalMessage: errorMsg,
                    buttons: [
                        {
                            label: this.allCustomLabelsUtil.OmniOK,
                            key: '0-Ok',
                            handleClick: () => {
                                this.modalEvents = [];
                            },
                        },
                    ],
                    hideHeader: false,
                    hideFooter: false,
                    triggeredOnStep: true,
                }),
            );

            // resolves modal event promise and opens first modal
            Promise.all([addModalEvent]).then(() => {
                const modals = this.template.querySelectorAll('[data-omni-key=omnimodal]');
                if (modals.length > 0) {
                    modals[0].openModal();
                }
            });
        }

        return false;
    }

    /**
     * Will perform the configured cancel action or,
     * when this.inline is true, the default cancel action.
     * @scope private
     * @returns {Promise<any>}
     */
    cancel() {
        return Promise.resolve(this.cancelAction)
            .then(cancelAction => {
                // When a cancel action is user defined, it will have a cancelMethod.
                if (cancelAction.cancel) return this.cancelAction.cancel();
                // Otherwise cancel was called by an inline omniscript.
                return Promise.resolve(OmniscriptCancelAction.DEFAULT_CANCEL_RESOLVED);
            })
            .then(result => {
                if (result === OmniscriptCancelAction.CANCEL_RESOLVED || result === OmniscriptCancelAction.DEFAULT_CANCEL_RESOLVED) {
                    const currentElement = this.jsonDef.children[this.jsonDef.asIndex];

                    // Create time tracking entry for Cancel outcome
                    handleTimeTracking(this, currentElement, 'Outcome', { outcome: 'Cancel' });

                    // Cache the value determining if cancal messaging is enabled as this value will not change during
                    // the lifespan of the OmniScript
                    if (this._cancelMessagingEnabled == null && result !== OmniscriptCancelAction.DEFAULT_CANCEL_RESOLVED) {
                        this._cancelMessagingEnabled = this.evaluateMessagingUtil(
                            this.cancelAction.jsonDef.propSetMap,
                            this.scriptHeaderDef.omniAnalyticsEnabled,
                        );
                    }

                    // Fire messaging for OS Cancel
                    if (this._cancelMessagingEnabled || this.scriptHeaderDef.omniAnalyticsEnabled) {
                        this.handleMessagingUtil(
                            this,
                            'omniscript_cancel',
                            {
                                ElementName: currentElement.name,
                                OmniEleName: currentElement.name,
                                ElementType: currentElement.type,
                                OmniEleType: currentElement.type,
                                ElementLabel: currentElement.propSetMap.label,
                                Resume: this.resume,
                            },
                            this.cancelAction.jsonDef || this.jsonDef,
                            'OS Cancel',
                        );
                    }
                }

                // Turns off the current Step and puts the OmniScript in an intermediary initial state where all Steps are turned off
                this.navigateTo(-1, this.jsonDef.asIndex);

                if (this.inline) {
                    this.resetForm();
                }

                this.setScriptVisibility(false);

                return result;
            })
            .catch(reason => {
                if (reason !== OmniscriptCancelAction.CANCEL_ABORTED && reason !== OmniscriptCancelAction.CANCEL_DISABLED) {
                    throw reason;
                }
            });
    }

    /**
     * The default done action for inline OmniScripts. Executes the same functionality as
     * default cancel, with out the prompt. Fired only when this.inline is true.
     * @todo navigate() must be removed from this functionality
     * @scope private
     * @returns {void}
     */
    done() {
        if (this.inline) this.resetForm();
        this.setScriptVisibility(false);
    }

    /**
     * @description Resets the OmniScript state back to the initial state. This is primarily used for OmniScript Inline
     *              mode.
     */
    resetForm() {
        try {
            this.jsonDef = JSON.parse(this.initialJsonDef);
            this.jsonDataStr = JSON.stringify(this.jsonDef.response);
            this._elementValueObj = JSON.parse(this.jsonDataStr);
            this.scriptHeaderDef = JSON.parse(this.initialScriptHeaderDef);
        } catch (err) {
            console.error(err);
        }
    }

    restartScript() {
        return delay()
            .then(() => {
                this.compLoaded = false;
                this.firstRender = false;
                this.resetForm();

                return delay(500);
            })
            .then(() => {
                this.compLoaded = true;
                this.firstRender = true;
                this._initialHeaderRender = true;
                this._lastExecutedStepIndex = 0;
            });
    }

    //#region SaveForLater

    /**
     * @scope private
     * @description Handles save for later.
     * @returns {Void}
     */
    saveForLater() {
        // Disallow if allowSaveForLater is disabled on jsonDef
        if (this.scriptHeaderDef.propSetMap.allowSaveForLater !== true) {
            return;
        }

        // Disallow if there are still pending updates
        if (this._pendingUpdates > 0) {
            this.displayModal({
                modalMessage: this.allCustomLabelsUtil.OmniPendingUpdatesError,
            });
            return;
        }

        let saveMessage = null;
        const currStepJsonDef = this.jsonDef.children[this._lastExecutedStepIndex];
        if (currStepJsonDef) {
            saveMessage = currStepJsonDef.propSetMap.saveMessage || '';
            if (this._multiLang) {
                saveMessage = handleOotbLabel(saveMessage, 'saveMessage', this.allCustomLabelsUtil);
            }
        }
        saveMessage = saveMessage || this.allCustomLabelsUtils.OmnisaveMessage;

        //TODO (108 consolidate all error modal usage to one function)
        const addModalEvent = Promise.resolve(
            this.modalEvents.push({
                type: 'info',
                modalHeader: this.allCustomLabelsUtil.OmniConfirm,
                modalMessage: saveMessage,
                buttons: [
                    {
                        label: this.allCustomLabelsUtil.Omnicancel,
                        key: '0-Cancel',
                        handleClick: () => {
                            this.modalEvents = [];
                            const saveForLaterButton = this.template.querySelector('.omniscript-btn-save-for-later');
                            if (saveForLaterButton) {
                                saveForLaterButton.focus();
                            }
                        },
                    },
                    {
                        label: this.allCustomLabelsUtil.OmniOK,
                        key: '0-Ok',
                        handleClick: () => {
                            // Remove the modal
                            this.modalEvents = [];
                            this.performSaveForLater(false);
                        },
                    },
                ],
                hideHeader: false,
                hideFooter: false,
                triggeredOnStep: true,
            }),
        );

        // resolves modal event promise and opens first modal
        Promise.all([addModalEvent]).then(() => {
            this.template.querySelectorAll('[data-omni-key=omnimodal]')[0].openModal();
        });
    }

    /**
     * @scope private
     * @description Performs save for later.
     * @param {Boolean} auto
     * @returns {Void}
     */
    performSaveForLater(auto) {
        // Reset the labels
        this.bSflResult = {
            allCustomLabels: this.allCustomLabelsUtil,
        };

        if (!auto) {
            this.compLoaded = false;
            this.showComp(false);
        }

        if (this._bSflInProgress === true) {
            this._bSflQueuedAuto = auto;
            this._bSflQueued = true;
            return;
        }

        this.bSflAuto = auto;
        this._bSflInProgress = true;

        if (this._rtpReq) {
            this.jsonDef.rtpReq = this._rtpReq;
            delete this.jsonDef.rtpReq.LanguageCode;
        }

        saveForLaterUtil(
            this,
            this.jsonDef,
            this.scriptHeaderDef.filesMap,
            this.layout,
            this._bPreview,
            auto,
            this._languageCode,
            this.scriptHeaderDef.isCommunity,
        )
            .then(saveResult => {
                if (!auto) {
                    // hide the component and show the "OmniScript saved"
                    this.bSflComplete = true;
                }

                this.compLoaded = true;
                this.bSflResult = {
                    allCustomLabels: this.allCustomLabelsUtil,
                    value: saveResult,
                };

                // Update jsonDef with new values
                this.jsonDef.sInstanceId = saveResult.instanceId;
                this.jsonDef.sflTimestamp = saveResult.sflTimestamp;

                this.applyCallResp({ sInstanceId: saveResult.instanceId }, false);
            })
            .catch(error => {
                this.compLoaded = true;
                this.showComp(true);
                const errorMessage = handleErrorReplace(error, null, this.scriptHeaderDef);
                this.notifySaveForLaterError(errorMessage);
            })
            .finally(() => {
                this._bSflInProgress = false;

                if (this._bSflQueued === true) {
                    this._bSflQueued = false;
                    this.performSaveForLater(this._bSflQueuedAuto);
                }
            });
    }

    /**
     * @scope private
     * @description Displays a modal with an error from the save for later (We might move this to a helper util for
     *              reuse).
     * @param {String} error
     * @returns {Void}
     */
    notifySaveForLaterError(error) {
        const addModalEvent = Promise.resolve(
            this.modalEvents.push({
                type: 'error',
                modalHeader: 'Error',
                modalMessage: `${error}<br><br>${this.allCustomLabelsUtil.OmniSavedFailed}`,
                buttons: [
                    {
                        label: this.allCustomLabelsUtil.OmniOK,
                        key: '0-Ok',
                        handleClick: () => {
                            this.modalEvents = [];
                        },
                    },
                ],
                hideHeader: false,
                hideFooter: false,
                triggeredOnStep: true,
            }),
        );

        // resolves modal event promise and opens first modal
        Promise.all([addModalEvent]).then(() => {
            this.template.querySelectorAll('[data-omni-key=omnimodal]')[0].openModal();
        });
    }

    /**
     * @scope private
     * @description Handles invalid Safe for Later.
     * @returns {Void}
     */
    handleContinueInvalidSfl() {
        if (this.jsonDef.propSetMap.mergeSavedData === true) {
            this.lodashUtil.mergeWith(this.jsonDef.propSetMap.seedDataJSON, this._bSflPrefill, this.mergeJSONLogicUtil);
            this.jsonDef.filesMap = this._bSflFilesMap;
        }

        this._reloadDef();
    }

    /**
     * @scope private
     * @description Handles a save for later request
     * @param {Object} evt
     * @returns {Void}
     */
    handleSaveForLater(evt) {
        evt.stopPropagation();

        // Disallow if allowSaveForLater is disabled on jsonDef
        if (this.scriptHeaderDef.propSetMap.allowSaveForLater !== true) {
            return;
        }

        // Disallow if there are still pending updates
        if (this._pendingUpdates > 0) {
            this.displayModal({
                modalMessage: this.allCustomLabelsUtil.OmniPendingUpdatesError,
            });
            return;
        }

        const auto = evt.detail.auto || false;
        this.performSaveForLater(auto);
    }

    /**
     * @scope private
     * @description Event handler that is triggered when the save for later is complete.
     * @param {object} evt - The custom omnisavedforlater event
     * @returns {Void}
     */
    handleSaveForLaterComplete(evt) {
        evt.stopPropagation();

        // Update jsonDef with new values
        this.jsonDef.sInstanceId = evt.detail.instanceId;
        this.jsonDef.response.sInstanceId = evt.detail.instanceId;
        this.jsonDef.sflTimestamp = evt.detail.sflTimestamp;
    }

    //#endregion

    /**
     * @scope private
     * @description Handles the filesMap array when a file is uploaded.
     * @param {CustomEvent} evt
     * @returns {Void}
     */
    handleFileUploaded(evt) {
        const detail = evt.detail;

        if (detail.operation === 'delete') {
            const fileId = detail.fileId;

            if (this.scriptHeaderDef.filesMap.hasOwnProperty(fileId)) {
                delete this.scriptHeaderDef.filesMap[fileId];
            }
        } else {
            const files = detail.files;

            files.forEach(file => {
                this.scriptHeaderDef.filesMap[file.data] = file.data;
            });
        }
    }

    /**
     * @scope private
     * @description Reloads JSON definition.
     * @returns {Void}
     */
    _reloadDef() {
        this.resume = false;
        this.bSflValid = true;
        this.instanceId = null;

        this.initScriptHeaderDef();
        this.resetFirstStepAccordionActive();
        this.initStepIndexes();
        this.initJsonDefResponse();
    }

    /**
     * @scope private
     * @description Determines if knowledge is enabled.
     * @returns {boolean}
     */
    isKnowledgeEnabled() {
        let isKBEnabled = false;

        if (
            this.scriptHeaderDef.kbIndex >= 0 &&
            !this._dispOutsideOmni &&
            this.jsonDef.asIndex >= 0 &&
            this.jsonDef.children[this.jsonDef.asIndex].type === 'Step'
        ) {
            isKBEnabled = this.jsonDef.children[this.jsonDef.asIndex].propSetMap.showPersistentComponent[this.scriptHeaderDef.kbIndex];
        }

        return isKBEnabled;
    }

    /**
     * @scope private
     * @description Handles errors.
     * @param {*} error
     * @returns {Void}
     */
    handleError(error) {
        const message = handleErrorReplace(error, this.jsonDef, this.scriptHeaderDef);
        this.hasErrors = true;
        this._errorMsg = message;
    }

    /**
     * @scope private
     * @description Handles all events for 'omnipendingupdates'
     *              - when _pendingUpdates is 0, prev/next navigation is allowed
     *              - when _pendingUpdates is greater than 0, prev/next navigation is not allowed
     * @param {CustomEvent} evt
     * @returns {Void}
     */
    handlePendingUpdates(evt) {
        evt.stopPropagation();

        if (evt.detail.pendingUpdates === true) {
            this._pendingUpdates++;
        } else if (evt.detail.pendingUpdates === false) {
            if (this._pendingUpdates > 0) {
                this._pendingUpdates--;
            }
        }
    }

    /**
     * Handles state change events originating from "CURRENT_PAGE" type navigate actions.
     * @scope private
     * @param {StateChangeEvent} evt
     * @returns {void}
     */
    handleStateChange(evt) {
        const params = normalizeParams(evt.detail);
        if (params.hasOwnProperty('step')) {
            let step = params.step;
            step = isNaN(step) ? this._stepNameIndexMap.get(params.step) : step;
            if (
                step > this.jsonDef.asIndex &&
                this.scriptHeaderDef.propSetMap.allowSaveForLater === true &&
                this.scriptHeaderDef.propSetMap.autoSaveOnStepNext === true
            ) {
                this.autoSflRequired = true;
            }

            this.triggerStepChange(step);
        }
    }

    /**
     * Handles the popstate event, and passes on to stepChange.
     * Keep place holder for completion of [OWC-607].
     * @scope private
     * @returns {void}
     */
    handlePopState() {
        const params = normalizeParams(parseParams(window.location.search));
        if (params.hasOwnProperty('step')) {
            if (params.step !== this.jsonDef.children[this.jsonDef.asIndex].name) {
                const step = isNaN(params.step) ? this._stepNameIndexMap.get(params.step) : params.step;
                this.triggerStepChange(step);
            }
        }
    }

    /**
     * Triggers determines the target index and passes onto navigateTo.
     * Allows for Skipping a head by multiple steps, as long as the data is provided.
     * @scope private
     * @param {(string|number)} step - A string representing the name of a step, or a number representing the step index.
     * @returns {void}
     */
    // eslint-disable-next-line consistent-return
    triggerStepChange(step) {
        if (step === '0' && this.inline) return this.setScriptVisibility();

        this._targetIndex = Number(step);
        const currentIndex = this.jsonDef.hasOwnProperty('asIndex') && !isNaN(Number(this.jsonDef.asIndex)) ? this.jsonDef.asIndex : 0;
        let nextIndex;

        if (this._initialHeaderRender) {
            // If this is the initial header render, we need to start at the beginning.
            nextIndex = 0;
        } else if (this._targetIndex > currentIndex) {
            // If we're traveling forward, we need to kick off the navigation loop with the next index.
            nextIndex = currentIndex + 1;
        } else if (isNaN(this._targetIndex)) {
            this._targetIndex = nextIndex = -1;
        } else {
            // Otherwise we just navigate.
            nextIndex = this._targetIndex;
        }

        delay(0).then(() => this.navigateTo(nextIndex, this.jsonDef.asIndex));
    }

    /**
     * Updates the url parameters in the SEO enabled prev/next buttons.
     * @scope private
     * @returns {void}
     */
    updateSeoNav() {
        let prevStepJsonDef;
        let nextStepJsonDef;

        if (this.jsonDef.asIndex > this.scriptHeaderDef.firstStepIndex) {
            const prevStepIndex = this.getPrevStepIndex(this.jsonDef.asIndex);
            prevStepJsonDef = this.jsonDef.children[prevStepIndex] ? this.jsonDef.children[prevStepIndex] : null;

            this.navButton.previous.targetParams = prevStepJsonDef
                ? `c__step=${prevStepJsonDef.name}${this.handleMergeFieldUtil(
                      this.scriptHeaderDef.propSetMap.additionalSeoParameters,
                      this._elementValueObj,
                      this.scriptHeaderDef.labelMap,
                  )}`
                : null;
        }

        if (this.jsonDef.asIndex < this._lastStepIndex) {
            const nextStepIndex = this.getNextStepIndex(this.jsonDef.asIndex);
            nextStepJsonDef = this.jsonDef.children[nextStepIndex] ? this.jsonDef.children[nextStepIndex] : null;

            this.navButton.next.targetParams = nextStepJsonDef
                ? `c__step=${nextStepJsonDef.name}${this.handleMergeFieldUtil(
                      this.scriptHeaderDef.propSetMap.additionalSeoParameters,
                      this._elementValueObj,
                      this.scriptHeaderDef.labelMap,
                  )}`
                : null;
        } else if (this.hasNext) {
            this.navButton.next.targetParams = `c__step=${this.jsonDef.asIndex + 1}${this.handleMergeFieldUtil(
                this.scriptHeaderDef.propSetMap.additionalSeoParameters,
                this._elementValueObj,
                this.scriptHeaderDef.labelMap,
            )}`;
        }

        this.navButton = { ...this.navButton };
    }

    /**
     * When the script data changes, we need to update the seoNav incase parameters have changed.
     * @param {CustomEvent} evt
     * @scope private
     * @returns {void}
     */
    headerRefresh() {
        if (this._isSeoEnabled) this.updateSeoNav();
    }

    /**
     * Show or hide the omniscript inline launcher.
     * @param {boolean} isVisible - If false, the script body will be hidden, if inline is true then the inline launcher will be shown when hidden.
     * @returns {void}
     */
    setScriptVisibility(isVisible = true) {
        if (isVisible) {
            this.isLauncherVisible = false;
            this.showComp(true);
            if (this.inline) {
                this.navigateTo(0, -1);
            }
        } else {
            this.isLauncherVisible = this.inline;
            this.showComp(false);
        }
    }

    showComp(isVisible = true) {
        this._isOsVisible = isVisible;
        const extraClasses = isVisible ? [] : [`${this._theme}-hide`];

        if (this.flexipageRegionWidth) {
            if (this.flexipageRegionWidth === 'SMALL') {
                this.jsonDef.propSetMap.stepChartPlacement = 'top';
                this.stepChartProps.layout = 'horizontal';
                this.stepChartProps.position = 'top';
            }
            extraClasses.push(`${this._theme}-flexipage-container_${this.flexipageRegionWidth.toLowerCase()}`);
        }

        if (this.jsonDef.propSetMap.fixedFooterOnMobile) {
            extraClasses.push(`${this._theme}-omniscript_mobile-fixed-footer`);
        }

        this.containerClasses =
            this._theme === 'slds' ? sldsContainerClassTmpl(this._theme, extraClasses) : ndsContainerClassTmpl(this._theme, extraClasses);
    }

    /**
     * @scope private
     * @description Displays a modal (default: error modal) based on the config object passed in.
     * @param {ModalConfiguration} config
     * @returns {Void}
     */
    displayModal(config) {
        // destructuring object with default values
        const {
            type = 'error',
            modalHeader = 'Error',
            modalMessage = 'Error',
            buttons = [
                {
                    label: this.allCustomLabelsUtil.OmniOK,
                    key: '0-Ok',
                    handleClick: () => {
                        this.modalEvents = [];
                    },
                },
            ],
            hideHeader = false,
            hideFooter = false,
            triggeredOnStep = true,
        } = config;

        const addModalEvent = Promise.resolve(
            this.modalEvents.push({
                type: type,
                modalHeader: modalHeader,
                modalMessage: modalMessage,
                buttons: buttons,
                hideHeader: hideHeader,
                hideFooter: hideFooter,
                triggeredOnStep: triggeredOnStep,
            }),
        );

        // resolves modal event promise and opens first modal
        Promise.all([addModalEvent]).then(() => {
            this.template.querySelectorAll('[data-omni-key=omnimodal]')[0].openModal();
        });
    }

    /**
     * Checks if we are resuming an OS using the navigation params
     */
    checkResume() {
        // We need to validate we don't have an instanceId from the URL before running all other logic
        if (!this.resume) {
            this._urlParams = normalizeParams(parseParams(window.location.search));
            if (this._urlParams.hasOwnProperty('instanceId')) {
                this.resume = true;
                this.instanceId = this._urlParams.instanceId;
            }
        }
    }
}
