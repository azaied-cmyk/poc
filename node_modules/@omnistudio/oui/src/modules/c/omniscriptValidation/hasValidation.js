/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import { debounce } from 'c/asyncUtils';
import { api, track } from 'lwc';
import { VALIDATION_EVENTS } from './omniscriptValidation';
import { dispatchOmniEvent } from 'c/omniscriptUtils';

/**
 * Mixin adding functionality for input-level omniscript validation.
 * @param {LightningElement} Base
 */
export const HasValidation = Base => {
    return class extends Base {
        _isValid;
        _showValidation;
        _inputSelector = '[data-omni-input]';
        _readOnly = false;
        _readOnlyClass;
        _handleKeyup = debounce(handleKeyup.bind(this), 500);
        _forceJsonToApply = false;

        _messageWhenValueMissing;
        _messageWhenTooShort;
        _messageWhenTooLong;
        _messageWhenBadInput;
        _messageWhenPatternMismatch;
        _messageWhenRangeOverflow;
        _messageWhenRangeUnderflow;
        _messageWhenStepMismatch;
        _messageWhenTypeMismatch;
        _messageWhenMaskIncomplete;
        _needMoreValidation = true;
        _setValueStrict = true;
        @track tabIndex;

        get isValid() {
            return this._isValid;
        }

        set isValid(value) {
            const conditionType = !this._propSetMap.conditionType ? 'Hide if False' : this._propSetMap.conditionType;

            const omniShow = conditionType === 'Hide if False' ? !this._propSetMap.show || this._omniShow : true;
            if (omniShow) {
                if (this._isValid !== value) {
                    if (value && this._isValid === false) {
                        dispatchOmniEvent(this, { jsonPath: this.jsonDef.lwcId }, VALIDATION_EVENTS.VALID);
                        window.console.log('hasValidation validation event - valid ' + this.jsonDef.name);
                    } else if (value === false) {
                        dispatchOmniEvent(this, { jsonPath: this.jsonDef.lwcId }, VALIDATION_EVENTS.INVALID);
                        window.console.log('hasValidation validation event - invalid ' + this.jsonDef.name);
                    }
                } else if (conditionType === 'Hide if False' && this._propSetMap.show && !this._omniSavedShow && !value) {
                    dispatchOmniEvent(this, { jsonPath: this.jsonDef.lwcId }, VALIDATION_EVENTS.INVALID);
                    window.console.log('hasValidation validation event - invalid2 ' + this.jsonDef.name);
                }
            }
            if (conditionType === 'Hide if False' && this._propSetMap.show) {
                this._omniSavedShow = this._omniShow;
            }

            this._isValid = value;
        }

        @api get label() {
            return this._propSetMap.label;
        }

        @api get validationMessage() {
            return this.childInput ? this.childInput.validationMessage : undefined;
        }

        @api get validity() {
            try {
                return this.childInput && this.childInput.validity ? this.childInput.validity : {};
            } catch (err) {
                return {};
            }
        }

        /**
         * Override for applyCallResp, adds check for UI validity.
         * @param {*} json
         * @param {boolean} [bApi=false] - Denotes the method caller is an API response. False indicates user initiated.
         * @param {boolean} [bValidation=false] - Denotes a server side validation response.
         */
        @api applyCallResp(json, bApi = false, bValidation = false) {
            if (json !== undefined) {
                if (!bValidation) {
                    // validateData should only run for bApi = true
                    const result = bApi ? this.validateData(json) : { valid: true, dataToApply: json };
                    let jsonToApply = bApi ? result.dataToApply : json;

                    if (bApi) {
                        if (!result.valid || (this.isEqual(jsonToApply, this.elementValue) && this.reportValidity())) return;

                        if (this.childInput) {
                            const preVal = this.childInput.value;
                            this.setChildInputValue(jsonToApply);
                            // Radio/Select/Multi-select has weird this.childInput.value behavior,
                            // therefore bypass the second validation
                            if (this._needMoreValidation) {
                                if (this._setValueStrict !== false) {
                                    // allow the input to handle data parsing before applying to the json
                                    // only if postVal === jsonToApply, it means that it's valid (if there is mask)
                                    const postVal = this.childInput.value;
                                    if (!this.isEqual(postVal, jsonToApply)) {
                                        // invalid value, restore
                                        jsonToApply = preVal;
                                        this.setChildInputValue(preVal);
                                    }
                                } else {
                                    const postVal = this.childInput.value;
                                    const isDebounce = this.isEqual(preVal, postVal);
                                    const wrapper = isDebounce ? x => Promise.resolve().then(x) : x => x();
                                    wrapper(
                                        this.handleValueSetApi.bind(this, jsonToApply, bApi, bValidation, preVal, isDebounce ? undefined : postVal),
                                    );
                                    //handleValueSetApi deals with the super apply call resp for us, so we escape here
                                    return;
                                }
                            }
                        }
                        // In order for the child input to run it's validation,
                        // we have to allow the cpu to process a cycle.
                        Promise.resolve().then(() => {
                            if (this.reportValidity() || this._forceJsonToApply) {
                                super.applyCallResp(jsonToApply, bApi, bValidation);
                            } else if (this.jsonDef.type === 'Select' && this._dependency && this._propSetMap.required) {
                                //special case for required dependent select
                                super.applyCallResp(jsonToApply, bApi, bValidation);
                            }
                        });
                    } else {
                        if (this._initialRender || this.reportValidity() === true || this._forceJsonToApply) {
                            super.applyCallResp(jsonToApply, bApi, bValidation);
                        }
                    }
                } else {
                    super.applyCallResp(json, bApi, bValidation);
                }
            }
        }

        handleValueSetApi(jsonToApply, bApi, bValidation, preVal, postValA) {
            const postVal = postValA !== undefined ? postValA : this.childInput.value;
            // allow the input to handle data validation, filtering and parsing before applying to the json
            // this is only set due to complicated in component data handling that cannot be easily extracted
            jsonToApply = postVal;
            if (!this.isEqual(jsonToApply, preVal)) {
                if (this.reportValidity() || this._forceJsonToApply) {
                    super.applyCallResp(jsonToApply, bApi, bValidation);
                }
            }
        }

        setChildInputValue(value) {
            if (typeof this.childInput.setValue === 'function') {
                this.childInput.setValue(value);
            } else {
                this.childInput.value = value;
            }
        }

        /**
         * Interface for native DOM checkValidity().
         * Performs custom validation as well as native Constraint Validation API calls.
         * Returns a boolean, but doesn't trigger display of validation messages.
         * @returns {boolean}
         */
        @api checkValidity() {
            if (this.childInput && typeof this.doCustomValidation === 'function') this.doCustomValidation();

            this.isValid = this.childInput ? this.childInput.checkValidity() : true;
            return this.isValid;
        }

        /**
         * Interface for native DOM reportValidity().
         * Performs custom validation as well as native Constraint Validation API calls.
         * Returns a boolean, and triggers the display of validation messages.
         * @returns {boolean}
         */
        @api reportValidity() {
            if (this.childInput && typeof this.doCustomValidation === 'function') this.doCustomValidation();

            // Setting this.isValid will add listeners to hide validation messages as soon as the input is valid.
            this.isValid = this.childInput ? this.childInput.reportValidity() : true;
            this._showValidation = !this.isValid;

            return this.isValid;
        }

        @api focus() {
            if (this.childInput && !this._readOnly) this.childInput.focus();
        }

        setReadOnly(value) {
            if (this.childInput && value === true) {
                this.classList.add(this._readOnlyClass);
                this.setAttribute('aria-disabled', true);
                this.tabIndex = -1;
                this.childInput.blur();
            } else if (this.childInput && !value) {
                this.classList.remove(this._readOnlyClass);
                this.removeAttribute('aria-disabled');
                this.tabIndex = undefined;
            }

            return (this._readOnly = value);
        }

        connectedCallback() {
            this.template.addEventListener('keyup', this._handleKeyup.bind(this));
            this._readOnlyClass = this.layout === 'newport' ? 'nds-read-only' : 'omni-read-only';

            if (typeof super.connectedCallback === 'function') super.connectedCallback();
        }

        initCompVariables() {
            super.initCompVariables();
            this._messageWhenValueMissing = this.allCustomLabelsUtil.OmniRequired;
            this._messageWhenTooShort = `${this.allCustomLabelsUtil.OmniMinLength} ${this._propSetMap.minLength}.`;
            this._messageWhenTooLong = `${this.allCustomLabelsUtil.OmniMaxLength} ${this._propSetMap.maxLength}.`;
            this._messageWhenBadInput = this.allCustomLabelsUtil.OmniValidationBadInput;
            this._messageWhenPatternMismatch = this._propSetMap.ptrnErrText || this.allCustomLabelsUtil.OmniValidationPatternMismatch;
            this._messageWhenRangeOverflow = this.allCustomLabelsUtil.OmniValidationRangeOverflow;
            this._messageWhenRangeUnderflow = this.allCustomLabelsUtil.OmniValidationRangeUnderflow;
            this._messageWhenStepMismatch = this.allCustomLabelsUtil.OmniValidationStepMismatch;
            this._messageWhenTypeMismatch = this.allCustomLabelsUtil.OmniValidationTypeMismatch;
            this._messageWhenMaskIncomplete = this.allCustomLabelsUtil.OmniValidationMaskIncomplete;
        }

        /**
         * @scope private
         * @description Set Custom Validation on input (Used for set error action).
         *              - reportValidity on step for components.
         * @param {*} json
         * @returns {Void}
         */
        setCustomValidation(json) {
            if (this.childInput) {
                this.childInput.setCustomValidity(json);
                this.reportValidity();
                if (!this.isFocusEventAttached) {
                    this.template.addEventListener('focusout', this.onFocusOutErrorElement.bind(this));
                    this.isFocusEventAttached = true;
                }
            }
        }

        onFocusOutErrorElement(event) {
            this.childInput.setCustomValidity('');
            if (this.reportValidity()) {
                this.applyCallResp(event.target.value);
            }
        }

        renderedCallback() {
            if (this._initialRender) {
                // Set the child input, and let the validationAggregator know the validation state.
                this.childInput = this.template.querySelector(this._inputSelector) || this.querySelector(this._inputSelector);
                // For Elements that have no show/hide set up
                // therefore checkValidity() needs to be called here
                // but for the Elements that have show/hide set up, validity will be checked
                // as part of omniShow()
                if (!this._propSetMap.show || ['Readonly if False', 'Optional if False'].includes(this._propSetMap.conditionType)) {
                    this.checkValidity();
                }
            }
            if (this._propSetMap.readOnly !== undefined && this._propSetMap.readOnly !== this._readOnly) this.setReadOnly(this._propSetMap.readOnly);
            if (typeof super.renderedCallback === 'function') super.renderedCallback();
        }

        isEqual(a, b) {
            let bEqual = this.lodashUtil.isEqual(a, b);
            if (!bEqual && ((a === null && b === '') || (b === null && a === ''))) {
                bEqual = true;
            }
            return bEqual;
        }
    };
};

function handleKeyup(evt) {
    // When an input becomes invalid, the user should get immediate feedback
    // that they've corrected their mistake.
    if (this._commitOnChange) {
        if (this.reportValidity()) {
            this.applyCallResp(evt.value);
        }
    } else {
        if (this._showValidation === true) {
            this.reportValidity();
        }
    }
}
