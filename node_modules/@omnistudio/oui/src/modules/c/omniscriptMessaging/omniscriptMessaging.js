/*************************************************************************
 *
 * VLOCITY, INC. CONFIDENTIAL
 * __________________
 *
 *  [2014] - [2020] Vlocity, Inc.
 *  All Rights Reserved.
 *
 * NOTICE:  All information contained herein is, and remains
 * the property of Vlocity, Inc. and its suppliers,
 * if any. The intellectual and technical concepts contained
 * herein are proprietary to Vlocity, Inc. and its suppliers and may be
 * covered by U.S. and Foreign Patents, patents in process, and are
 * protected by trade secret or copyright law. Dissemination of this
 * information and reproduction, modification or reverse-engineering
 * of this material, is prohibited unless prior written permission
 * is obtained from Vlocity, Inc.
 *
 * Build: v234.0.0
 */
import OmniscriptAtomicElement from 'c/omniscriptAtomicElement';
import { isRepeatNotation } from 'c/omniscriptInternalUtils';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import { RUN_MODES } from 'c/omniscriptInternalUtils';
import { track } from 'lwc';
import tmpl from './omniscriptMessaging.html';
import tmpl_nds from './omniscriptMessaging_nds.html';
import tmpl_toast from './omniscriptMessaging_toast.html';

const wrapperClassStatic = {
    slds: 'slds-scoped-notification slds-scoped-notification_form slds-media slds-media_center slds-scoped-notification_light',
    nds: 'nds-is-relative nds-scoped-notification nds-scoped-notification_form',
};

const msgTypeMap = {
    slds: {
        Success: {
            iconName: 'utility:success',
            iconVariant: 'success',
            wrapperClassDynamic: 'slds-scoped-notification--success',
        },
        Comment: {
            iconName: 'utility:comments',
            iconVariant: 'default',
        },
        Warning: {
            iconName: 'utility:warning',
            iconVariant: 'warning',
            wrapperClassDynamic: 'slds-scoped-notification--warning',
        },
        Requirement: {
            iconName: 'utility:error',
            iconVariant: 'error',
            ariaRole: 'alert',
            wrapperClassDynamic: 'slds-scoped-notification--error',
        },
        empty: {
            iconName: null,
            iconVariant: null,
        },
    },
    nds: {
        Success: {
            iconName: 'utility:check',
            iconVariant: 'success',
        },
        Comment: {
            iconName: 'utility:chat',
            iconVariant: 'default',
        },
        Warning: {
            iconName: 'utility:warning',
            iconVariant: 'warning',
        },
        Requirement: {
            iconName: 'utility:close',
            iconVariant: 'error',
            textClass: 'nds-text-color--error',
            ariaRole: 'alert',
            wrapperClassDynamic: 'nds-scoped-notification--error',
        },
        empty: {
            iconName: null,
            iconVariant: null,
        },
    },
};
/**
 * @module ns/omniscriptMessaging
 * @extends OmniscriptAtomicElement
 * @typicalname omniscriptMessaging
 */
export default class OmniscriptMessaging extends OmniscriptAtomicElement {
    _forceJsonToApply = true;
    _showLabel;
    ariaRole = 'status';
    /**
     * Data store for text of message.
     * @type String
     * @scope track (private)
     */
    @track messageText;
    /**
     * Data store for type of message.
     * @type String
     * @scope track (private)
     */
    @track messageType;

    /**
     * Overwrites inherited initCompVariables. This method is executed once during connectedCallback.
     * @scope private
     * @returns {void}
     */
    initCompVariables() {
        super.initCompVariables();
        this._showLabel = !this._propSetMap.hideLabel;
    }

    get validationMessage() {
        return this.messageText;
    }

    get wrapperClass() {
        return wrapperClassStatic[this._theme] + ' ' + this.wrapperClassDynamic;
    }

    get isToast() {
        return this._propSetMap.showMessageAs === 'toast';
    }

    /**
     * Special function to determine if component is valid.
     * @scope private
     * @returns {Boolean}
     */
    evaluateValidity() {
        const messageType = this.messageType || 'empty';
        return !!(messageType !== 'Requirement');
    }

    /**
     * removes the tabindex element from the event target
     * @param {Event} event - the spawning  element.
     * @scope private
     * @returns {void}
     */
    removeTabIndex(event) {
        event.target.removeAttribute('tabindex');
    }

    /**
     * checkValidity should return a Boolean value true, if the input is valid, false if invalid.
     * @returns {Boolean}
     * @scope public
     */
    checkValidity() {
        this.isValid = this.evaluateValidity();
        return this.isValid;
    }

    /**
     * reportValidity should return the value of checkValidity, and trigger the display of any
     * validation messages as well.
     * @returns {Boolean}
     * @scope public
     */
    reportValidity() {
        this.isValid = this.evaluateValidity();
        this._showValidation = !this.isValid;
        return this.isValid;
    }

    showToast() {
        if (this._isDesignMode || !this.messageText) {
            // don't show anything in design mode
            return;
        }
        // in debug mode we're not able to show toast using the LWC api
        if (RUN_MODES.DEBUG === this.runMode) {
            this.dispatchEvent(
                new CustomEvent('lightning__showtoast', {
                    bubbles: true,
                    composed: true,
                    detail: {
                        title: this.messageText,
                        variant: this.getToastVariant(),
                        mode: this.getToastMode(),
                    },
                }),
            );
        } else {
            const event = new ShowToastEvent({
                title: this.messageText,
                variant: this.getToastVariant(),
                mode: this.getToastMode(),
            });
            this.dispatchEvent(event);
        }
    }

    getToastVariant() {
        if (this.messageType === 'Requirement') {
            return 'error';
        }
        if (this.messageType === 'Success') {
            return 'success';
        }
        if (this.messageType === 'Warning') {
            return 'warning';
        }
        return 'info';
    }

    getToastMode() {
        return this._propSetMap.toastMode || 'dismissible';
    }

    /**
     * focuses the input. Overrides from htmlElement. Focuses if from requirement, but only temporarily.
     * @return {void}
     * @scope public
     */
    focus() {
        if (this.messageType === 'Requirement') {
            if (this.isToast) {
                this.showToast();
            } else {
                let focusTarget = this.wrapperEle;
                focusTarget.setAttribute('tabindex', -1);
                focusTarget.focus();
                focusTarget.addEventListener('blur', this.removeTabIndex, { once: true });
            }
        }
    }

    /**
     * Overwrites inherited method that gets triggered when data json changes.
     * @return {void}
     * @scope private
     */
    stateRefresh() {
        const previousMessageType = this.messageType;
        const currentResult = this.evalConditionUtil(this.jsonDef, 'validate', this);
        const msgJson = (this._propSetMap.messages && this._propSetMap.messages.find(x => x.active && x.value === currentResult)) || {
            type: 'empty',
            text: null,
        };
        Object.assign(
            this,
            {
                messageText: this.handleMergeFieldUtil(
                    msgJson.text,
                    this.jsonData,
                    this.scriptHeaderDef.labelMap,
                    isRepeatNotation(msgJson.text) ? this.jsonDef.JSONPath : null,
                ),
                messageType: msgJson.type,
            },
            {
                iconName: null,
                iconVariant: null,
                textClass: null,
                ariaRole: 'status',
                wrapperClassDynamic: '',
            },
            msgTypeMap[this._theme][msgJson.type],
        );
        this.applyCallResp(currentResult);

        if (this._propSetMap.showMessageAs === 'toast' && this.messageType !== previousMessageType) {
            this.showToast();
        }
    }

    /**
     * Overwrites native LWC render
     * @return {void}
     * @scope private
     */
    render() {
        if (this.isToast) {
            return tmpl_toast;
        }
        return this.layout === 'newport' ? tmpl_nds : tmpl;
    }

    /**
     * Overwrites native LWC renderedCallback
     * @return {void}
     * @scope private
     */
    renderedCallback() {
        if (this._initialRender) {
            this.wrapperEle = this.template.querySelector('[role]');
        }
        if (typeof super.renderedCallback === 'function') super.renderedCallback();
    }
}
